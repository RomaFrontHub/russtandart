/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ ! function(e, t) { "use strict"; "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function(e) { if (!e.document) throw new Error("jQuery requires a window with a document"); return t(e) } : t(e) }("undefined" != typeof window ? window : this, function(C, e) {
    "use strict";
    var t = [],
        r = Object.getPrototypeOf,
        s = t.slice,
        g = t.flat ? function(e) { return t.flat.call(e) } : function(e) { return t.concat.apply([], e) },
        u = t.push,
        i = t.indexOf,
        n = {},
        o = n.toString,
        v = n.hasOwnProperty,
        a = v.toString,
        l = a.call(Object),
        y = {},
        m = function(e) { return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item },
        x = function(e) { return null != e && e === e.window },
        E = C.document,
        c = { type: !0, src: !0, nonce: !0, noModule: !0 };

    function b(e, t, n) {
        var r, i, o = (n = n || E).createElement("script");
        if (o.text = e, t)
            for (r in c)(i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i);
        n.head.appendChild(o).parentNode.removeChild(o)
    }

    function w(e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[o.call(e)] || "object" : typeof e }
    var f = "3.6.0",
        S = function(e, t) { return new S.fn.init(e, t) };

    function p(e) {
        var t = !!e && "length" in e && e.length,
            n = w(e);
        return !m(e) && !x(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e)
    }
    S.fn = S.prototype = {
        jquery: f,
        constructor: S,
        length: 0,
        toArray: function() { return s.call(this) },
        get: function(e) { return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e] },
        pushStack: function(e) { var t = S.merge(this.constructor(), e); return t.prevObject = this, t },
        each: function(e) { return S.each(this, e) },
        map: function(n) { return this.pushStack(S.map(this, function(e, t) { return n.call(e, t, e) })) },
        slice: function() { return this.pushStack(s.apply(this, arguments)) },
        first: function() { return this.eq(0) },
        last: function() { return this.eq(-1) },
        even: function() { return this.pushStack(S.grep(this, function(e, t) { return (t + 1) % 2 })) },
        odd: function() { return this.pushStack(S.grep(this, function(e, t) { return t % 2 })) },
        eq: function(e) {
            var t = this.length,
                n = +e + (e < 0 ? t : 0);
            return this.pushStack(0 <= n && n < t ? [this[n]] : [])
        },
        end: function() { return this.prevObject || this.constructor() },
        push: u,
        sort: t.sort,
        splice: t.splice
    }, S.extend = S.fn.extend = function() {
        var e, t, n, r, i, o, a = arguments[0] || {},
            s = 1,
            u = arguments.length,
            l = !1;
        for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || m(a) || (a = {}), s === u && (a = this, s--); s < u; s++)
            if (null != (e = arguments[s]))
                for (t in e) r = e[t], "__proto__" !== t && a !== r && (l && r && (S.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || S.isPlainObject(n) ? n : {}, i = !1, a[t] = S.extend(l, o, r)) : void 0 !== r && (a[t] = r));
        return a
    }, S.extend({
        expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(e) { throw new Error(e) },
        noop: function() {},
        isPlainObject: function(e) { var t, n; return !(!e || "[object Object]" !== o.call(e)) && (!(t = r(e)) || "function" == typeof(n = v.call(t, "constructor") && t.constructor) && a.call(n) === l) },
        isEmptyObject: function(e) { var t; for (t in e) return !1; return !0 },
        globalEval: function(e, t, n) { b(e, { nonce: t && t.nonce }, n) },
        each: function(e, t) {
            var n, r = 0;
            if (p(e)) {
                for (n = e.length; r < n; r++)
                    if (!1 === t.call(e[r], r, e[r])) break
            } else
                for (r in e)
                    if (!1 === t.call(e[r], r, e[r])) break; return e
        },
        makeArray: function(e, t) { var n = t || []; return null != e && (p(Object(e)) ? S.merge(n, "string" == typeof e ? [e] : e) : u.call(n, e)), n },
        inArray: function(e, t, n) { return null == t ? -1 : i.call(t, e, n) },
        merge: function(e, t) { for (var n = +t.length, r = 0, i = e.length; r < n; r++) e[i++] = t[r]; return e.length = i, e },
        grep: function(e, t, n) { for (var r = [], i = 0, o = e.length, a = !n; i < o; i++) !t(e[i], i) !== a && r.push(e[i]); return r },
        map: function(e, t, n) {
            var r, i, o = 0,
                a = [];
            if (p(e))
                for (r = e.length; o < r; o++) null != (i = t(e[o], o, n)) && a.push(i);
            else
                for (o in e) null != (i = t(e[o], o, n)) && a.push(i);
            return g(a)
        },
        guid: 1,
        support: y
    }), "function" == typeof Symbol && (S.fn[Symbol.iterator] = t[Symbol.iterator]), S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(e, t) { n["[object " + t + "]"] = t.toLowerCase() });
    var d = function(n) {
        var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E, v, s, c, y, S = "sizzle" + 1 * new Date,
            p = n.document,
            k = 0,
            r = 0,
            m = ue(),
            x = ue(),
            A = ue(),
            N = ue(),
            j = function(e, t) { return e === t && (l = !0), 0 },
            D = {}.hasOwnProperty,
            t = [],
            q = t.pop,
            L = t.push,
            H = t.push,
            O = t.slice,
            P = function(e, t) {
                for (var n = 0, r = e.length; n < r; n++)
                    if (e[n] === t) return n;
                return -1
            },
            R = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            M = "[\\x20\\t\\r\\n\\f]",
            I = "(?:\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
            W = "\\[" + M + "*(" + I + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + M + "*\\]",
            F = ":(" + I + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + W + ")*)|.*)\\)|)",
            B = new RegExp(M + "+", "g"),
            $ = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"),
            _ = new RegExp("^" + M + "*," + M + "*"),
            z = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"),
            U = new RegExp(M + "|>"),
            X = new RegExp(F),
            V = new RegExp("^" + I + "$"),
            G = { ID: new RegExp("^#(" + I + ")"), CLASS: new RegExp("^\\.(" + I + ")"), TAG: new RegExp("^(" + I + "|[*])"), ATTR: new RegExp("^" + W), PSEUDO: new RegExp("^" + F), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"), bool: new RegExp("^(?:" + R + ")$", "i"), needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i") },
            Y = /HTML$/i,
            Q = /^(?:input|select|textarea|button)$/i,
            J = /^h\d$/i,
            K = /^[^{]+\{\s*\[native \w/,
            Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            ee = /[+~]/,
            te = new RegExp("\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\([^\\r\\n\\f])", "g"),
            ne = function(e, t) { var n = "0x" + e.slice(1) - 65536; return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)) },
            re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
            ie = function(e, t) { return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e },
            oe = function() { T() },
            ae = be(function(e) { return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase() }, { dir: "parentNode", next: "legend" });
        try { H.apply(t = O.call(p.childNodes), p.childNodes), t[p.childNodes.length].nodeType } catch (e) {
            H = {
                apply: t.length ? function(e, t) { L.apply(e, O.call(t)) } : function(e, t) {
                    var n = e.length,
                        r = 0;
                    while (e[n++] = t[r++]);
                    e.length = n - 1
                }
            }
        }

        function se(t, e, n, r) {
            var i, o, a, s, u, l, c, f = e && e.ownerDocument,
                p = e ? e.nodeType : 9;
            if (n = n || [], "string" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p) return n;
            if (!r && (T(e), e = e || C, E)) {
                if (11 !== p && (u = Z.exec(t)))
                    if (i = u[1]) { if (9 === p) { if (!(a = e.getElementById(i))) return n; if (a.id === i) return n.push(a), n } else if (f && (a = f.getElementById(i)) && y(e, a) && a.id === i) return n.push(a), n } else { if (u[2]) return H.apply(n, e.getElementsByTagName(t)), n; if ((i = u[3]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply(n, e.getElementsByClassName(i)), n }
                if (d.qsa && !N[t + " "] && (!v || !v.test(t)) && (1 !== p || "object" !== e.nodeName.toLowerCase())) {
                    if (c = t, f = e, 1 === p && (U.test(t) || z.test(t))) {
                        (f = ee.test(t) && ye(e.parentNode) || e) === e && d.scope || ((s = e.getAttribute("id")) ? s = s.replace(re, ie) : e.setAttribute("id", s = S)), o = (l = h(t)).length;
                        while (o--) l[o] = (s ? "#" + s : ":scope") + " " + xe(l[o]);
                        c = l.join(",")
                    }
                    try { return H.apply(n, f.querySelectorAll(c)), n } catch (e) { N(t, !0) } finally { s === S && e.removeAttribute("id") }
                }
            }
            return g(t.replace($, "$1"), e, n, r)
        }

        function ue() { var r = []; return function e(t, n) { return r.push(t + " ") > b.cacheLength && delete e[r.shift()], e[t + " "] = n } }

        function le(e) { return e[S] = !0, e }

        function ce(e) { var t = C.createElement("fieldset"); try { return !!e(t) } catch (e) { return !1 } finally { t.parentNode && t.parentNode.removeChild(t), t = null } }

        function fe(e, t) {
            var n = e.split("|"),
                r = n.length;
            while (r--) b.attrHandle[n[r]] = t
        }

        function pe(e, t) {
            var n = t && e,
                r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
            if (r) return r;
            if (n)
                while (n = n.nextSibling)
                    if (n === t) return -1;
            return e ? 1 : -1
        }

        function de(t) { return function(e) { return "input" === e.nodeName.toLowerCase() && e.type === t } }

        function he(n) { return function(e) { var t = e.nodeName.toLowerCase(); return ("input" === t || "button" === t) && e.type === n } }

        function ge(t) { return function(e) { return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ae(e) === t : e.disabled === t : "label" in e && e.disabled === t } }

        function ve(a) {
            return le(function(o) {
                return o = +o, le(function(e, t) {
                    var n, r = a([], e.length, o),
                        i = r.length;
                    while (i--) e[n = r[i]] && (e[n] = !(t[n] = e[n]))
                })
            })
        }

        function ye(e) { return e && "undefined" != typeof e.getElementsByTagName && e }
        for (e in d = se.support = {}, i = se.isXML = function(e) {
                var t = e && e.namespaceURI,
                    n = e && (e.ownerDocument || e).documentElement;
                return !Y.test(t || n && n.nodeName || "HTML")
            }, T = se.setDocument = function(e) {
                var t, n, r = e ? e.ownerDocument || e : p;
                return r != C && 9 === r.nodeType && r.documentElement && (a = (C = r).documentElement, E = !i(C), p != C && (n = C.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", oe, !1) : n.attachEvent && n.attachEvent("onunload", oe)), d.scope = ce(function(e) { return a.appendChild(e).appendChild(C.createElement("div")), "undefined" != typeof e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length }), d.attributes = ce(function(e) { return e.className = "i", !e.getAttribute("className") }), d.getElementsByTagName = ce(function(e) { return e.appendChild(C.createComment("")), !e.getElementsByTagName("*").length }), d.getElementsByClassName = K.test(C.getElementsByClassName), d.getById = ce(function(e) { return a.appendChild(e).id = S, !C.getElementsByName || !C.getElementsByName(S).length }), d.getById ? (b.filter.ID = function(e) { var t = e.replace(te, ne); return function(e) { return e.getAttribute("id") === t } }, b.find.ID = function(e, t) { if ("undefined" != typeof t.getElementById && E) { var n = t.getElementById(e); return n ? [n] : [] } }) : (b.filter.ID = function(e) { var n = e.replace(te, ne); return function(e) { var t = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id"); return t && t.value === n } }, b.find.ID = function(e, t) {
                    if ("undefined" != typeof t.getElementById && E) {
                        var n, r, i, o = t.getElementById(e);
                        if (o) {
                            if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
                            i = t.getElementsByName(e), r = 0;
                            while (o = i[r++])
                                if ((n = o.getAttributeNode("id")) && n.value === e) return [o]
                        }
                        return []
                    }
                }), b.find.TAG = d.getElementsByTagName ? function(e, t) { return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0 } : function(e, t) {
                    var n, r = [],
                        i = 0,
                        o = t.getElementsByTagName(e);
                    if ("*" === e) { while (n = o[i++]) 1 === n.nodeType && r.push(n); return r }
                    return o
                }, b.find.CLASS = d.getElementsByClassName && function(e, t) { if ("undefined" != typeof t.getElementsByClassName && E) return t.getElementsByClassName(e) }, s = [], v = [], (d.qsa = K.test(C.querySelectorAll)) && (ce(function(e) {
                    var t;
                    a.appendChild(e).innerHTML = "<a id='" + S + "'></a><select id='" + S + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || v.push("\\[" + M + "*(?:value|" + R + ")"), e.querySelectorAll("[id~=" + S + "-]").length || v.push("~="), (t = C.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || v.push("\\[" + M + "*name" + M + "*=" + M + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || v.push(":checked"), e.querySelectorAll("a#" + S + "+*").length || v.push(".#.+[+~]"), e.querySelectorAll("\\\f"), v.push("[\\r\\n\\f]")
                }), ce(function(e) {
                    e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                    var t = C.createElement("input");
                    t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && v.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), v.push(",.*:")
                })), (d.matchesSelector = K.test(c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function(e) { d.disconnectedMatch = c.call(e, "*"), c.call(e, "[s!='']:x"), s.push("!=", F) }), v = v.length && new RegExp(v.join("|")), s = s.length && new RegExp(s.join("|")), t = K.test(a.compareDocumentPosition), y = t || K.test(a.contains) ? function(e, t) {
                    var n = 9 === e.nodeType ? e.documentElement : e,
                        r = t && t.parentNode;
                    return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))
                } : function(e, t) {
                    if (t)
                        while (t = t.parentNode)
                            if (t === e) return !0;
                    return !1
                }, j = t ? function(e, t) { if (e === t) return l = !0, 0; var n = !e.compareDocumentPosition - !t.compareDocumentPosition; return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === n ? e == C || e.ownerDocument == p && y(p, e) ? -1 : t == C || t.ownerDocument == p && y(p, t) ? 1 : u ? P(u, e) - P(u, t) : 0 : 4 & n ? -1 : 1) } : function(e, t) {
                    if (e === t) return l = !0, 0;
                    var n, r = 0,
                        i = e.parentNode,
                        o = t.parentNode,
                        a = [e],
                        s = [t];
                    if (!i || !o) return e == C ? -1 : t == C ? 1 : i ? -1 : o ? 1 : u ? P(u, e) - P(u, t) : 0;
                    if (i === o) return pe(e, t);
                    n = e;
                    while (n = n.parentNode) a.unshift(n);
                    n = t;
                    while (n = n.parentNode) s.unshift(n);
                    while (a[r] === s[r]) r++;
                    return r ? pe(a[r], s[r]) : a[r] == p ? -1 : s[r] == p ? 1 : 0
                }), C
            }, se.matches = function(e, t) { return se(e, null, null, t) }, se.matchesSelector = function(e, t) {
                if (T(e), d.matchesSelector && E && !N[t + " "] && (!s || !s.test(t)) && (!v || !v.test(t))) try { var n = c.call(e, t); if (n || d.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n } catch (e) { N(t, !0) }
                return 0 < se(t, C, null, [e]).length
            }, se.contains = function(e, t) { return (e.ownerDocument || e) != C && T(e), y(e, t) }, se.attr = function(e, t) {
                (e.ownerDocument || e) != C && T(e);
                var n = b.attrHandle[t.toLowerCase()],
                    r = n && D.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !E) : void 0;
                return void 0 !== r ? r : d.attributes || !E ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
            }, se.escape = function(e) { return (e + "").replace(re, ie) }, se.error = function(e) { throw new Error("Syntax error, unrecognized expression: " + e) }, se.uniqueSort = function(e) {
                var t, n = [],
                    r = 0,
                    i = 0;
                if (l = !d.detectDuplicates, u = !d.sortStable && e.slice(0), e.sort(j), l) { while (t = e[i++]) t === e[i] && (r = n.push(i)); while (r--) e.splice(n[r], 1) }
                return u = null, e
            }, o = se.getText = function(e) {
                var t, n = "",
                    r = 0,
                    i = e.nodeType;
                if (i) { if (1 === i || 9 === i || 11 === i) { if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling) n += o(e) } else if (3 === i || 4 === i) return e.nodeValue } else
                    while (t = e[r++]) n += o(t);
                return n
            }, (b = se.selectors = {
                cacheLength: 50,
                createPseudo: le,
                match: G,
                attrHandle: {},
                find: {},
                relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } },
                preFilter: { ATTR: function(e) { return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4) }, CHILD: function(e) { return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e }, PSEUDO: function(e) { var t, n = !e[6] && e[2]; return G.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = h(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)) } },
                filter: {
                    TAG: function(e) { var t = e.replace(te, ne).toLowerCase(); return "*" === e ? function() { return !0 } : function(e) { return e.nodeName && e.nodeName.toLowerCase() === t } },
                    CLASS: function(e) { var t = m[e + " "]; return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && m(e, function(e) { return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "") }) },
                    ATTR: function(n, r, i) { return function(e) { var t = se.attr(e, n); return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(B, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-")) } },
                    CHILD: function(h, e, t, g, v) {
                        var y = "nth" !== h.slice(0, 3),
                            m = "last" !== h.slice(-4),
                            x = "of-type" === e;
                        return 1 === g && 0 === v ? function(e) { return !!e.parentNode } : function(e, t, n) {
                            var r, i, o, a, s, u, l = y !== m ? "nextSibling" : "previousSibling",
                                c = e.parentNode,
                                f = x && e.nodeName.toLowerCase(),
                                p = !n && !x,
                                d = !1;
                            if (c) {
                                if (y) {
                                    while (l) {
                                        a = e;
                                        while (a = a[l])
                                            if (x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) return !1;
                                        u = l = "only" === h && !u && "nextSibling"
                                    }
                                    return !0
                                }
                                if (u = [m ? c.firstChild : c.lastChild], m && p) {
                                    d = (s = (r = (i = (o = (a = c)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]) && r[2], a = s && c.childNodes[s];
                                    while (a = ++s && a && a[l] || (d = s = 0) || u.pop())
                                        if (1 === a.nodeType && ++d && a === e) { i[h] = [k, s, d]; break }
                                } else if (p && (d = s = (r = (i = (o = (a = e)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]), !1 === d)
                                    while (a = ++s && a && a[l] || (d = s = 0) || u.pop())
                                        if ((x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) && ++d && (p && ((i = (o = a[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] = [k, d]), a === e)) break;
                                return (d -= v) === g || d % g == 0 && 0 <= d / g
                            }
                        }
                    },
                    PSEUDO: function(e, o) {
                        var t, a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e);
                        return a[S] ? a(o) : 1 < a.length ? (t = [e, e, "", o], b.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function(e, t) {
                            var n, r = a(e, o),
                                i = r.length;
                            while (i--) e[n = P(e, r[i])] = !(t[n] = r[i])
                        }) : function(e) { return a(e, 0, t) }) : a
                    }
                },
                pseudos: {
                    not: le(function(e) {
                        var r = [],
                            i = [],
                            s = f(e.replace($, "$1"));
                        return s[S] ? le(function(e, t, n, r) {
                            var i, o = s(e, null, r, []),
                                a = e.length;
                            while (a--)(i = o[a]) && (e[a] = !(t[a] = i))
                        }) : function(e, t, n) { return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop() }
                    }),
                    has: le(function(t) { return function(e) { return 0 < se(t, e).length } }),
                    contains: le(function(t) {
                        return t = t.replace(te, ne),
                            function(e) { return -1 < (e.textContent || o(e)).indexOf(t) }
                    }),
                    lang: le(function(n) {
                        return V.test(n || "") || se.error("unsupported lang: " + n), n = n.replace(te, ne).toLowerCase(),
                            function(e) {
                                var t;
                                do { if (t = E ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-") } while ((e = e.parentNode) && 1 === e.nodeType);
                                return !1
                            }
                    }),
                    target: function(e) { var t = n.location && n.location.hash; return t && t.slice(1) === e.id },
                    root: function(e) { return e === a },
                    focus: function(e) { return e === C.activeElement && (!C.hasFocus || C.hasFocus()) && !!(e.type || e.href || ~e.tabIndex) },
                    enabled: ge(!1),
                    disabled: ge(!0),
                    checked: function(e) { var t = e.nodeName.toLowerCase(); return "input" === t && !!e.checked || "option" === t && !!e.selected },
                    selected: function(e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected },
                    empty: function(e) {
                        for (e = e.firstChild; e; e = e.nextSibling)
                            if (e.nodeType < 6) return !1;
                        return !0
                    },
                    parent: function(e) { return !b.pseudos.empty(e) },
                    header: function(e) { return J.test(e.nodeName) },
                    input: function(e) { return Q.test(e.nodeName) },
                    button: function(e) { var t = e.nodeName.toLowerCase(); return "input" === t && "button" === e.type || "button" === t },
                    text: function(e) { var t; return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase()) },
                    first: ve(function() { return [0] }),
                    last: ve(function(e, t) { return [t - 1] }),
                    eq: ve(function(e, t, n) { return [n < 0 ? n + t : n] }),
                    even: ve(function(e, t) { for (var n = 0; n < t; n += 2) e.push(n); return e }),
                    odd: ve(function(e, t) { for (var n = 1; n < t; n += 2) e.push(n); return e }),
                    lt: ve(function(e, t, n) { for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r;) e.push(r); return e }),
                    gt: ve(function(e, t, n) { for (var r = n < 0 ? n + t : n; ++r < t;) e.push(r); return e })
                }
            }).pseudos.nth = b.pseudos.eq, { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) b.pseudos[e] = de(e);
        for (e in { submit: !0, reset: !0 }) b.pseudos[e] = he(e);

        function me() {}

        function xe(e) { for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value; return r }

        function be(s, e, t) {
            var u = e.dir,
                l = e.next,
                c = l || u,
                f = t && "parentNode" === c,
                p = r++;
            return e.first ? function(e, t, n) {
                while (e = e[u])
                    if (1 === e.nodeType || f) return s(e, t, n);
                return !1
            } : function(e, t, n) {
                var r, i, o, a = [k, p];
                if (n) {
                    while (e = e[u])
                        if ((1 === e.nodeType || f) && s(e, t, n)) return !0
                } else
                    while (e = e[u])
                        if (1 === e.nodeType || f)
                            if (i = (o = e[S] || (e[S] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase()) e = e[u] || e;
                            else { if ((r = i[c]) && r[0] === k && r[1] === p) return a[2] = r[2]; if ((i[c] = a)[2] = s(e, t, n)) return !0 } return !1
            }
        }

        function we(i) {
            return 1 < i.length ? function(e, t, n) {
                var r = i.length;
                while (r--)
                    if (!i[r](e, t, n)) return !1;
                return !0
            } : i[0]
        }

        function Te(e, t, n, r, i) { for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s))); return a }

        function Ce(d, h, g, v, y, e) {
            return v && !v[S] && (v = Ce(v)), y && !y[S] && (y = Ce(y, e)), le(function(e, t, n, r) {
                var i, o, a, s = [],
                    u = [],
                    l = t.length,
                    c = e || function(e, t, n) { for (var r = 0, i = t.length; r < i; r++) se(e, t[r], n); return n }(h || "*", n.nodeType ? [n] : n, []),
                    f = !d || !e && h ? c : Te(c, s, d, n, r),
                    p = g ? y || (e ? d : l || v) ? [] : t : f;
                if (g && g(f, p, n, r), v) { i = Te(p, u), v(i, [], n, r), o = i.length; while (o--)(a = i[o]) && (p[u[o]] = !(f[u[o]] = a)) }
                if (e) {
                    if (y || d) {
                        if (y) {
                            i = [], o = p.length;
                            while (o--)(a = p[o]) && i.push(f[o] = a);
                            y(null, p = [], i, r)
                        }
                        o = p.length;
                        while (o--)(a = p[o]) && -1 < (i = y ? P(e, a) : s[o]) && (e[i] = !(t[i] = a))
                    }
                } else p = Te(p === t ? p.splice(l, p.length) : p), y ? y(null, t, p, r) : H.apply(t, p)
            })
        }

        function Ee(e) {
            for (var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, u = be(function(e) { return e === i }, a, !0), l = be(function(e) { return -1 < P(i, e) }, a, !0), c = [function(e, t, n) { var r = !o && (n || t !== w) || ((i = t).nodeType ? u(e, t, n) : l(e, t, n)); return i = null, r }]; s < r; s++)
                if (t = b.relative[e[s].type]) c = [be(we(c), t)];
                else {
                    if ((t = b.filter[e[s].type].apply(null, e[s].matches))[S]) {
                        for (n = ++s; n < r; n++)
                            if (b.relative[e[n].type]) break;
                        return Ce(1 < s && we(c), 1 < s && xe(e.slice(0, s - 1).concat({ value: " " === e[s - 2].type ? "*" : "" })).replace($, "$1"), t, s < n && Ee(e.slice(s, n)), n < r && Ee(e = e.slice(n)), n < r && xe(e))
                    }
                    c.push(t)
                }
            return we(c)
        }
        return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function(e, t) {
            var n, r, i, o, a, s, u, l = x[e + " "];
            if (l) return t ? 0 : l.slice(0);
            a = e, s = [], u = b.preFilter;
            while (a) { for (o in n && !(r = _.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = z.exec(a)) && (n = r.shift(), i.push({ value: n, type: r[0].replace($, " ") }), a = a.slice(n.length)), b.filter) !(r = G[o].exec(a)) || u[o] && !(r = u[o](r)) || (n = r.shift(), i.push({ value: n, type: o, matches: r }), a = a.slice(n.length)); if (!n) break }
            return t ? a.length : a ? se.error(e) : x(e, s).slice(0)
        }, f = se.compile = function(e, t) {
            var n, v, y, m, x, r, i = [],
                o = [],
                a = A[e + " "];
            if (!a) {
                t || (t = h(e)), n = t.length;
                while (n--)(a = Ee(t[n]))[S] ? i.push(a) : o.push(a);
                (a = A(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function(e, t, n, r, i) {
                    var o, a, s, u = 0,
                        l = "0",
                        c = e && [],
                        f = [],
                        p = w,
                        d = e || x && b.find.TAG("*", i),
                        h = k += null == p ? 1 : Math.random() || .1,
                        g = d.length;
                    for (i && (w = t == C || t || i); l !== g && null != (o = d[l]); l++) {
                        if (x && o) {
                            a = 0, t || o.ownerDocument == C || (T(o), n = !E);
                            while (s = v[a++])
                                if (s(o, t || C, n)) { r.push(o); break }
                            i && (k = h)
                        }
                        m && ((o = !s && o) && u--, e && c.push(o))
                    }
                    if (u += l, m && l !== u) {
                        a = 0;
                        while (s = y[a++]) s(c, f, t, n);
                        if (e) {
                            if (0 < u)
                                while (l--) c[l] || f[l] || (f[l] = q.call(r));
                            f = Te(f)
                        }
                        H.apply(r, f), i && !e && 0 < f.length && 1 < u + y.length && se.uniqueSort(r)
                    }
                    return i && (k = h, w = p), c
                }, m ? le(r) : r))).selector = e
            }
            return a
        }, g = se.select = function(e, t, n, r) {
            var i, o, a, s, u, l = "function" == typeof e && e,
                c = !r && h(e = l.selector || e);
            if (n = n || [], 1 === c.length) {
                if (2 < (o = c[0] = c[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && E && b.relative[o[1].type]) {
                    if (!(t = (b.find.ID(a.matches[0].replace(te, ne), t) || [])[0])) return n;
                    l && (t = t.parentNode), e = e.slice(o.shift().value.length)
                }
                i = G.needsContext.test(e) ? 0 : o.length;
                while (i--) { if (a = o[i], b.relative[s = a.type]) break; if ((u = b.find[s]) && (r = u(a.matches[0].replace(te, ne), ee.test(o[0].type) && ye(t.parentNode) || t))) { if (o.splice(i, 1), !(e = r.length && xe(o))) return H.apply(n, r), n; break } }
            }
            return (l || f(e, c))(r, t, !E, n, !t || ee.test(e) && ye(t.parentNode) || t), n
        }, d.sortStable = S.split("").sort(j).join("") === S, d.detectDuplicates = !!l, T(), d.sortDetached = ce(function(e) { return 1 & e.compareDocumentPosition(C.createElement("fieldset")) }), ce(function(e) { return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href") }) || fe("type|href|height|width", function(e, t, n) { if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2) }), d.attributes && ce(function(e) { return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value") }) || fe("value", function(e, t, n) { if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue }), ce(function(e) { return null == e.getAttribute("disabled") }) || fe(R, function(e, t, n) { var r; if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null }), se
    }(C);
    S.find = d, S.expr = d.selectors, S.expr[":"] = S.expr.pseudos, S.uniqueSort = S.unique = d.uniqueSort, S.text = d.getText, S.isXMLDoc = d.isXML, S.contains = d.contains, S.escapeSelector = d.escape;
    var h = function(e, t, n) {
            var r = [],
                i = void 0 !== n;
            while ((e = e[t]) && 9 !== e.nodeType)
                if (1 === e.nodeType) {
                    if (i && S(e).is(n)) break;
                    r.push(e)
                }
            return r
        },
        T = function(e, t) { for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e); return n },
        k = S.expr.match.needsContext;

    function A(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() }
    var N = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

    function j(e, n, r) { return m(n) ? S.grep(e, function(e, t) { return !!n.call(e, t, e) !== r }) : n.nodeType ? S.grep(e, function(e) { return e === n !== r }) : "string" != typeof n ? S.grep(e, function(e) { return -1 < i.call(n, e) !== r }) : S.filter(n, e, r) }
    S.filter = function(e, t, n) { var r = t[0]; return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? S.find.matchesSelector(r, e) ? [r] : [] : S.find.matches(e, S.grep(t, function(e) { return 1 === e.nodeType })) }, S.fn.extend({
        find: function(e) {
            var t, n, r = this.length,
                i = this;
            if ("string" != typeof e) return this.pushStack(S(e).filter(function() {
                for (t = 0; t < r; t++)
                    if (S.contains(i[t], this)) return !0
            }));
            for (n = this.pushStack([]), t = 0; t < r; t++) S.find(e, i[t], n);
            return 1 < r ? S.uniqueSort(n) : n
        },
        filter: function(e) { return this.pushStack(j(this, e || [], !1)) },
        not: function(e) { return this.pushStack(j(this, e || [], !0)) },
        is: function(e) { return !!j(this, "string" == typeof e && k.test(e) ? S(e) : e || [], !1).length }
    });
    var D, q = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
    (S.fn.init = function(e, t, n) {
        var r, i;
        if (!e) return this;
        if (n = n || D, "string" == typeof e) {
            if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : q.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
            if (r[1]) {
                if (t = t instanceof S ? t[0] : t, S.merge(this, S.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), N.test(r[1]) && S.isPlainObject(t))
                    for (r in t) m(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
                return this
            }
            return (i = E.getElementById(r[2])) && (this[0] = i, this.length = 1), this
        }
        return e.nodeType ? (this[0] = e, this.length = 1, this) : m(e) ? void 0 !== n.ready ? n.ready(e) : e(S) : S.makeArray(e, this)
    }).prototype = S.fn, D = S(E);
    var L = /^(?:parents|prev(?:Until|All))/,
        H = { children: !0, contents: !0, next: !0, prev: !0 };

    function O(e, t) { while ((e = e[t]) && 1 !== e.nodeType); return e }
    S.fn.extend({
        has: function(e) {
            var t = S(e, this),
                n = t.length;
            return this.filter(function() {
                for (var e = 0; e < n; e++)
                    if (S.contains(this, t[e])) return !0
            })
        },
        closest: function(e, t) {
            var n, r = 0,
                i = this.length,
                o = [],
                a = "string" != typeof e && S(e);
            if (!k.test(e))
                for (; r < i; r++)
                    for (n = this[r]; n && n !== t; n = n.parentNode)
                        if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && S.find.matchesSelector(n, e))) { o.push(n); break }
            return this.pushStack(1 < o.length ? S.uniqueSort(o) : o)
        },
        index: function(e) { return e ? "string" == typeof e ? i.call(S(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 },
        add: function(e, t) { return this.pushStack(S.uniqueSort(S.merge(this.get(), S(e, t)))) },
        addBack: function(e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)) }
    }), S.each({ parent: function(e) { var t = e.parentNode; return t && 11 !== t.nodeType ? t : null }, parents: function(e) { return h(e, "parentNode") }, parentsUntil: function(e, t, n) { return h(e, "parentNode", n) }, next: function(e) { return O(e, "nextSibling") }, prev: function(e) { return O(e, "previousSibling") }, nextAll: function(e) { return h(e, "nextSibling") }, prevAll: function(e) { return h(e, "previousSibling") }, nextUntil: function(e, t, n) { return h(e, "nextSibling", n) }, prevUntil: function(e, t, n) { return h(e, "previousSibling", n) }, siblings: function(e) { return T((e.parentNode || {}).firstChild, e) }, children: function(e) { return T(e.firstChild) }, contents: function(e) { return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (A(e, "template") && (e = e.content || e), S.merge([], e.childNodes)) } }, function(r, i) { S.fn[r] = function(e, t) { var n = S.map(this, i, e); return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = S.filter(t, n)), 1 < this.length && (H[r] || S.uniqueSort(n), L.test(r) && n.reverse()), this.pushStack(n) } });
    var P = /[^\x20\t\r\n\f]+/g;

    function R(e) { return e }

    function M(e) { throw e }

    function I(e, t, n, r) { var i; try { e && m(i = e.promise) ? i.call(e).done(t).fail(n) : e && m(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r)) } catch (e) { n.apply(void 0, [e]) } }
    S.Callbacks = function(r) {
        var e, n;
        r = "string" == typeof r ? (e = r, n = {}, S.each(e.match(P) || [], function(e, t) { n[t] = !0 }), n) : S.extend({}, r);
        var i, t, o, a, s = [],
            u = [],
            l = -1,
            c = function() {
                for (a = a || r.once, o = i = !0; u.length; l = -1) { t = u.shift(); while (++l < s.length) !1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1) }
                r.memory || (t = !1), i = !1, a && (s = t ? [] : "")
            },
            f = { add: function() { return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) { S.each(e, function(e, t) { m(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && "string" !== w(t) && n(t) }) }(arguments), t && !i && c()), this }, remove: function() { return S.each(arguments, function(e, t) { var n; while (-1 < (n = S.inArray(t, s, n))) s.splice(n, 1), n <= l && l-- }), this }, has: function(e) { return e ? -1 < S.inArray(e, s) : 0 < s.length }, empty: function() { return s && (s = []), this }, disable: function() { return a = u = [], s = t = "", this }, disabled: function() { return !s }, lock: function() { return a = u = [], t || i || (s = t = ""), this }, locked: function() { return !!a }, fireWith: function(e, t) { return a || (t = [e, (t = t || []).slice ? t.slice() : t], u.push(t), i || c()), this }, fire: function() { return f.fireWith(this, arguments), this }, fired: function() { return !!o } };
        return f
    }, S.extend({
        Deferred: function(e) {
            var o = [
                    ["notify", "progress", S.Callbacks("memory"), S.Callbacks("memory"), 2],
                    ["resolve", "done", S.Callbacks("once memory"), S.Callbacks("once memory"), 0, "resolved"],
                    ["reject", "fail", S.Callbacks("once memory"), S.Callbacks("once memory"), 1, "rejected"]
                ],
                i = "pending",
                a = {
                    state: function() { return i },
                    always: function() { return s.done(arguments).fail(arguments), this },
                    "catch": function(e) { return a.then(null, e) },
                    pipe: function() {
                        var i = arguments;
                        return S.Deferred(function(r) {
                            S.each(o, function(e, t) {
                                var n = m(i[t[4]]) && i[t[4]];
                                s[t[1]](function() {
                                    var e = n && n.apply(this, arguments);
                                    e && m(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [e] : arguments)
                                })
                            }), i = null
                        }).promise()
                    },
                    then: function(t, n, r) {
                        var u = 0;

                        function l(i, o, a, s) {
                            return function() {
                                var n = this,
                                    r = arguments,
                                    e = function() {
                                        var e, t;
                                        if (!(i < u)) {
                                            if ((e = a.apply(n, r)) === o.promise()) throw new TypeError("Thenable self-resolution");
                                            t = e && ("object" == typeof e || "function" == typeof e) && e.then, m(t) ? s ? t.call(e, l(u, o, R, s), l(u, o, M, s)) : (u++, t.call(e, l(u, o, R, s), l(u, o, M, s), l(u, o, R, o.notifyWith))) : (a !== R && (n = void 0, r = [e]), (s || o.resolveWith)(n, r))
                                        }
                                    },
                                    t = s ? e : function() { try { e() } catch (e) { S.Deferred.exceptionHook && S.Deferred.exceptionHook(e, t.stackTrace), u <= i + 1 && (a !== M && (n = void 0, r = [e]), o.rejectWith(n, r)) } };
                                i ? t() : (S.Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook()), C.setTimeout(t))
                            }
                        }
                        return S.Deferred(function(e) { o[0][3].add(l(0, e, m(r) ? r : R, e.notifyWith)), o[1][3].add(l(0, e, m(t) ? t : R)), o[2][3].add(l(0, e, m(n) ? n : M)) }).promise()
                    },
                    promise: function(e) { return null != e ? S.extend(e, a) : a }
                },
                s = {};
            return S.each(o, function(e, t) {
                var n = t[2],
                    r = t[5];
                a[t[1]] = n.add, r && n.add(function() { i = r }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function() { return s[t[0] + "With"](this === s ? void 0 : this, arguments), this }, s[t[0] + "With"] = n.fireWith
            }), a.promise(s), e && e.call(s, s), s
        },
        when: function(e) {
            var n = arguments.length,
                t = n,
                r = Array(t),
                i = s.call(arguments),
                o = S.Deferred(),
                a = function(t) { return function(e) { r[t] = this, i[t] = 1 < arguments.length ? s.call(arguments) : e, --n || o.resolveWith(r, i) } };
            if (n <= 1 && (I(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || m(i[t] && i[t].then))) return o.then();
            while (t--) I(i[t], a(t), o.reject);
            return o.promise()
        }
    });
    var W = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    S.Deferred.exceptionHook = function(e, t) { C.console && C.console.warn && e && W.test(e.name) && C.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t) }, S.readyException = function(e) { C.setTimeout(function() { throw e }) };
    var F = S.Deferred();

    function B() { E.removeEventListener("DOMContentLoaded", B), C.removeEventListener("load", B), S.ready() }
    S.fn.ready = function(e) { return F.then(e)["catch"](function(e) { S.readyException(e) }), this }, S.extend({
        isReady: !1,
        readyWait: 1,
        ready: function(e) {
            (!0 === e ? --S.readyWait : S.isReady) || (S.isReady = !0) !== e && 0 < --S.readyWait || F.resolveWith(E, [S])
        }
    }), S.ready.then = F.then, "complete" === E.readyState || "loading" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(S.ready) : (E.addEventListener("DOMContentLoaded", B), C.addEventListener("load", B));
    var $ = function(e, t, n, r, i, o, a) {
            var s = 0,
                u = e.length,
                l = null == n;
            if ("object" === w(n))
                for (s in i = !0, n) $(e, t, s, n[s], !0, o, a);
            else if (void 0 !== r && (i = !0, m(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function(e, t, n) { return l.call(S(e), n) })), t))
                for (; s < u; s++) t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n)));
            return i ? e : l ? t.call(e) : u ? t(e[0], n) : o
        },
        _ = /^-ms-/,
        z = /-([a-z])/g;

    function U(e, t) { return t.toUpperCase() }

    function X(e) { return e.replace(_, "ms-").replace(z, U) }
    var V = function(e) { return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType };

    function G() { this.expando = S.expando + G.uid++ }
    G.uid = 1, G.prototype = {
        cache: function(e) { var t = e[this.expando]; return t || (t = {}, V(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t },
        set: function(e, t, n) {
            var r, i = this.cache(e);
            if ("string" == typeof t) i[X(t)] = n;
            else
                for (r in t) i[X(r)] = t[r];
            return i
        },
        get: function(e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][X(t)] },
        access: function(e, t, n) { return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t) },
        remove: function(e, t) { var n, r = e[this.expando]; if (void 0 !== r) { if (void 0 !== t) { n = (t = Array.isArray(t) ? t.map(X) : (t = X(t)) in r ? [t] : t.match(P) || []).length; while (n--) delete r[t[n]] }(void 0 === t || S.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]) } },
        hasData: function(e) { var t = e[this.expando]; return void 0 !== t && !S.isEmptyObject(t) }
    };
    var Y = new G,
        Q = new G,
        J = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        K = /[A-Z]/g;

    function Z(e, t, n) {
        var r, i;
        if (void 0 === n && 1 === e.nodeType)
            if (r = "data-" + t.replace(K, "-$&").toLowerCase(), "string" == typeof(n = e.getAttribute(r))) {
                try { n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : J.test(i) ? JSON.parse(i) : i) } catch (e) {}
                Q.set(e, t, n)
            } else n = void 0;
        return n
    }
    S.extend({ hasData: function(e) { return Q.hasData(e) || Y.hasData(e) }, data: function(e, t, n) { return Q.access(e, t, n) }, removeData: function(e, t) { Q.remove(e, t) }, _data: function(e, t, n) { return Y.access(e, t, n) }, _removeData: function(e, t) { Y.remove(e, t) } }), S.fn.extend({
        data: function(n, e) {
            var t, r, i, o = this[0],
                a = o && o.attributes;
            if (void 0 === n) {
                if (this.length && (i = Q.get(o), 1 === o.nodeType && !Y.get(o, "hasDataAttrs"))) {
                    t = a.length;
                    while (t--) a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = X(r.slice(5)), Z(o, r, i[r]));
                    Y.set(o, "hasDataAttrs", !0)
                }
                return i
            }
            return "object" == typeof n ? this.each(function() { Q.set(this, n) }) : $(this, function(e) {
                var t;
                if (o && void 0 === e) return void 0 !== (t = Q.get(o, n)) ? t : void 0 !== (t = Z(o, n)) ? t : void 0;
                this.each(function() { Q.set(this, n, e) })
            }, null, e, 1 < arguments.length, null, !0)
        },
        removeData: function(e) { return this.each(function() { Q.remove(this, e) }) }
    }), S.extend({
        queue: function(e, t, n) { var r; if (e) return t = (t || "fx") + "queue", r = Y.get(e, t), n && (!r || Array.isArray(n) ? r = Y.access(e, t, S.makeArray(n)) : r.push(n)), r || [] },
        dequeue: function(e, t) {
            t = t || "fx";
            var n = S.queue(e, t),
                r = n.length,
                i = n.shift(),
                o = S._queueHooks(e, t);
            "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function() { S.dequeue(e, t) }, o)), !r && o && o.empty.fire()
        },
        _queueHooks: function(e, t) { var n = t + "queueHooks"; return Y.get(e, n) || Y.access(e, n, { empty: S.Callbacks("once memory").add(function() { Y.remove(e, [t + "queue", n]) }) }) }
    }), S.fn.extend({
        queue: function(t, n) {
            var e = 2;
            return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? S.queue(this[0], t) : void 0 === n ? this : this.each(function() {
                var e = S.queue(this, t, n);
                S._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && S.dequeue(this, t)
            })
        },
        dequeue: function(e) { return this.each(function() { S.dequeue(this, e) }) },
        clearQueue: function(e) { return this.queue(e || "fx", []) },
        promise: function(e, t) {
            var n, r = 1,
                i = S.Deferred(),
                o = this,
                a = this.length,
                s = function() {--r || i.resolveWith(o, [o]) };
            "string" != typeof e && (t = e, e = void 0), e = e || "fx";
            while (a--)(n = Y.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s));
            return s(), i.promise(t)
        }
    });
    var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"),
        ne = ["Top", "Right", "Bottom", "Left"],
        re = E.documentElement,
        ie = function(e) { return S.contains(e.ownerDocument, e) },
        oe = { composed: !0 };
    re.getRootNode && (ie = function(e) { return S.contains(e.ownerDocument, e) || e.getRootNode(oe) === e.ownerDocument });
    var ae = function(e, t) { return "none" === (e = t || e).style.display || "" === e.style.display && ie(e) && "none" === S.css(e, "display") };

    function se(e, t, n, r) {
        var i, o, a = 20,
            s = r ? function() { return r.cur() } : function() { return S.css(e, t, "") },
            u = s(),
            l = n && n[3] || (S.cssNumber[t] ? "" : "px"),
            c = e.nodeType && (S.cssNumber[t] || "px" !== l && +u) && te.exec(S.css(e, t));
        if (c && c[3] !== l) {
            u /= 2, l = l || c[3], c = +u || 1;
            while (a--) S.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o;
            c *= 2, S.style(e, t, c + l), n = n || []
        }
        return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i
    }
    var ue = {};

    function le(e, t) { for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++)(r = e[c]).style && (n = r.style.display, t ? ("none" === n && (l[c] = Y.get(r, "display") || null, l[c] || (r.style.display = "")), "" === r.style.display && ae(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ue[s]) || (o = a.body.appendChild(a.createElement(s)), u = S.css(o, "display"), o.parentNode.removeChild(o), "none" === u && (u = "block"), ue[s] = u)))) : "none" !== n && (l[c] = "none", Y.set(r, "display", n))); for (c = 0; c < f; c++) null != l[c] && (e[c].style.display = l[c]); return e }
    S.fn.extend({ show: function() { return le(this, !0) }, hide: function() { return le(this) }, toggle: function(e) { return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() { ae(this) ? S(this).show() : S(this).hide() }) } });
    var ce, fe, pe = /^(?:checkbox|radio)$/i,
        de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
        he = /^$|^module$|\/(?:java|ecma)script/i;
    ce = E.createDocumentFragment().appendChild(E.createElement("div")), (fe = E.createElement("input")).setAttribute("type", "radio"), fe.setAttribute("checked", "checked"), fe.setAttribute("name", "t"), ce.appendChild(fe), y.checkClone = ce.cloneNode(!0).cloneNode(!0).lastChild.checked, ce.innerHTML = "<textarea>x</textarea>", y.noCloneChecked = !!ce.cloneNode(!0).lastChild.defaultValue, ce.innerHTML = "<option></option>", y.option = !!ce.lastChild;
    var ge = { thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] };

    function ve(e, t) { var n; return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && A(e, t) ? S.merge([e], n) : n }

    function ye(e, t) { for (var n = 0, r = e.length; n < r; n++) Y.set(e[n], "globalEval", !t || Y.get(t[n], "globalEval")) }
    ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td, y.option || (ge.optgroup = ge.option = [1, "<select multiple='multiple'>", "</select>"]);
    var me = /<|&#?\w+;/;

    function xe(e, t, n, r, i) {
        for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)
            if ((o = e[d]) || 0 === o)
                if ("object" === w(o)) S.merge(p, o.nodeType ? [o] : o);
                else if (me.test(o)) {
            a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + S.htmlPrefilter(o) + u[2], c = u[0];
            while (c--) a = a.lastChild;
            S.merge(p, a.childNodes), (a = f.firstChild).textContent = ""
        } else p.push(t.createTextNode(o));
        f.textContent = "", d = 0;
        while (o = p[d++])
            if (r && -1 < S.inArray(o, r)) i && i.push(o);
            else if (l = ie(o), a = ve(f.appendChild(o), "script"), l && ye(a), n) { c = 0; while (o = a[c++]) he.test(o.type || "") && n.push(o) }
        return f
    }
    var be = /^([^.]*)(?:\.(.+)|)/;

    function we() { return !0 }

    function Te() { return !1 }

    function Ce(e, t) { return e === function() { try { return E.activeElement } catch (e) {} }() == ("focus" === t) }

    function Ee(e, t, n, r, i, o) {
        var a, s;
        if ("object" == typeof t) { for (s in "string" != typeof n && (r = r || n, n = void 0), t) Ee(e, s, n, r, t[s], o); return e }
        if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Te;
        else if (!i) return e;
        return 1 === o && (a = i, (i = function(e) { return S().off(e), a.apply(this, arguments) }).guid = a.guid || (a.guid = S.guid++)), e.each(function() { S.event.add(this, t, i, r, n) })
    }

    function Se(e, i, o) {
        o ? (Y.set(e, i, !1), S.event.add(e, i, {
            namespace: !1,
            handler: function(e) {
                var t, n, r = Y.get(this, i);
                if (1 & e.isTrigger && this[i]) {
                    if (r.length)(S.event.special[i] || {}).delegateType && e.stopPropagation();
                    else if (r = s.call(arguments), Y.set(this, i, r), t = o(this, i), this[i](), r !== (n = Y.get(this, i)) || t ? Y.set(this, i, !1) : n = {}, r !== n) return e.stopImmediatePropagation(), e.preventDefault(), n && n.value
                } else r.length && (Y.set(this, i, { value: S.event.trigger(S.extend(r[0], S.Event.prototype), r.slice(1), this) }), e.stopImmediatePropagation())
            }
        })) : void 0 === Y.get(e, i) && S.event.add(e, i, we)
    }
    S.event = {
        global: {},
        add: function(t, e, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, v = Y.get(t); if (V(t)) { n.handler && (n = (o = n).handler, i = o.selector), i && S.find.matchesSelector(re, i), n.guid || (n.guid = S.guid++), (u = v.events) || (u = v.events = Object.create(null)), (a = v.handle) || (a = v.handle = function(e) { return "undefined" != typeof S && S.event.triggered !== e.type ? S.event.dispatch.apply(t, arguments) : void 0 }), l = (e = (e || "").match(P) || [""]).length; while (l--) d = g = (s = be.exec(e[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = S.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = S.event.special[d] || {}, c = S.extend({ type: d, origType: g, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && S.expr.match.needsContext.test(i), namespace: h.join(".") }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), S.event.global[d] = !0) } },
        remove: function(e, t, n, r, i) {
            var o, a, s, u, l, c, f, p, d, h, g, v = Y.hasData(e) && Y.get(e);
            if (v && (u = v.events)) {
                l = (t = (t || "").match(P) || [""]).length;
                while (l--)
                    if (d = g = (s = be.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d) {
                        f = S.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length;
                        while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c));
                        a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || S.removeEvent(e, d, v.handle), delete u[d])
                    } else
                        for (d in u) S.event.remove(e, d + t[l], n, r, !0);
                S.isEmptyObject(u) && Y.remove(e, "handle events")
            }
        },
        dispatch: function(e) {
            var t, n, r, i, o, a, s = new Array(arguments.length),
                u = S.event.fix(e),
                l = (Y.get(this, "events") || Object.create(null))[u.type] || [],
                c = S.event.special[u.type] || {};
            for (s[0] = u, t = 1; t < arguments.length; t++) s[t] = arguments[t];
            if (u.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, u)) { a = S.event.handlers.call(this, u, l), t = 0; while ((i = a[t++]) && !u.isPropagationStopped()) { u.currentTarget = i.elem, n = 0; while ((o = i.handlers[n++]) && !u.isImmediatePropagationStopped()) u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace) || (u.handleObj = o, u.data = o.data, void 0 !== (r = ((S.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (u.result = r) && (u.preventDefault(), u.stopPropagation())) } return c.postDispatch && c.postDispatch.call(this, u), u.result }
        },
        handlers: function(e, t) {
            var n, r, i, o, a, s = [],
                u = t.delegateCount,
                l = e.target;
            if (u && l.nodeType && !("click" === e.type && 1 <= e.button))
                for (; l !== this; l = l.parentNode || this)
                    if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) {
                        for (o = [], a = {}, n = 0; n < u; n++) void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < S(i, this).index(l) : S.find(i, this, null, [l]).length), a[i] && o.push(r);
                        o.length && s.push({ elem: l, handlers: o })
                    }
            return l = this, u < t.length && s.push({ elem: l, handlers: t.slice(u) }), s
        },
        addProp: function(t, e) { Object.defineProperty(S.Event.prototype, t, { enumerable: !0, configurable: !0, get: m(e) ? function() { if (this.originalEvent) return e(this.originalEvent) } : function() { if (this.originalEvent) return this.originalEvent[t] }, set: function(e) { Object.defineProperty(this, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) } }) },
        fix: function(e) { return e[S.expando] ? e : new S.Event(e) },
        special: { load: { noBubble: !0 }, click: { setup: function(e) { var t = this || e; return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click", we), !1 }, trigger: function(e) { var t = this || e; return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click"), !0 }, _default: function(e) { var t = e.target; return pe.test(t.type) && t.click && A(t, "input") && Y.get(t, "click") || A(t, "a") } }, beforeunload: { postDispatch: function(e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result) } } }
    }, S.removeEvent = function(e, t, n) { e.removeEventListener && e.removeEventListener(t, n) }, S.Event = function(e, t) {
        if (!(this instanceof S.Event)) return new S.Event(e, t);
        e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? we : Te, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && S.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[S.expando] = !0
    }, S.Event.prototype = {
        constructor: S.Event,
        isDefaultPrevented: Te,
        isPropagationStopped: Te,
        isImmediatePropagationStopped: Te,
        isSimulated: !1,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = we, e && !this.isSimulated && e.preventDefault()
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = we, e && !this.isSimulated && e.stopPropagation()
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = we, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
        }
    }, S.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, "char": !0, code: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: !0 }, S.event.addProp), S.each({ focus: "focusin", blur: "focusout" }, function(e, t) { S.event.special[e] = { setup: function() { return Se(this, e, Ce), !1 }, trigger: function() { return Se(this, e), !0 }, _default: function() { return !0 }, delegateType: t } }), S.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function(e, i) {
        S.event.special[e] = {
            delegateType: i,
            bindType: i,
            handle: function(e) {
                var t, n = e.relatedTarget,
                    r = e.handleObj;
                return n && (n === this || S.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t
            }
        }
    }), S.fn.extend({ on: function(e, t, n, r) { return Ee(this, e, t, n, r) }, one: function(e, t, n, r) { return Ee(this, e, t, n, r, 1) }, off: function(e, t, n) { var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, S(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this; if ("object" == typeof e) { for (i in e) this.off(i, t, e[i]); return this } return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Te), this.each(function() { S.event.remove(this, e, n, t) }) } });
    var ke = /<script|<style|<link/i,
        Ae = /checked\s*(?:[^=]|=\s*.checked.)/i,
        Ne = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

    function je(e, t) { return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && S(e).children("tbody")[0] || e }

    function De(e) { return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e }

    function qe(e) { return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e }

    function Le(e, t) {
        var n, r, i, o, a, s;
        if (1 === t.nodeType) {
            if (Y.hasData(e) && (s = Y.get(e).events))
                for (i in Y.remove(t, "handle events"), s)
                    for (n = 0, r = s[i].length; n < r; n++) S.event.add(t, i, s[i][n]);
            Q.hasData(e) && (o = Q.access(e), a = S.extend({}, o), Q.set(t, a))
        }
    }

    function He(n, r, i, o) {
        r = g(r);
        var e, t, a, s, u, l, c = 0,
            f = n.length,
            p = f - 1,
            d = r[0],
            h = m(d);
        if (h || 1 < f && "string" == typeof d && !y.checkClone && Ae.test(d)) return n.each(function(e) {
            var t = n.eq(e);
            h && (r[0] = d.call(this, e, t.html())), He(t, r, i, o)
        });
        if (f && (t = (e = xe(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) {
            for (s = (a = S.map(ve(e, "script"), De)).length; c < f; c++) u = e, c !== p && (u = S.clone(u, !0, !0), s && S.merge(a, ve(u, "script"))), i.call(n[c], u, c);
            if (s)
                for (l = a[a.length - 1].ownerDocument, S.map(a, qe), c = 0; c < s; c++) u = a[c], he.test(u.type || "") && !Y.access(u, "globalEval") && S.contains(l, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? S._evalUrl && !u.noModule && S._evalUrl(u.src, { nonce: u.nonce || u.getAttribute("nonce") }, l) : b(u.textContent.replace(Ne, ""), u, l))
        }
        return n
    }

    function Oe(e, t, n) { for (var r, i = t ? S.filter(t, e) : e, o = 0; null != (r = i[o]); o++) n || 1 !== r.nodeType || S.cleanData(ve(r)), r.parentNode && (n && ie(r) && ye(ve(r, "script")), r.parentNode.removeChild(r)); return e }
    S.extend({
        htmlPrefilter: function(e) { return e },
        clone: function(e, t, n) {
            var r, i, o, a, s, u, l, c = e.cloneNode(!0),
                f = ie(e);
            if (!(y.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || S.isXMLDoc(e)))
                for (a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++) s = o[r], u = a[r], void 0, "input" === (l = u.nodeName.toLowerCase()) && pe.test(s.type) ? u.checked = s.checked : "input" !== l && "textarea" !== l || (u.defaultValue = s.defaultValue);
            if (t)
                if (n)
                    for (o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++) Le(o[r], a[r]);
                else Le(e, c);
            return 0 < (a = ve(c, "script")).length && ye(a, !f && ve(e, "script")), c
        },
        cleanData: function(e) {
            for (var t, n, r, i = S.event.special, o = 0; void 0 !== (n = e[o]); o++)
                if (V(n)) {
                    if (t = n[Y.expando]) {
                        if (t.events)
                            for (r in t.events) i[r] ? S.event.remove(n, r) : S.removeEvent(n, r, t.handle);
                        n[Y.expando] = void 0
                    }
                    n[Q.expando] && (n[Q.expando] = void 0)
                }
        }
    }), S.fn.extend({
        detach: function(e) { return Oe(this, e, !0) },
        remove: function(e) { return Oe(this, e) },
        text: function(e) { return $(this, function(e) { return void 0 === e ? S.text(this) : this.empty().each(function() { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e) }) }, null, e, arguments.length) },
        append: function() { return He(this, arguments, function(e) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || je(this, e).appendChild(e) }) },
        prepend: function() {
            return He(this, arguments, function(e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var t = je(this, e);
                    t.insertBefore(e, t.firstChild)
                }
            })
        },
        before: function() { return He(this, arguments, function(e) { this.parentNode && this.parentNode.insertBefore(e, this) }) },
        after: function() { return He(this, arguments, function(e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling) }) },
        empty: function() { for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (S.cleanData(ve(e, !1)), e.textContent = ""); return this },
        clone: function(e, t) { return e = null != e && e, t = null == t ? e : t, this.map(function() { return S.clone(this, e, t) }) },
        html: function(e) {
            return $(this, function(e) {
                var t = this[0] || {},
                    n = 0,
                    r = this.length;
                if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                if ("string" == typeof e && !ke.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) {
                    e = S.htmlPrefilter(e);
                    try {
                        for (; n < r; n++) 1 === (t = this[n] || {}).nodeType && (S.cleanData(ve(t, !1)), t.innerHTML = e);
                        t = 0
                    } catch (e) {}
                }
                t && this.empty().append(e)
            }, null, e, arguments.length)
        },
        replaceWith: function() {
            var n = [];
            return He(this, arguments, function(e) {
                var t = this.parentNode;
                S.inArray(this, n) < 0 && (S.cleanData(ve(this)), t && t.replaceChild(e, this))
            }, n)
        }
    }), S.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function(e, a) { S.fn[e] = function(e) { for (var t, n = [], r = S(e), i = r.length - 1, o = 0; o <= i; o++) t = o === i ? this : this.clone(!0), S(r[o])[a](t), u.apply(n, t.get()); return this.pushStack(n) } });
    var Pe = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"),
        Re = function(e) { var t = e.ownerDocument.defaultView; return t && t.opener || (t = C), t.getComputedStyle(e) },
        Me = function(e, t, n) { var r, i, o = {}; for (i in t) o[i] = e.style[i], e.style[i] = t[i]; for (i in r = n.call(e), t) e.style[i] = o[i]; return r },
        Ie = new RegExp(ne.join("|"), "i");

    function We(e, t, n) { var r, i, o, a, s = e.style; return (n = n || Re(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || ie(e) || (a = S.style(e, t)), !y.pixelBoxStyles() && Pe.test(a) && Ie.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a }

    function Fe(e, t) {
        return {
            get: function() {
                if (!e()) return (this.get = t).apply(this, arguments);
                delete this.get
            }
        }
    }! function() {
        function e() {
            if (l) {
                u.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", re.appendChild(u).appendChild(l);
                var e = C.getComputedStyle(l);
                n = "1%" !== e.top, s = 12 === t(e.marginLeft), l.style.right = "60%", o = 36 === t(e.right), r = 36 === t(e.width), l.style.position = "absolute", i = 12 === t(l.offsetWidth / 3), re.removeChild(u), l = null
            }
        }

        function t(e) { return Math.round(parseFloat(e)) }
        var n, r, i, o, a, s, u = E.createElement("div"),
            l = E.createElement("div");
        l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", y.clearCloneStyle = "content-box" === l.style.backgroundClip, S.extend(y, { boxSizingReliable: function() { return e(), r }, pixelBoxStyles: function() { return e(), o }, pixelPosition: function() { return e(), n }, reliableMarginLeft: function() { return e(), s }, scrollboxSize: function() { return e(), i }, reliableTrDimensions: function() { var e, t, n, r; return null == a && (e = E.createElement("table"), t = E.createElement("tr"), n = E.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", n.style.height = "9px", n.style.display = "block", re.appendChild(e).appendChild(t).appendChild(n), r = C.getComputedStyle(t), a = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === t.offsetHeight, re.removeChild(e)), a } }))
    }();
    var Be = ["Webkit", "Moz", "ms"],
        $e = E.createElement("div").style,
        _e = {};

    function ze(e) {
        var t = S.cssProps[e] || _e[e];
        return t || (e in $e ? e : _e[e] = function(e) {
            var t = e[0].toUpperCase() + e.slice(1),
                n = Be.length;
            while (n--)
                if ((e = Be[n] + t) in $e) return e
        }(e) || e)
    }
    var Ue = /^(none|table(?!-c[ea]).+)/,
        Xe = /^--/,
        Ve = { position: "absolute", visibility: "hidden", display: "block" },
        Ge = { letterSpacing: "0", fontWeight: "400" };

    function Ye(e, t, n) { var r = te.exec(t); return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t }

    function Qe(e, t, n, r, i, o) {
        var a = "width" === t ? 1 : 0,
            s = 0,
            u = 0;
        if (n === (r ? "border" : "content")) return 0;
        for (; a < 4; a += 2) "margin" === n && (u += S.css(e, n + ne[a], !0, i)), r ? ("content" === n && (u -= S.css(e, "padding" + ne[a], !0, i)), "margin" !== n && (u -= S.css(e, "border" + ne[a] + "Width", !0, i))) : (u += S.css(e, "padding" + ne[a], !0, i), "padding" !== n ? u += S.css(e, "border" + ne[a] + "Width", !0, i) : s += S.css(e, "border" + ne[a] + "Width", !0, i));
        return !r && 0 <= o && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u
    }

    function Je(e, t, n) {
        var r = Re(e),
            i = (!y.boxSizingReliable() || n) && "border-box" === S.css(e, "boxSizing", !1, r),
            o = i,
            a = We(e, t, r),
            s = "offset" + t[0].toUpperCase() + t.slice(1);
        if (Pe.test(a)) {
            if (!n) return a;
            a = "auto"
        }
        return (!y.boxSizingReliable() && i || !y.reliableTrDimensions() && A(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === S.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === S.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + Qe(e, t, n || (i ? "border" : "content"), o, r, a) + "px"
    }

    function Ke(e, t, n, r, i) { return new Ke.prototype.init(e, t, n, r, i) }
    S.extend({
        cssHooks: { opacity: { get: function(e, t) { if (t) { var n = We(e, "opacity"); return "" === n ? "1" : n } } } },
        cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, gridArea: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnStart: !0, gridRow: !0, gridRowEnd: !0, gridRowStart: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 },
        cssProps: {},
        style: function(e, t, n, r) {
            if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                var i, o, a, s = X(t),
                    u = Xe.test(t),
                    l = e.style;
                if (u || (t = ze(s)), a = S.cssHooks[t] || S.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t];
                "string" === (o = typeof n) && (i = te.exec(n)) && i[1] && (n = se(e, t, i), o = "number"), null != n && n == n && ("number" !== o || u || (n += i && i[3] || (S.cssNumber[s] ? "" : "px")), y.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n))
            }
        },
        css: function(e, t, n, r) { var i, o, a, s = X(t); return Xe.test(t) || (t = ze(s)), (a = S.cssHooks[t] || S.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = We(e, t, r)), "normal" === i && t in Ge && (i = Ge[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i }
    }), S.each(["height", "width"], function(e, u) {
        S.cssHooks[u] = {
            get: function(e, t, n) { if (t) return !Ue.test(S.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Je(e, u, n) : Me(e, Ve, function() { return Je(e, u, n) }) },
            set: function(e, t, n) {
                var r, i = Re(e),
                    o = !y.scrollboxSize() && "absolute" === i.position,
                    a = (o || n) && "border-box" === S.css(e, "boxSizing", !1, i),
                    s = n ? Qe(e, u, n, a, i) : 0;
                return a && o && (s -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - Qe(e, u, "border", !1, i) - .5)), s && (r = te.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = S.css(e, u)), Ye(0, t, s)
            }
        }
    }), S.cssHooks.marginLeft = Fe(y.reliableMarginLeft, function(e, t) { if (t) return (parseFloat(We(e, "marginLeft")) || e.getBoundingClientRect().left - Me(e, { marginLeft: 0 }, function() { return e.getBoundingClientRect().left })) + "px" }), S.each({ margin: "", padding: "", border: "Width" }, function(i, o) { S.cssHooks[i + o] = { expand: function(e) { for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++) n[i + ne[t] + o] = r[t] || r[t - 2] || r[0]; return n } }, "margin" !== i && (S.cssHooks[i + o].set = Ye) }), S.fn.extend({
        css: function(e, t) {
            return $(this, function(e, t, n) {
                var r, i, o = {},
                    a = 0;
                if (Array.isArray(t)) { for (r = Re(e), i = t.length; a < i; a++) o[t[a]] = S.css(e, t[a], !1, r); return o }
                return void 0 !== n ? S.style(e, t, n) : S.css(e, t)
            }, e, t, 1 < arguments.length)
        }
    }), ((S.Tween = Ke).prototype = { constructor: Ke, init: function(e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || S.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (S.cssNumber[n] ? "" : "px") }, cur: function() { var e = Ke.propHooks[this.prop]; return e && e.get ? e.get(this) : Ke.propHooks._default.get(this) }, run: function(e) { var t, n = Ke.propHooks[this.prop]; return this.options.duration ? this.pos = t = S.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : Ke.propHooks._default.set(this), this } }).init.prototype = Ke.prototype, (Ke.propHooks = { _default: { get: function(e) { var t; return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = S.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0 }, set: function(e) { S.fx.step[e.prop] ? S.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !S.cssHooks[e.prop] && null == e.elem.style[ze(e.prop)] ? e.elem[e.prop] = e.now : S.style(e.elem, e.prop, e.now + e.unit) } } }).scrollTop = Ke.propHooks.scrollLeft = { set: function(e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now) } }, S.easing = { linear: function(e) { return e }, swing: function(e) { return .5 - Math.cos(e * Math.PI) / 2 }, _default: "swing" }, S.fx = Ke.prototype.init, S.fx.step = {};
    var Ze, et, tt, nt, rt = /^(?:toggle|show|hide)$/,
        it = /queueHooks$/;

    function ot() { et && (!1 === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(ot) : C.setTimeout(ot, S.fx.interval), S.fx.tick()) }

    function at() { return C.setTimeout(function() { Ze = void 0 }), Ze = Date.now() }

    function st(e, t) {
        var n, r = 0,
            i = { height: e };
        for (t = t ? 1 : 0; r < 4; r += 2 - t) i["margin" + (n = ne[r])] = i["padding" + n] = e;
        return t && (i.opacity = i.width = e), i
    }

    function ut(e, t, n) {
        for (var r, i = (lt.tweeners[t] || []).concat(lt.tweeners["*"]), o = 0, a = i.length; o < a; o++)
            if (r = i[o].call(n, t, e)) return r
    }

    function lt(o, e, t) {
        var n, a, r = 0,
            i = lt.prefilters.length,
            s = S.Deferred().always(function() { delete u.elem }),
            u = function() { if (a) return !1; for (var e = Ze || at(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++) l.tweens[r].run(n); return s.notifyWith(o, [l, n, t]), n < 1 && i ? t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1) },
            l = s.promise({
                elem: o,
                props: S.extend({}, e),
                opts: S.extend(!0, { specialEasing: {}, easing: S.easing._default }, t),
                originalProperties: e,
                originalOptions: t,
                startTime: Ze || at(),
                duration: t.duration,
                tweens: [],
                createTween: function(e, t) { var n = S.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing); return l.tweens.push(n), n },
                stop: function(e) {
                    var t = 0,
                        n = e ? l.tweens.length : 0;
                    if (a) return this;
                    for (a = !0; t < n; t++) l.tweens[t].run(1);
                    return e ? (s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]), this
                }
            }),
            c = l.props;
        for (! function(e, t) {
                var n, r, i, o, a;
                for (n in e)
                    if (i = t[r = X(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = S.cssHooks[r]) && "expand" in a)
                        for (n in o = a.expand(o), delete e[r], o) n in e || (e[n] = o[n], t[n] = i);
                    else t[r] = i
            }(c, l.opts.specialEasing); r < i; r++)
            if (n = lt.prefilters[r].call(l, o, c, l.opts)) return m(n.stop) && (S._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n;
        return S.map(c, ut, l), m(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), S.fx.timer(S.extend(u, { elem: o, anim: l, queue: l.opts.queue })), l
    }
    S.Animation = S.extend(lt, {
        tweeners: { "*": [function(e, t) { var n = this.createTween(e, t); return se(n.elem, e, te.exec(t), n), n }] },
        tweener: function(e, t) { m(e) ? (t = e, e = ["*"]) : e = e.match(P); for (var n, r = 0, i = e.length; r < i; r++) n = e[r], lt.tweeners[n] = lt.tweeners[n] || [], lt.tweeners[n].unshift(t) },
        prefilters: [function(e, t, n) {
            var r, i, o, a, s, u, l, c, f = "width" in t || "height" in t,
                p = this,
                d = {},
                h = e.style,
                g = e.nodeType && ae(e),
                v = Y.get(e, "fxshow");
            for (r in n.queue || (null == (a = S._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function() { a.unqueued || s() }), a.unqueued++, p.always(function() { p.always(function() { a.unqueued--, S.queue(e, "fx").length || a.empty.fire() }) })), t)
                if (i = t[r], rt.test(i)) {
                    if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) {
                        if ("show" !== i || !v || void 0 === v[r]) continue;
                        g = !0
                    }
                    d[r] = v && v[r] || S.style(e, r)
                }
            if ((u = !S.isEmptyObject(t)) || !S.isEmptyObject(d))
                for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Y.get(e, "display")), "none" === (c = S.css(e, "display")) && (l ? c = l : (le([e], !0), l = e.style.display || l, c = S.css(e, "display"), le([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === S.css(e, "float") && (u || (p.done(function() { h.display = l }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function() { h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2] })), u = !1, d) u || (v ? "hidden" in v && (g = v.hidden) : v = Y.access(e, "fxshow", { display: l }), o && (v.hidden = !g), g && le([e], !0), p.done(function() { for (r in g || le([e]), Y.remove(e, "fxshow"), d) S.style(e, r, d[r]) })), u = ut(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0))
        }],
        prefilter: function(e, t) { t ? lt.prefilters.unshift(e) : lt.prefilters.push(e) }
    }), S.speed = function(e, t, n) { var r = e && "object" == typeof e ? S.extend({}, e) : { complete: n || !n && t || m(e) && e, duration: e, easing: n && t || t && !m(t) && t }; return S.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in S.fx.speeds ? r.duration = S.fx.speeds[r.duration] : r.duration = S.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function() { m(r.old) && r.old.call(this), r.queue && S.dequeue(this, r.queue) }, r }, S.fn.extend({
        fadeTo: function(e, t, n, r) { return this.filter(ae).css("opacity", 0).show().end().animate({ opacity: t }, e, n, r) },
        animate: function(t, e, n, r) {
            var i = S.isEmptyObject(t),
                o = S.speed(e, n, r),
                a = function() {
                    var e = lt(this, S.extend({}, t), o);
                    (i || Y.get(this, "finish")) && e.stop(!0)
                };
            return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a)
        },
        stop: function(i, e, o) {
            var a = function(e) {
                var t = e.stop;
                delete e.stop, t(o)
            };
            return "string" != typeof i && (o = e, e = i, i = void 0), e && this.queue(i || "fx", []), this.each(function() {
                var e = !0,
                    t = null != i && i + "queueHooks",
                    n = S.timers,
                    r = Y.get(this);
                if (t) r[t] && r[t].stop && a(r[t]);
                else
                    for (t in r) r[t] && r[t].stop && it.test(t) && a(r[t]);
                for (t = n.length; t--;) n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1));
                !e && o || S.dequeue(this, i)
            })
        },
        finish: function(a) {
            return !1 !== a && (a = a || "fx"), this.each(function() {
                var e, t = Y.get(this),
                    n = t[a + "queue"],
                    r = t[a + "queueHooks"],
                    i = S.timers,
                    o = n ? n.length : 0;
                for (t.finish = !0, S.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;) i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1));
                for (e = 0; e < o; e++) n[e] && n[e].finish && n[e].finish.call(this);
                delete t.finish
            })
        }
    }), S.each(["toggle", "show", "hide"], function(e, r) {
        var i = S.fn[r];
        S.fn[r] = function(e, t, n) { return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(st(r, !0), e, t, n) }
    }), S.each({ slideDown: st("show"), slideUp: st("hide"), slideToggle: st("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function(e, r) { S.fn[e] = function(e, t, n) { return this.animate(r, e, t, n) } }), S.timers = [], S.fx.tick = function() {
        var e, t = 0,
            n = S.timers;
        for (Ze = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1);
        n.length || S.fx.stop(), Ze = void 0
    }, S.fx.timer = function(e) { S.timers.push(e), S.fx.start() }, S.fx.interval = 13, S.fx.start = function() { et || (et = !0, ot()) }, S.fx.stop = function() { et = null }, S.fx.speeds = { slow: 600, fast: 200, _default: 400 }, S.fn.delay = function(r, e) {
        return r = S.fx && S.fx.speeds[r] || r, e = e || "fx", this.queue(e, function(e, t) {
            var n = C.setTimeout(e, r);
            t.stop = function() { C.clearTimeout(n) }
        })
    }, tt = E.createElement("input"), nt = E.createElement("select").appendChild(E.createElement("option")), tt.type = "checkbox", y.checkOn = "" !== tt.value, y.optSelected = nt.selected, (tt = E.createElement("input")).value = "t", tt.type = "radio", y.radioValue = "t" === tt.value;
    var ct, ft = S.expr.attrHandle;
    S.fn.extend({ attr: function(e, t) { return $(this, S.attr, e, t, 1 < arguments.length) }, removeAttr: function(e) { return this.each(function() { S.removeAttr(this, e) }) } }), S.extend({
        attr: function(e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? S.prop(e, t, n) : (1 === o && S.isXMLDoc(e) || (i = S.attrHooks[t.toLowerCase()] || (S.expr.match.bool.test(t) ? ct : void 0)), void 0 !== n ? null === n ? void S.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = S.find.attr(e, t)) ? void 0 : r) },
        attrHooks: { type: { set: function(e, t) { if (!y.radioValue && "radio" === t && A(e, "input")) { var n = e.value; return e.setAttribute("type", t), n && (e.value = n), t } } } },
        removeAttr: function(e, t) {
            var n, r = 0,
                i = t && t.match(P);
            if (i && 1 === e.nodeType)
                while (n = i[r++]) e.removeAttribute(n)
        }
    }), ct = { set: function(e, t, n) { return !1 === t ? S.removeAttr(e, n) : e.setAttribute(n, n), n } }, S.each(S.expr.match.bool.source.match(/\w+/g), function(e, t) {
        var a = ft[t] || S.find.attr;
        ft[t] = function(e, t, n) { var r, i, o = t.toLowerCase(); return n || (i = ft[o], ft[o] = r, r = null != a(e, t, n) ? o : null, ft[o] = i), r }
    });
    var pt = /^(?:input|select|textarea|button)$/i,
        dt = /^(?:a|area)$/i;

    function ht(e) { return (e.match(P) || []).join(" ") }

    function gt(e) { return e.getAttribute && e.getAttribute("class") || "" }

    function vt(e) { return Array.isArray(e) ? e : "string" == typeof e && e.match(P) || [] }
    S.fn.extend({ prop: function(e, t) { return $(this, S.prop, e, t, 1 < arguments.length) }, removeProp: function(e) { return this.each(function() { delete this[S.propFix[e] || e] }) } }), S.extend({ prop: function(e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return 1 === o && S.isXMLDoc(e) || (t = S.propFix[t] || t, i = S.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t] }, propHooks: { tabIndex: { get: function(e) { var t = S.find.attr(e, "tabindex"); return t ? parseInt(t, 10) : pt.test(e.nodeName) || dt.test(e.nodeName) && e.href ? 0 : -1 } } }, propFix: { "for": "htmlFor", "class": "className" } }), y.optSelected || (S.propHooks.selected = {
        get: function(e) { var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null },
        set: function(e) {
            var t = e.parentNode;
            t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
        }
    }), S.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() { S.propFix[this.toLowerCase()] = this }), S.fn.extend({
        addClass: function(t) {
            var e, n, r, i, o, a, s, u = 0;
            if (m(t)) return this.each(function(e) { S(this).addClass(t.call(this, e, gt(this))) });
            if ((e = vt(t)).length)
                while (n = this[u++])
                    if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") {
                        a = 0;
                        while (o = e[a++]) r.indexOf(" " + o + " ") < 0 && (r += o + " ");
                        i !== (s = ht(r)) && n.setAttribute("class", s)
                    }
            return this
        },
        removeClass: function(t) {
            var e, n, r, i, o, a, s, u = 0;
            if (m(t)) return this.each(function(e) { S(this).removeClass(t.call(this, e, gt(this))) });
            if (!arguments.length) return this.attr("class", "");
            if ((e = vt(t)).length)
                while (n = this[u++])
                    if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") {
                        a = 0;
                        while (o = e[a++])
                            while (-1 < r.indexOf(" " + o + " ")) r = r.replace(" " + o + " ", " ");
                        i !== (s = ht(r)) && n.setAttribute("class", s)
                    }
            return this
        },
        toggleClass: function(i, t) {
            var o = typeof i,
                a = "string" === o || Array.isArray(i);
            return "boolean" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : m(i) ? this.each(function(e) { S(this).toggleClass(i.call(this, e, gt(this), t), t) }) : this.each(function() { var e, t, n, r; if (a) { t = 0, n = S(this), r = vt(i); while (e = r[t++]) n.hasClass(e) ? n.removeClass(e) : n.addClass(e) } else void 0 !== i && "boolean" !== o || ((e = gt(this)) && Y.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === i ? "" : Y.get(this, "__className__") || "")) })
        },
        hasClass: function(e) {
            var t, n, r = 0;
            t = " " + e + " ";
            while (n = this[r++])
                if (1 === n.nodeType && -1 < (" " + ht(gt(n)) + " ").indexOf(t)) return !0;
            return !1
        }
    });
    var yt = /\r/g;
    S.fn.extend({
        val: function(n) {
            var r, e, i, t = this[0];
            return arguments.length ? (i = m(n), this.each(function(e) {
                var t;
                1 === this.nodeType && (null == (t = i ? n.call(this, e, S(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = S.map(t, function(e) { return null == e ? "" : e + "" })), (r = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t))
            })) : t ? (r = S.valHooks[t.type] || S.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof(e = t.value) ? e.replace(yt, "") : null == e ? "" : e : void 0
        }
    }), S.extend({
        valHooks: {
            option: { get: function(e) { var t = S.find.attr(e, "value"); return null != t ? t : ht(S.text(e)) } },
            select: {
                get: function(e) {
                    var t, n, r, i = e.options,
                        o = e.selectedIndex,
                        a = "select-one" === e.type,
                        s = a ? null : [],
                        u = a ? o + 1 : i.length;
                    for (r = o < 0 ? u : a ? o : 0; r < u; r++)
                        if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) {
                            if (t = S(n).val(), a) return t;
                            s.push(t)
                        }
                    return s
                },
                set: function(e, t) {
                    var n, r, i = e.options,
                        o = S.makeArray(t),
                        a = i.length;
                    while (a--)((r = i[a]).selected = -1 < S.inArray(S.valHooks.option.get(r), o)) && (n = !0);
                    return n || (e.selectedIndex = -1), o
                }
            }
        }
    }), S.each(["radio", "checkbox"], function() { S.valHooks[this] = { set: function(e, t) { if (Array.isArray(t)) return e.checked = -1 < S.inArray(S(e).val(), t) } }, y.checkOn || (S.valHooks[this].get = function(e) { return null === e.getAttribute("value") ? "on" : e.value }) }), y.focusin = "onfocusin" in C;
    var mt = /^(?:focusinfocus|focusoutblur)$/,
        xt = function(e) { e.stopPropagation() };
    S.extend(S.event, {
        trigger: function(e, t, n, r) {
            var i, o, a, s, u, l, c, f, p = [n || E],
                d = v.call(e, "type") ? e.type : e,
                h = v.call(e, "namespace") ? e.namespace.split(".") : [];
            if (o = f = a = n = n || E, 3 !== n.nodeType && 8 !== n.nodeType && !mt.test(d + S.event.triggered) && (-1 < d.indexOf(".") && (d = (h = d.split(".")).shift(), h.sort()), u = d.indexOf(":") < 0 && "on" + d, (e = e[S.expando] ? e : new S.Event(d, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : S.makeArray(t, [e]), c = S.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) {
                if (!r && !c.noBubble && !x(n)) {
                    for (s = c.delegateType || d, mt.test(s + d) || (o = o.parentNode); o; o = o.parentNode) p.push(o), a = o;
                    a === (n.ownerDocument || E) && p.push(a.defaultView || a.parentWindow || C)
                }
                i = 0;
                while ((o = p[i++]) && !e.isPropagationStopped()) f = o, e.type = 1 < i ? s : c.bindType || d, (l = (Y.get(o, "events") || Object.create(null))[e.type] && Y.get(o, "handle")) && l.apply(o, t), (l = u && o[u]) && l.apply && V(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault());
                return e.type = d, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !V(n) || u && m(n[d]) && !x(n) && ((a = n[u]) && (n[u] = null), S.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, xt), n[d](), e.isPropagationStopped() && f.removeEventListener(d, xt), S.event.triggered = void 0, a && (n[u] = a)), e.result
            }
        },
        simulate: function(e, t, n) {
            var r = S.extend(new S.Event, n, { type: e, isSimulated: !0 });
            S.event.trigger(r, null, t)
        }
    }), S.fn.extend({ trigger: function(e, t) { return this.each(function() { S.event.trigger(e, t, this) }) }, triggerHandler: function(e, t) { var n = this[0]; if (n) return S.event.trigger(e, t, n, !0) } }), y.focusin || S.each({ focus: "focusin", blur: "focusout" }, function(n, r) {
        var i = function(e) { S.event.simulate(r, e.target, S.event.fix(e)) };
        S.event.special[r] = {
            setup: function() {
                var e = this.ownerDocument || this.document || this,
                    t = Y.access(e, r);
                t || e.addEventListener(n, i, !0), Y.access(e, r, (t || 0) + 1)
            },
            teardown: function() {
                var e = this.ownerDocument || this.document || this,
                    t = Y.access(e, r) - 1;
                t ? Y.access(e, r, t) : (e.removeEventListener(n, i, !0), Y.remove(e, r))
            }
        }
    });
    var bt = C.location,
        wt = { guid: Date.now() },
        Tt = /\?/;
    S.parseXML = function(e) { var t, n; if (!e || "string" != typeof e) return null; try { t = (new C.DOMParser).parseFromString(e, "text/xml") } catch (e) {} return n = t && t.getElementsByTagName("parsererror")[0], t && !n || S.error("Invalid XML: " + (n ? S.map(n.childNodes, function(e) { return e.textContent }).join("\n") : e)), t };
    var Ct = /\[\]$/,
        Et = /\r?\n/g,
        St = /^(?:submit|button|image|reset|file)$/i,
        kt = /^(?:input|select|textarea|keygen)/i;

    function At(n, e, r, i) {
        var t;
        if (Array.isArray(e)) S.each(e, function(e, t) { r || Ct.test(n) ? i(n, t) : At(n + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, r, i) });
        else if (r || "object" !== w(e)) i(n, e);
        else
            for (t in e) At(n + "[" + t + "]", e[t], r, i)
    }
    S.param = function(e, t) {
        var n, r = [],
            i = function(e, t) {
                var n = m(t) ? t() : t;
                r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n)
            };
        if (null == e) return "";
        if (Array.isArray(e) || e.jquery && !S.isPlainObject(e)) S.each(e, function() { i(this.name, this.value) });
        else
            for (n in e) At(n, e[n], t, i);
        return r.join("&")
    }, S.fn.extend({ serialize: function() { return S.param(this.serializeArray()) }, serializeArray: function() { return this.map(function() { var e = S.prop(this, "elements"); return e ? S.makeArray(e) : this }).filter(function() { var e = this.type; return this.name && !S(this).is(":disabled") && kt.test(this.nodeName) && !St.test(e) && (this.checked || !pe.test(e)) }).map(function(e, t) { var n = S(this).val(); return null == n ? null : Array.isArray(n) ? S.map(n, function(e) { return { name: t.name, value: e.replace(Et, "\r\n") } }) : { name: t.name, value: n.replace(Et, "\r\n") } }).get() } });
    var Nt = /%20/g,
        jt = /#.*$/,
        Dt = /([?&])_=[^&]*/,
        qt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
        Lt = /^(?:GET|HEAD)$/,
        Ht = /^\/\//,
        Ot = {},
        Pt = {},
        Rt = "*/".concat("*"),
        Mt = E.createElement("a");

    function It(o) {
        return function(e, t) {
            "string" != typeof e && (t = e, e = "*");
            var n, r = 0,
                i = e.toLowerCase().match(P) || [];
            if (m(t))
                while (n = i[r++]) "+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t)
        }
    }

    function Wt(t, i, o, a) {
        var s = {},
            u = t === Pt;

        function l(e) { var r; return s[e] = !0, S.each(t[e] || [], function(e, t) { var n = t(i, o, a); return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1) }), r }
        return l(i.dataTypes[0]) || !s["*"] && l("*")
    }

    function Ft(e, t) { var n, r, i = S.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]); return r && S.extend(!0, e, r), e }
    Mt.href = bt.href, S.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: { url: bt.href, type: "GET", isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Rt, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": S.parseXML }, flatOptions: { url: !0, context: !0 } },
        ajaxSetup: function(e, t) { return t ? Ft(Ft(e, S.ajaxSettings), t) : Ft(S.ajaxSettings, e) },
        ajaxPrefilter: It(Ot),
        ajaxTransport: It(Pt),
        ajax: function(e, t) {
            "object" == typeof e && (t = e, e = void 0), t = t || {};
            var c, f, p, n, d, r, h, g, i, o, v = S.ajaxSetup({}, t),
                y = v.context || v,
                m = v.context && (y.nodeType || y.jquery) ? S(y) : S.event,
                x = S.Deferred(),
                b = S.Callbacks("once memory"),
                w = v.statusCode || {},
                a = {},
                s = {},
                u = "canceled",
                T = {
                    readyState: 0,
                    getResponseHeader: function(e) {
                        var t;
                        if (h) {
                            if (!n) { n = {}; while (t = qt.exec(p)) n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2]) }
                            t = n[e.toLowerCase() + " "]
                        }
                        return null == t ? null : t.join(", ")
                    },
                    getAllResponseHeaders: function() { return h ? p : null },
                    setRequestHeader: function(e, t) { return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this },
                    overrideMimeType: function(e) { return null == h && (v.mimeType = e), this },
                    statusCode: function(e) {
                        var t;
                        if (e)
                            if (h) T.always(e[T.status]);
                            else
                                for (t in e) w[t] = [w[t], e[t]];
                        return this
                    },
                    abort: function(e) { var t = e || u; return c && c.abort(t), l(0, t), this }
                };
            if (x.promise(T), v.url = ((e || v.url || bt.href) + "").replace(Ht, bt.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(P) || [""], null == v.crossDomain) { r = E.createElement("a"); try { r.href = v.url, r.href = r.href, v.crossDomain = Mt.protocol + "//" + Mt.host != r.protocol + "//" + r.host } catch (e) { v.crossDomain = !0 } }
            if (v.data && v.processData && "string" != typeof v.data && (v.data = S.param(v.data, v.traditional)), Wt(Ot, v, t, T), h) return T;
            for (i in (g = S.event && v.global) && 0 == S.active++ && S.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Lt.test(v.type), f = v.url.replace(jt, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(Nt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (Tt.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(Dt, "$1"), o = (Tt.test(f) ? "&" : "?") + "_=" + wt.guid++ + o), v.url = f + o), v.ifModified && (S.lastModified[f] && T.setRequestHeader("If-Modified-Since", S.lastModified[f]), S.etag[f] && T.setRequestHeader("If-None-Match", S.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + Rt + "; q=0.01" : "") : v.accepts["*"]), v.headers) T.setRequestHeader(i, v.headers[i]);
            if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort();
            if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = Wt(Pt, v, t, T)) {
                if (T.readyState = 1, g && m.trigger("ajaxSend", [T, v]), h) return T;
                v.async && 0 < v.timeout && (d = C.setTimeout(function() { T.abort("timeout") }, v.timeout));
                try { h = !1, c.send(a, l) } catch (e) {
                    if (h) throw e;
                    l(-1, e)
                }
            } else l(-1, "No Transport");

            function l(e, t, n, r) {
                var i, o, a, s, u, l = t;
                h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function(e, t, n) {
                    var r, i, o, a, s = e.contents,
                        u = e.dataTypes;
                    while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
                    if (r)
                        for (i in s)
                            if (s[i] && s[i].test(r)) { u.unshift(i); break }
                    if (u[0] in n) o = u[0];
                    else {
                        for (i in n) {
                            if (!u[0] || e.converters[i + " " + u[0]]) { o = i; break }
                            a || (a = i)
                        }
                        o = o || a
                    }
                    if (o) return o !== u[0] && u.unshift(o), n[o]
                }(v, T, n)), !i && -1 < S.inArray("script", v.dataTypes) && S.inArray("json", v.dataTypes) < 0 && (v.converters["text script"] = function() {}), s = function(e, t, n, r) {
                    var i, o, a, s, u, l = {},
                        c = e.dataTypes.slice();
                    if (c[1])
                        for (a in e.converters) l[a.toLowerCase()] = e.converters[a];
                    o = c.shift();
                    while (o)
                        if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift())
                            if ("*" === o) o = u;
                            else if ("*" !== u && u !== o) {
                        if (!(a = l[u + " " + o] || l["* " + o]))
                            for (i in l)
                                if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) {!0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1])); break }
                        if (!0 !== a)
                            if (a && e["throws"]) t = a(t);
                            else try { t = a(t) } catch (e) { return { state: "parsererror", error: a ? e : "No conversion from " + u + " to " + o } }
                    }
                    return { state: "success", data: t }
                }(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (S.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (S.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [T, v, i ? o : a]), b.fireWith(y, [T, l]), g && (m.trigger("ajaxComplete", [T, v]), --S.active || S.event.trigger("ajaxStop")))
            }
            return T
        },
        getJSON: function(e, t, n) { return S.get(e, t, n, "json") },
        getScript: function(e, t) { return S.get(e, void 0, t, "script") }
    }), S.each(["get", "post"], function(e, i) { S[i] = function(e, t, n, r) { return m(t) && (r = r || n, n = t, t = void 0), S.ajax(S.extend({ url: e, type: i, dataType: r, data: t, success: n }, S.isPlainObject(e) && e)) } }), S.ajaxPrefilter(function(e) { var t; for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "") }), S._evalUrl = function(e, t, n) { return S.ajax({ url: e, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, converters: { "text script": function() {} }, dataFilter: function(e) { S.globalEval(e, t, n) } }) }, S.fn.extend({
        wrapAll: function(e) { var t; return this[0] && (m(e) && (e = e.call(this[0])), t = S(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function() { var e = this; while (e.firstElementChild) e = e.firstElementChild; return e }).append(this)), this },
        wrapInner: function(n) {
            return m(n) ? this.each(function(e) { S(this).wrapInner(n.call(this, e)) }) : this.each(function() {
                var e = S(this),
                    t = e.contents();
                t.length ? t.wrapAll(n) : e.append(n)
            })
        },
        wrap: function(t) { var n = m(t); return this.each(function(e) { S(this).wrapAll(n ? t.call(this, e) : t) }) },
        unwrap: function(e) { return this.parent(e).not("body").each(function() { S(this).replaceWith(this.childNodes) }), this }
    }), S.expr.pseudos.hidden = function(e) { return !S.expr.pseudos.visible(e) }, S.expr.pseudos.visible = function(e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length) }, S.ajaxSettings.xhr = function() { try { return new C.XMLHttpRequest } catch (e) {} };
    var Bt = { 0: 200, 1223: 204 },
        $t = S.ajaxSettings.xhr();
    y.cors = !!$t && "withCredentials" in $t, y.ajax = $t = !!$t, S.ajaxTransport(function(i) {
        var o, a;
        if (y.cors || $t && !i.crossDomain) return {
            send: function(e, t) {
                var n, r = i.xhr();
                if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields)
                    for (n in i.xhrFields) r[n] = i.xhrFields[n];
                for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader(n, e[n]);
                o = function(e) { return function() { o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Bt[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? { binary: r.response } : { text: r.responseText }, r.getAllResponseHeaders())) } }, r.onload = o(), a = r.onerror = r.ontimeout = o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function() { 4 === r.readyState && C.setTimeout(function() { o && a() }) }, o = o("abort");
                try { r.send(i.hasContent && i.data || null) } catch (e) { if (o) throw e }
            },
            abort: function() { o && o() }
        }
    }), S.ajaxPrefilter(function(e) { e.crossDomain && (e.contents.script = !1) }), S.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function(e) { return S.globalEval(e), e } } }), S.ajaxPrefilter("script", function(e) { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET") }), S.ajaxTransport("script", function(n) { var r, i; if (n.crossDomain || n.scriptAttrs) return { send: function(e, t) { r = S("<script>").attr(n.scriptAttrs || {}).prop({ charset: n.scriptCharset, src: n.url }).on("load error", i = function(e) { r.remove(), i = null, e && t("error" === e.type ? 404 : 200, e.type) }), E.head.appendChild(r[0]) }, abort: function() { i && i() } } });
    var _t, zt = [],
        Ut = /(=)\?(?=&|$)|\?\?/;
    S.ajaxSetup({ jsonp: "callback", jsonpCallback: function() { var e = zt.pop() || S.expando + "_" + wt.guid++; return this[e] = !0, e } }), S.ajaxPrefilter("json jsonp", function(e, t, n) { var r, i, o, a = !1 !== e.jsonp && (Ut.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ut.test(e.data) && "data"); if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Ut, "$1" + r) : !1 !== e.jsonp && (e.url += (Tt.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function() { return o || S.error(r + " was not called"), o[0] }, e.dataTypes[0] = "json", i = C[r], C[r] = function() { o = arguments }, n.always(function() { void 0 === i ? S(C).removeProp(r) : C[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, zt.push(r)), o && m(i) && i(o[0]), o = i = void 0 }), "script" }), y.createHTMLDocument = ((_t = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === _t.childNodes.length), S.parseHTML = function(e, t, n) { return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = N.exec(e)) ? [t.createElement(i[1])] : (i = xe([e], t, o), o && o.length && S(o).remove(), S.merge([], i.childNodes))); var r, i, o }, S.fn.load = function(e, t, n) {
        var r, i, o, a = this,
            s = e.indexOf(" ");
        return -1 < s && (r = ht(e.slice(s)), e = e.slice(0, s)), m(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), 0 < a.length && S.ajax({ url: e, type: i || "GET", dataType: "html", data: t }).done(function(e) { o = arguments, a.html(r ? S("<div>").append(S.parseHTML(e)).find(r) : e) }).always(n && function(e, t) { a.each(function() { n.apply(this, o || [e.responseText, t, e]) }) }), this
    }, S.expr.pseudos.animated = function(t) { return S.grep(S.timers, function(e) { return t === e.elem }).length }, S.offset = {
        setOffset: function(e, t, n) {
            var r, i, o, a, s, u, l = S.css(e, "position"),
                c = S(e),
                f = {};
            "static" === l && (e.style.position = "relative"), s = c.offset(), o = S.css(e, "top"), u = S.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), m(t) && (t = t.call(e, n, S.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : c.css(f)
        }
    }, S.fn.extend({
        offset: function(t) { if (arguments.length) return void 0 === t ? this : this.each(function(e) { S.offset.setOffset(this, t, e) }); var e, n, r = this[0]; return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: e.top + n.pageYOffset, left: e.left + n.pageXOffset }) : { top: 0, left: 0 } : void 0 },
        position: function() {
            if (this[0]) {
                var e, t, n, r = this[0],
                    i = { top: 0, left: 0 };
                if ("fixed" === S.css(r, "position")) t = r.getBoundingClientRect();
                else {
                    t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement;
                    while (e && (e === n.body || e === n.documentElement) && "static" === S.css(e, "position")) e = e.parentNode;
                    e && e !== r && 1 === e.nodeType && ((i = S(e).offset()).top += S.css(e, "borderTopWidth", !0), i.left += S.css(e, "borderLeftWidth", !0))
                }
                return { top: t.top - i.top - S.css(r, "marginTop", !0), left: t.left - i.left - S.css(r, "marginLeft", !0) }
            }
        },
        offsetParent: function() { return this.map(function() { var e = this.offsetParent; while (e && "static" === S.css(e, "position")) e = e.offsetParent; return e || re }) }
    }), S.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(t, i) {
        var o = "pageYOffset" === i;
        S.fn[t] = function(e) {
            return $(this, function(e, t, n) {
                var r;
                if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t];
                r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n
            }, t, e, arguments.length)
        }
    }), S.each(["top", "left"], function(e, n) { S.cssHooks[n] = Fe(y.pixelPosition, function(e, t) { if (t) return t = We(e, n), Pe.test(t) ? S(e).position()[n] + "px" : t }) }), S.each({ Height: "height", Width: "width" }, function(a, s) {
        S.each({ padding: "inner" + a, content: s, "": "outer" + a }, function(r, o) {
            S.fn[o] = function(e, t) {
                var n = arguments.length && (r || "boolean" != typeof e),
                    i = r || (!0 === e || !0 === t ? "margin" : "border");
                return $(this, function(e, t, n) { var r; return x(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? S.css(e, t, i) : S.style(e, t, n, i) }, s, n ? e : void 0, n)
            }
        })
    }), S.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e, t) { S.fn[t] = function(e) { return this.on(t, e) } }), S.fn.extend({ bind: function(e, t, n) { return this.on(e, null, t, n) }, unbind: function(e, t) { return this.off(e, null, t) }, delegate: function(e, t, n, r) { return this.on(t, e, n, r) }, undelegate: function(e, t, n) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n) }, hover: function(e, t) { return this.mouseenter(e).mouseleave(t || e) } }), S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(e, n) { S.fn[n] = function(e, t) { return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n) } });
    var Xt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    S.proxy = function(e, t) { var n, r, i; if ("string" == typeof t && (n = e[t], t = e, e = n), m(e)) return r = s.call(arguments, 2), (i = function() { return e.apply(t || this, r.concat(s.call(arguments))) }).guid = e.guid = e.guid || S.guid++, i }, S.holdReady = function(e) { e ? S.readyWait++ : S.ready(!0) }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function(e) { var t = S.type(e); return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e)) }, S.trim = function(e) { return null == e ? "" : (e + "").replace(Xt, "") }, "function" == typeof define && define.amd && define("jquery", [], function() { return S });
    var Vt = C.jQuery,
        Gt = C.$;
    return S.noConflict = function(e) { return C.$ === S && (C.$ = Gt), e && C.jQuery === S && (C.jQuery = Vt), S }, "undefined" == typeof e && (C.jQuery = C.$ = S), S
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJqcXVlcnktMy42LjAubWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBqUXVlcnkgdjMuNi4wIHwgKGMpIE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgfCBqcXVlcnkub3JnL2xpY2Vuc2UgKi8gISBmdW5jdGlvbihlLCB0KSB7IFwidXNlIHN0cmljdFwiOyBcIm9iamVjdFwiID09IHR5cGVvZiBtb2R1bGUgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPyBtb2R1bGUuZXhwb3J0cyA9IGUuZG9jdW1lbnQgPyB0KGUsICEwKSA6IGZ1bmN0aW9uKGUpIHsgaWYgKCFlLmRvY3VtZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIpOyByZXR1cm4gdChlKSB9IDogdChlKSB9KFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKEMsIGUpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgdmFyIHQgPSBbXSxcclxuICAgICAgICByID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxyXG4gICAgICAgIHMgPSB0LnNsaWNlLFxyXG4gICAgICAgIGcgPSB0LmZsYXQgPyBmdW5jdGlvbihlKSB7IHJldHVybiB0LmZsYXQuY2FsbChlKSB9IDogZnVuY3Rpb24oZSkgeyByZXR1cm4gdC5jb25jYXQuYXBwbHkoW10sIGUpIH0sXHJcbiAgICAgICAgdSA9IHQucHVzaCxcclxuICAgICAgICBpID0gdC5pbmRleE9mLFxyXG4gICAgICAgIG4gPSB7fSxcclxuICAgICAgICBvID0gbi50b1N0cmluZyxcclxuICAgICAgICB2ID0gbi5oYXNPd25Qcm9wZXJ0eSxcclxuICAgICAgICBhID0gdi50b1N0cmluZyxcclxuICAgICAgICBsID0gYS5jYWxsKE9iamVjdCksXHJcbiAgICAgICAgeSA9IHt9LFxyXG4gICAgICAgIG0gPSBmdW5jdGlvbihlKSB7IHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgJiYgXCJudW1iZXJcIiAhPSB0eXBlb2YgZS5ub2RlVHlwZSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUuaXRlbSB9LFxyXG4gICAgICAgIHggPSBmdW5jdGlvbihlKSB7IHJldHVybiBudWxsICE9IGUgJiYgZSA9PT0gZS53aW5kb3cgfSxcclxuICAgICAgICBFID0gQy5kb2N1bWVudCxcclxuICAgICAgICBjID0geyB0eXBlOiAhMCwgc3JjOiAhMCwgbm9uY2U6ICEwLCBub01vZHVsZTogITAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBiKGUsIHQsIG4pIHtcclxuICAgICAgICB2YXIgciwgaSwgbyA9IChuID0gbiB8fCBFKS5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG4gICAgICAgIGlmIChvLnRleHQgPSBlLCB0KVxyXG4gICAgICAgICAgICBmb3IgKHIgaW4gYykoaSA9IHRbcl0gfHwgdC5nZXRBdHRyaWJ1dGUgJiYgdC5nZXRBdHRyaWJ1dGUocikpICYmIG8uc2V0QXR0cmlidXRlKHIsIGkpO1xyXG4gICAgICAgIG4uaGVhZC5hcHBlbmRDaGlsZChvKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG8pXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdyhlKSB7IHJldHVybiBudWxsID09IGUgPyBlICsgXCJcIiA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlID8gbltvLmNhbGwoZSldIHx8IFwib2JqZWN0XCIgOiB0eXBlb2YgZSB9XHJcbiAgICB2YXIgZiA9IFwiMy42LjBcIixcclxuICAgICAgICBTID0gZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gbmV3IFMuZm4uaW5pdChlLCB0KSB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHAoZSkge1xyXG4gICAgICAgIHZhciB0ID0gISFlICYmIFwibGVuZ3RoXCIgaW4gZSAmJiBlLmxlbmd0aCxcclxuICAgICAgICAgICAgbiA9IHcoZSk7XHJcbiAgICAgICAgcmV0dXJuICFtKGUpICYmICF4KGUpICYmIChcImFycmF5XCIgPT09IG4gfHwgMCA9PT0gdCB8fCBcIm51bWJlclwiID09IHR5cGVvZiB0ICYmIDAgPCB0ICYmIHQgLSAxIGluIGUpXHJcbiAgICB9XHJcbiAgICBTLmZuID0gUy5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAganF1ZXJ5OiBmLFxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBTLFxyXG4gICAgICAgIGxlbmd0aDogMCxcclxuICAgICAgICB0b0FycmF5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHMuY2FsbCh0aGlzKSB9LFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oZSkgeyByZXR1cm4gbnVsbCA9PSBlID8gcy5jYWxsKHRoaXMpIDogZSA8IDAgPyB0aGlzW2UgKyB0aGlzLmxlbmd0aF0gOiB0aGlzW2VdIH0sXHJcbiAgICAgICAgcHVzaFN0YWNrOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gUy5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksIGUpOyByZXR1cm4gdC5wcmV2T2JqZWN0ID0gdGhpcywgdCB9LFxyXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIFMuZWFjaCh0aGlzLCBlKSB9LFxyXG4gICAgICAgIG1hcDogZnVuY3Rpb24obikgeyByZXR1cm4gdGhpcy5wdXNoU3RhY2soUy5tYXAodGhpcywgZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gbi5jYWxsKGUsIHQsIGUpIH0pKSB9LFxyXG4gICAgICAgIHNsaWNlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgfSxcclxuICAgICAgICBmaXJzdDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmVxKDApIH0sXHJcbiAgICAgICAgbGFzdDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmVxKC0xKSB9LFxyXG4gICAgICAgIGV2ZW46IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5wdXNoU3RhY2soUy5ncmVwKHRoaXMsIGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuICh0ICsgMSkgJSAyIH0pKSB9LFxyXG4gICAgICAgIG9kZDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnB1c2hTdGFjayhTLmdyZXAodGhpcywgZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gdCAlIDIgfSkpIH0sXHJcbiAgICAgICAgZXE6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIG4gPSArZSArIChlIDwgMCA/IHQgOiAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKDAgPD0gbiAmJiBuIDwgdCA/IFt0aGlzW25dXSA6IFtdKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5kOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCkgfSxcclxuICAgICAgICBwdXNoOiB1LFxyXG4gICAgICAgIHNvcnQ6IHQuc29ydCxcclxuICAgICAgICBzcGxpY2U6IHQuc3BsaWNlXHJcbiAgICB9LCBTLmV4dGVuZCA9IFMuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGUsIHQsIG4sIHIsIGksIG8sIGEgPSBhcmd1bWVudHNbMF0gfHwge30sXHJcbiAgICAgICAgICAgIHMgPSAxLFxyXG4gICAgICAgICAgICB1ID0gYXJndW1lbnRzLmxlbmd0aCxcclxuICAgICAgICAgICAgbCA9ICExO1xyXG4gICAgICAgIGZvciAoXCJib29sZWFuXCIgPT0gdHlwZW9mIGEgJiYgKGwgPSBhLCBhID0gYXJndW1lbnRzW3NdIHx8IHt9LCBzKyspLCBcIm9iamVjdFwiID09IHR5cGVvZiBhIHx8IG0oYSkgfHwgKGEgPSB7fSksIHMgPT09IHUgJiYgKGEgPSB0aGlzLCBzLS0pOyBzIDwgdTsgcysrKVxyXG4gICAgICAgICAgICBpZiAobnVsbCAhPSAoZSA9IGFyZ3VtZW50c1tzXSkpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHQgaW4gZSkgciA9IGVbdF0sIFwiX19wcm90b19fXCIgIT09IHQgJiYgYSAhPT0gciAmJiAobCAmJiByICYmIChTLmlzUGxhaW5PYmplY3QocikgfHwgKGkgPSBBcnJheS5pc0FycmF5KHIpKSkgPyAobiA9IGFbdF0sIG8gPSBpICYmICFBcnJheS5pc0FycmF5KG4pID8gW10gOiBpIHx8IFMuaXNQbGFpbk9iamVjdChuKSA/IG4gOiB7fSwgaSA9ICExLCBhW3RdID0gUy5leHRlbmQobCwgbywgcikpIDogdm9pZCAwICE9PSByICYmIChhW3RdID0gcikpO1xyXG4gICAgICAgIHJldHVybiBhXHJcbiAgICB9LCBTLmV4dGVuZCh7XHJcbiAgICAgICAgZXhwYW5kbzogXCJqUXVlcnlcIiArIChmICsgTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxEL2csIFwiXCIpLFxyXG4gICAgICAgIGlzUmVhZHk6ICEwLFxyXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbihlKSB7IHRocm93IG5ldyBFcnJvcihlKSB9LFxyXG4gICAgICAgIG5vb3A6IGZ1bmN0aW9uKCkge30sXHJcbiAgICAgICAgaXNQbGFpbk9iamVjdDogZnVuY3Rpb24oZSkgeyB2YXIgdCwgbjsgcmV0dXJuICEoIWUgfHwgXCJbb2JqZWN0IE9iamVjdF1cIiAhPT0gby5jYWxsKGUpKSAmJiAoISh0ID0gcihlKSkgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZihuID0gdi5jYWxsKHQsIFwiY29uc3RydWN0b3JcIikgJiYgdC5jb25zdHJ1Y3RvcikgJiYgYS5jYWxsKG4pID09PSBsKSB9LFxyXG4gICAgICAgIGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKGUpIHsgdmFyIHQ7IGZvciAodCBpbiBlKSByZXR1cm4gITE7IHJldHVybiAhMCB9LFxyXG4gICAgICAgIGdsb2JhbEV2YWw6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgYihlLCB7IG5vbmNlOiB0ICYmIHQubm9uY2UgfSwgbikgfSxcclxuICAgICAgICBlYWNoOiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgIHZhciBuLCByID0gMDtcclxuICAgICAgICAgICAgaWYgKHAoZSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobiA9IGUubGVuZ3RoOyByIDwgbjsgcisrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghMSA9PT0gdC5jYWxsKGVbcl0sIHIsIGVbcl0pKSBicmVha1xyXG4gICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgIGZvciAociBpbiBlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghMSA9PT0gdC5jYWxsKGVbcl0sIHIsIGVbcl0pKSBicmVhazsgcmV0dXJuIGVcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1ha2VBcnJheTogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiA9IHQgfHwgW107IHJldHVybiBudWxsICE9IGUgJiYgKHAoT2JqZWN0KGUpKSA/IFMubWVyZ2UobiwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IFtlXSA6IGUpIDogdS5jYWxsKG4sIGUpKSwgbiB9LFxyXG4gICAgICAgIGluQXJyYXk6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgcmV0dXJuIG51bGwgPT0gdCA/IC0xIDogaS5jYWxsKHQsIGUsIG4pIH0sXHJcbiAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uKGUsIHQpIHsgZm9yICh2YXIgbiA9ICt0Lmxlbmd0aCwgciA9IDAsIGkgPSBlLmxlbmd0aDsgciA8IG47IHIrKykgZVtpKytdID0gdFtyXTsgcmV0dXJuIGUubGVuZ3RoID0gaSwgZSB9LFxyXG4gICAgICAgIGdyZXA6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgZm9yICh2YXIgciA9IFtdLCBpID0gMCwgbyA9IGUubGVuZ3RoLCBhID0gIW47IGkgPCBvOyBpKyspICF0KGVbaV0sIGkpICE9PSBhICYmIHIucHVzaChlW2ldKTsgcmV0dXJuIHIgfSxcclxuICAgICAgICBtYXA6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcclxuICAgICAgICAgICAgdmFyIHIsIGksIG8gPSAwLFxyXG4gICAgICAgICAgICAgICAgYSA9IFtdO1xyXG4gICAgICAgICAgICBpZiAocChlKSlcclxuICAgICAgICAgICAgICAgIGZvciAociA9IGUubGVuZ3RoOyBvIDwgcjsgbysrKSBudWxsICE9IChpID0gdChlW29dLCBvLCBuKSkgJiYgYS5wdXNoKGkpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBmb3IgKG8gaW4gZSkgbnVsbCAhPSAoaSA9IHQoZVtvXSwgbywgbikpICYmIGEucHVzaChpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGcoYSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGd1aWQ6IDEsXHJcbiAgICAgICAgc3VwcG9ydDogeVxyXG4gICAgfSksIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIChTLmZuW1N5bWJvbC5pdGVyYXRvcl0gPSB0W1N5bWJvbC5pdGVyYXRvcl0pLCBTLmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oZSwgdCkgeyBuW1wiW29iamVjdCBcIiArIHQgKyBcIl1cIl0gPSB0LnRvTG93ZXJDYXNlKCkgfSk7XHJcbiAgICB2YXIgZCA9IGZ1bmN0aW9uKG4pIHtcclxuICAgICAgICB2YXIgZSwgZCwgYiwgbywgaSwgaCwgZiwgZywgdywgdSwgbCwgVCwgQywgYSwgRSwgdiwgcywgYywgeSwgUyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUsXHJcbiAgICAgICAgICAgIHAgPSBuLmRvY3VtZW50LFxyXG4gICAgICAgICAgICBrID0gMCxcclxuICAgICAgICAgICAgciA9IDAsXHJcbiAgICAgICAgICAgIG0gPSB1ZSgpLFxyXG4gICAgICAgICAgICB4ID0gdWUoKSxcclxuICAgICAgICAgICAgQSA9IHVlKCksXHJcbiAgICAgICAgICAgIE4gPSB1ZSgpLFxyXG4gICAgICAgICAgICBqID0gZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gZSA9PT0gdCAmJiAobCA9ICEwKSwgMCB9LFxyXG4gICAgICAgICAgICBEID0ge30uaGFzT3duUHJvcGVydHksXHJcbiAgICAgICAgICAgIHQgPSBbXSxcclxuICAgICAgICAgICAgcSA9IHQucG9wLFxyXG4gICAgICAgICAgICBMID0gdC5wdXNoLFxyXG4gICAgICAgICAgICBIID0gdC5wdXNoLFxyXG4gICAgICAgICAgICBPID0gdC5zbGljZSxcclxuICAgICAgICAgICAgUCA9IGZ1bmN0aW9uKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwLCByID0gZS5sZW5ndGg7IG4gPCByOyBuKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVbbl0gPT09IHQpIHJldHVybiBuO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFIgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXHJcbiAgICAgICAgICAgIE0gPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXHJcbiAgICAgICAgICAgIEkgPSBcIig/OlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyBNICsgXCI/fFxcXFxcXFxcW15cXFxcclxcXFxuXFxcXGZdfFtcXFxcdy1dfFteXFwwLVxcXFx4N2ZdKStcIixcclxuICAgICAgICAgICAgVyA9IFwiXFxcXFtcIiArIE0gKyBcIiooXCIgKyBJICsgXCIpKD86XCIgKyBNICsgXCIqKFsqXiR8IX5dPz0pXCIgKyBNICsgXCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIEkgKyBcIikpfClcIiArIE0gKyBcIipcXFxcXVwiLFxyXG4gICAgICAgICAgICBGID0gXCI6KFwiICsgSSArIFwiKSg/OlxcXFwoKCgnKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIFcgKyBcIikqKXwuKilcXFxcKXwpXCIsXHJcbiAgICAgICAgICAgIEIgPSBuZXcgUmVnRXhwKE0gKyBcIitcIiwgXCJnXCIpLFxyXG4gICAgICAgICAgICAkID0gbmV3IFJlZ0V4cChcIl5cIiArIE0gKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyBNICsgXCIrJFwiLCBcImdcIiksXHJcbiAgICAgICAgICAgIF8gPSBuZXcgUmVnRXhwKFwiXlwiICsgTSArIFwiKixcIiArIE0gKyBcIipcIiksXHJcbiAgICAgICAgICAgIHogPSBuZXcgUmVnRXhwKFwiXlwiICsgTSArIFwiKihbPit+XXxcIiArIE0gKyBcIilcIiArIE0gKyBcIipcIiksXHJcbiAgICAgICAgICAgIFUgPSBuZXcgUmVnRXhwKE0gKyBcInw+XCIpLFxyXG4gICAgICAgICAgICBYID0gbmV3IFJlZ0V4cChGKSxcclxuICAgICAgICAgICAgViA9IG5ldyBSZWdFeHAoXCJeXCIgKyBJICsgXCIkXCIpLFxyXG4gICAgICAgICAgICBHID0geyBJRDogbmV3IFJlZ0V4cChcIl4jKFwiICsgSSArIFwiKVwiKSwgQ0xBU1M6IG5ldyBSZWdFeHAoXCJeXFxcXC4oXCIgKyBJICsgXCIpXCIpLCBUQUc6IG5ldyBSZWdFeHAoXCJeKFwiICsgSSArIFwifFsqXSlcIiksIEFUVFI6IG5ldyBSZWdFeHAoXCJeXCIgKyBXKSwgUFNFVURPOiBuZXcgUmVnRXhwKFwiXlwiICsgRiksIENISUxEOiBuZXcgUmVnRXhwKFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIE0gKyBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgTSArIFwiKig/OihbKy1dfClcIiArIE0gKyBcIiooXFxcXGQrKXwpKVwiICsgTSArIFwiKlxcXFwpfClcIiwgXCJpXCIpLCBib29sOiBuZXcgUmVnRXhwKFwiXig/OlwiICsgUiArIFwiKSRcIiwgXCJpXCIpLCBuZWVkc0NvbnRleHQ6IG5ldyBSZWdFeHAoXCJeXCIgKyBNICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICsgTSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIE0gKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIikgfSxcclxuICAgICAgICAgICAgWSA9IC9IVE1MJC9pLFxyXG4gICAgICAgICAgICBRID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcclxuICAgICAgICAgICAgSiA9IC9eaFxcZCQvaSxcclxuICAgICAgICAgICAgSyA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXHJcbiAgICAgICAgICAgIFogPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcclxuICAgICAgICAgICAgZWUgPSAvWyt+XS8sXHJcbiAgICAgICAgICAgIHRlID0gbmV3IFJlZ0V4cChcIlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyBNICsgXCI/fFxcXFxcXFxcKFteXFxcXHJcXFxcblxcXFxmXSlcIiwgXCJnXCIpLFxyXG4gICAgICAgICAgICBuZSA9IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4gPSBcIjB4XCIgKyBlLnNsaWNlKDEpIC0gNjU1MzY7IHJldHVybiB0IHx8IChuIDwgMCA/IFN0cmluZy5mcm9tQ2hhckNvZGUobiArIDY1NTM2KSA6IFN0cmluZy5mcm9tQ2hhckNvZGUobiA+PiAxMCB8IDU1Mjk2LCAxMDIzICYgbiB8IDU2MzIwKSkgfSxcclxuICAgICAgICAgICAgcmUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcclxuICAgICAgICAgICAgaWUgPSBmdW5jdGlvbihlLCB0KSB7IHJldHVybiB0ID8gXCJcXDBcIiA9PT0gZSA/IFwiXFx1ZmZmZFwiIDogZS5zbGljZSgwLCAtMSkgKyBcIlxcXFxcIiArIGUuY2hhckNvZGVBdChlLmxlbmd0aCAtIDEpLnRvU3RyaW5nKDE2KSArIFwiIFwiIDogXCJcXFxcXCIgKyBlIH0sXHJcbiAgICAgICAgICAgIG9lID0gZnVuY3Rpb24oKSB7IFQoKSB9LFxyXG4gICAgICAgICAgICBhZSA9IGJlKGZ1bmN0aW9uKGUpIHsgcmV0dXJuICEwID09PSBlLmRpc2FibGVkICYmIFwiZmllbGRzZXRcIiA9PT0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIH0sIHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9KTtcclxuICAgICAgICB0cnkgeyBILmFwcGx5KHQgPSBPLmNhbGwocC5jaGlsZE5vZGVzKSwgcC5jaGlsZE5vZGVzKSwgdFtwLmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZSB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIEggPSB7XHJcbiAgICAgICAgICAgICAgICBhcHBseTogdC5sZW5ndGggPyBmdW5jdGlvbihlLCB0KSB7IEwuYXBwbHkoZSwgTy5jYWxsKHQpKSB9IDogZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gZS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlW24rK10gPSB0W3IrK10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGUubGVuZ3RoID0gbiAtIDFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2UodCwgZSwgbiwgcikge1xyXG4gICAgICAgICAgICB2YXIgaSwgbywgYSwgcywgdSwgbCwgYywgZiA9IGUgJiYgZS5vd25lckRvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgcCA9IGUgPyBlLm5vZGVUeXBlIDogOTtcclxuICAgICAgICAgICAgaWYgKG4gPSBuIHx8IFtdLCBcInN0cmluZ1wiICE9IHR5cGVvZiB0IHx8ICF0IHx8IDEgIT09IHAgJiYgOSAhPT0gcCAmJiAxMSAhPT0gcCkgcmV0dXJuIG47XHJcbiAgICAgICAgICAgIGlmICghciAmJiAoVChlKSwgZSA9IGUgfHwgQywgRSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICgxMSAhPT0gcCAmJiAodSA9IFouZXhlYyh0KSkpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPSB1WzFdKSB7IGlmICg5ID09PSBwKSB7IGlmICghKGEgPSBlLmdldEVsZW1lbnRCeUlkKGkpKSkgcmV0dXJuIG47IGlmIChhLmlkID09PSBpKSByZXR1cm4gbi5wdXNoKGEpLCBuIH0gZWxzZSBpZiAoZiAmJiAoYSA9IGYuZ2V0RWxlbWVudEJ5SWQoaSkpICYmIHkoZSwgYSkgJiYgYS5pZCA9PT0gaSkgcmV0dXJuIG4ucHVzaChhKSwgbiB9IGVsc2UgeyBpZiAodVsyXSkgcmV0dXJuIEguYXBwbHkobiwgZS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0KSksIG47IGlmICgoaSA9IHVbM10pICYmIGQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHJldHVybiBILmFwcGx5KG4sIGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShpKSksIG4gfVxyXG4gICAgICAgICAgICAgICAgaWYgKGQucXNhICYmICFOW3QgKyBcIiBcIl0gJiYgKCF2IHx8ICF2LnRlc3QodCkpICYmICgxICE9PSBwIHx8IFwib2JqZWN0XCIgIT09IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9IHQsIGYgPSBlLCAxID09PSBwICYmIChVLnRlc3QodCkgfHwgei50ZXN0KHQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZiA9IGVlLnRlc3QodCkgJiYgeWUoZS5wYXJlbnROb2RlKSB8fCBlKSA9PT0gZSAmJiBkLnNjb3BlIHx8ICgocyA9IGUuZ2V0QXR0cmlidXRlKFwiaWRcIikpID8gcyA9IHMucmVwbGFjZShyZSwgaWUpIDogZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBzID0gUykpLCBvID0gKGwgPSBoKHQpKS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChvLS0pIGxbb10gPSAocyA/IFwiI1wiICsgcyA6IFwiOnNjb3BlXCIpICsgXCIgXCIgKyB4ZShsW29dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGwuam9pbihcIixcIilcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHsgcmV0dXJuIEguYXBwbHkobiwgZi5xdWVyeVNlbGVjdG9yQWxsKGMpKSwgbiB9IGNhdGNoIChlKSB7IE4odCwgITApIH0gZmluYWxseSB7IHMgPT09IFMgJiYgZS5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKSB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGcodC5yZXBsYWNlKCQsIFwiJDFcIiksIGUsIG4sIHIpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB1ZSgpIHsgdmFyIHIgPSBbXTsgcmV0dXJuIGZ1bmN0aW9uIGUodCwgbikgeyByZXR1cm4gci5wdXNoKHQgKyBcIiBcIikgPiBiLmNhY2hlTGVuZ3RoICYmIGRlbGV0ZSBlW3Iuc2hpZnQoKV0sIGVbdCArIFwiIFwiXSA9IG4gfSB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGxlKGUpIHsgcmV0dXJuIGVbU10gPSAhMCwgZSB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNlKGUpIHsgdmFyIHQgPSBDLmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTsgdHJ5IHsgcmV0dXJuICEhZSh0KSB9IGNhdGNoIChlKSB7IHJldHVybiAhMSB9IGZpbmFsbHkgeyB0LnBhcmVudE5vZGUgJiYgdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpLCB0ID0gbnVsbCB9IH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZmUoZSwgdCkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IGUuc3BsaXQoXCJ8XCIpLFxyXG4gICAgICAgICAgICAgICAgciA9IG4ubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZSAoci0tKSBiLmF0dHJIYW5kbGVbbltyXV0gPSB0XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwZShlLCB0KSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gdCAmJiBlLFxyXG4gICAgICAgICAgICAgICAgciA9IG4gJiYgMSA9PT0gZS5ub2RlVHlwZSAmJiAxID09PSB0Lm5vZGVUeXBlICYmIGUuc291cmNlSW5kZXggLSB0LnNvdXJjZUluZGV4O1xyXG4gICAgICAgICAgICBpZiAocikgcmV0dXJuIHI7XHJcbiAgICAgICAgICAgIGlmIChuKVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPSBuLm5leHRTaWJsaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuID09PSB0KSByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIHJldHVybiBlID8gMSA6IC0xXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkZSh0KSB7IHJldHVybiBmdW5jdGlvbihlKSB7IHJldHVybiBcImlucHV0XCIgPT09IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAmJiBlLnR5cGUgPT09IHQgfSB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGhlKG4pIHsgcmV0dXJuIGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7IHJldHVybiAoXCJpbnB1dFwiID09PSB0IHx8IFwiYnV0dG9uXCIgPT09IHQpICYmIGUudHlwZSA9PT0gbiB9IH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2UodCkgeyByZXR1cm4gZnVuY3Rpb24oZSkgeyByZXR1cm4gXCJmb3JtXCIgaW4gZSA/IGUucGFyZW50Tm9kZSAmJiAhMSA9PT0gZS5kaXNhYmxlZCA/IFwibGFiZWxcIiBpbiBlID8gXCJsYWJlbFwiIGluIGUucGFyZW50Tm9kZSA/IGUucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gdCA6IGUuZGlzYWJsZWQgPT09IHQgOiBlLmlzRGlzYWJsZWQgPT09IHQgfHwgZS5pc0Rpc2FibGVkICE9PSAhdCAmJiBhZShlKSA9PT0gdCA6IGUuZGlzYWJsZWQgPT09IHQgOiBcImxhYmVsXCIgaW4gZSAmJiBlLmRpc2FibGVkID09PSB0IH0gfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB2ZShhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsZShmdW5jdGlvbihvKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbyA9ICtvLCBsZShmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4sIHIgPSBhKFtdLCBlLmxlbmd0aCwgbyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSByLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSBlW24gPSByW2ldXSAmJiAoZVtuXSA9ICEodFtuXSA9IGVbbl0pKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHllKGUpIHsgcmV0dXJuIGUgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5nZXRFbGVtZW50c0J5VGFnTmFtZSAmJiBlIH1cclxuICAgICAgICBmb3IgKGUgaW4gZCA9IHNlLnN1cHBvcnQgPSB7fSwgaSA9IHNlLmlzWE1MID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBlICYmIGUubmFtZXNwYWNlVVJJLFxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBlICYmIChlLm93bmVyRG9jdW1lbnQgfHwgZSkuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFZLnRlc3QodCB8fCBuICYmIG4ubm9kZU5hbWUgfHwgXCJIVE1MXCIpXHJcbiAgICAgICAgICAgIH0sIFQgPSBzZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0LCBuLCByID0gZSA/IGUub3duZXJEb2N1bWVudCB8fCBlIDogcDtcclxuICAgICAgICAgICAgICAgIHJldHVybiByICE9IEMgJiYgOSA9PT0gci5ub2RlVHlwZSAmJiByLmRvY3VtZW50RWxlbWVudCAmJiAoYSA9IChDID0gcikuZG9jdW1lbnRFbGVtZW50LCBFID0gIWkoQyksIHAgIT0gQyAmJiAobiA9IEMuZGVmYXVsdFZpZXcpICYmIG4udG9wICE9PSBuICYmIChuLmFkZEV2ZW50TGlzdGVuZXIgPyBuLmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwgb2UsICExKSA6IG4uYXR0YWNoRXZlbnQgJiYgbi5hdHRhY2hFdmVudChcIm9udW5sb2FkXCIsIG9lKSksIGQuc2NvcGUgPSBjZShmdW5jdGlvbihlKSB7IHJldHVybiBhLmFwcGVuZENoaWxkKGUpLmFwcGVuZENoaWxkKEMuY3JlYXRlRWxlbWVudChcImRpdlwiKSksIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGUucXVlcnlTZWxlY3RvckFsbCAmJiAhZS5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlIGZpZWxkc2V0IGRpdlwiKS5sZW5ndGggfSksIGQuYXR0cmlidXRlcyA9IGNlKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUuY2xhc3NOYW1lID0gXCJpXCIsICFlLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKSB9KSwgZC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGNlKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUuYXBwZW5kQ2hpbGQoQy5jcmVhdGVDb21tZW50KFwiXCIpKSwgIWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aCB9KSwgZC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gSy50ZXN0KEMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSksIGQuZ2V0QnlJZCA9IGNlKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGEuYXBwZW5kQ2hpbGQoZSkuaWQgPSBTLCAhQy5nZXRFbGVtZW50c0J5TmFtZSB8fCAhQy5nZXRFbGVtZW50c0J5TmFtZShTKS5sZW5ndGggfSksIGQuZ2V0QnlJZCA/IChiLmZpbHRlci5JRCA9IGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBlLnJlcGxhY2UodGUsIG5lKTsgcmV0dXJuIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUuZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IHQgfSB9LCBiLmZpbmQuSUQgPSBmdW5jdGlvbihlLCB0KSB7IGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB0LmdldEVsZW1lbnRCeUlkICYmIEUpIHsgdmFyIG4gPSB0LmdldEVsZW1lbnRCeUlkKGUpOyByZXR1cm4gbiA/IFtuXSA6IFtdIH0gfSkgOiAoYi5maWx0ZXIuSUQgPSBmdW5jdGlvbihlKSB7IHZhciBuID0gZS5yZXBsYWNlKHRlLCBuZSk7IHJldHVybiBmdW5jdGlvbihlKSB7IHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5nZXRBdHRyaWJ1dGVOb2RlICYmIGUuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpOyByZXR1cm4gdCAmJiB0LnZhbHVlID09PSBuIH0gfSwgYi5maW5kLklEID0gZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB0LmdldEVsZW1lbnRCeUlkICYmIEUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4sIHIsIGksIG8gPSB0LmdldEVsZW1lbnRCeUlkKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChuID0gby5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIikpICYmIG4udmFsdWUgPT09IGUpIHJldHVybiBbb107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gdC5nZXRFbGVtZW50c0J5TmFtZShlKSwgciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobyA9IGlbcisrXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG4gPSBvLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKSkgJiYgbi52YWx1ZSA9PT0gZSkgcmV0dXJuIFtvXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLCBiLmZpbmQuVEFHID0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyB0LmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpIDogZC5xc2EgPyB0LnF1ZXJ5U2VsZWN0b3JBbGwoZSkgOiB2b2lkIDAgfSA6IGZ1bmN0aW9uKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbiwgciA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiKlwiID09PSBlKSB7IHdoaWxlIChuID0gb1tpKytdKSAxID09PSBuLm5vZGVUeXBlICYmIHIucHVzaChuKTsgcmV0dXJuIHIgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvXHJcbiAgICAgICAgICAgICAgICB9LCBiLmZpbmQuQ0xBU1MgPSBkLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oZSwgdCkgeyBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIEUpIHJldHVybiB0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZSkgfSwgcyA9IFtdLCB2ID0gW10sIChkLnFzYSA9IEsudGVzdChDLnF1ZXJ5U2VsZWN0b3JBbGwpKSAmJiAoY2UoZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0O1xyXG4gICAgICAgICAgICAgICAgICAgIGEuYXBwZW5kQ2hpbGQoZSkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBTICsgXCInPjwvYT48c2VsZWN0IGlkPSdcIiArIFMgKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz48b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggJiYgdi5wdXNoKFwiWypeJF09XCIgKyBNICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIpLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCB8fCB2LnB1c2goXCJcXFxcW1wiICsgTSArIFwiKig/OnZhbHVlfFwiICsgUiArIFwiKVwiKSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkfj1cIiArIFMgKyBcIi1dXCIpLmxlbmd0aCB8fCB2LnB1c2goXCJ+PVwiKSwgKHQgPSBDLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSkuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcIlwiKSwgZS5hcHBlbmRDaGlsZCh0KSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9JyddXCIpLmxlbmd0aCB8fCB2LnB1c2goXCJcXFxcW1wiICsgTSArIFwiKm5hbWVcIiArIE0gKyBcIio9XCIgKyBNICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIpLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggfHwgdi5wdXNoKFwiOmNoZWNrZWRcIiksIGUucXVlcnlTZWxlY3RvckFsbChcImEjXCIgKyBTICsgXCIrKlwiKS5sZW5ndGggfHwgdi5wdXNoKFwiLiMuK1srfl1cIiksIGUucXVlcnlTZWxlY3RvckFsbChcIlxcXFxcXGZcIiksIHYucHVzaChcIltcXFxcclxcXFxuXFxcXGZdXCIpXHJcbiAgICAgICAgICAgICAgICB9KSwgY2UoZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IEMuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImhpZGRlblwiKSwgZS5hcHBlbmRDaGlsZCh0KS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwiRFwiKSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICYmIHYucHVzaChcIm5hbWVcIiArIE0gKyBcIipbKl4kfCF+XT89XCIpLCAyICE9PSBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggJiYgdi5wdXNoKFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiksIGEuYXBwZW5kQ2hpbGQoZSkuZGlzYWJsZWQgPSAhMCwgMiAhPT0gZS5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAmJiB2LnB1c2goXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiKSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKSwgdi5wdXNoKFwiLC4qOlwiKVxyXG4gICAgICAgICAgICAgICAgfSkpLCAoZC5tYXRjaGVzU2VsZWN0b3IgPSBLLnRlc3QoYyA9IGEubWF0Y2hlcyB8fCBhLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBhLm1vek1hdGNoZXNTZWxlY3RvciB8fCBhLm9NYXRjaGVzU2VsZWN0b3IgfHwgYS5tc01hdGNoZXNTZWxlY3RvcikpICYmIGNlKGZ1bmN0aW9uKGUpIHsgZC5kaXNjb25uZWN0ZWRNYXRjaCA9IGMuY2FsbChlLCBcIipcIiksIGMuY2FsbChlLCBcIltzIT0nJ106eFwiKSwgcy5wdXNoKFwiIT1cIiwgRikgfSksIHYgPSB2Lmxlbmd0aCAmJiBuZXcgUmVnRXhwKHYuam9pbihcInxcIikpLCBzID0gcy5sZW5ndGggJiYgbmV3IFJlZ0V4cChzLmpvaW4oXCJ8XCIpKSwgdCA9IEsudGVzdChhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSwgeSA9IHQgfHwgSy50ZXN0KGEuY29udGFpbnMpID8gZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gOSA9PT0gZS5ub2RlVHlwZSA/IGUuZG9jdW1lbnRFbGVtZW50IDogZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHQgJiYgdC5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlID09PSByIHx8ICEoIXIgfHwgMSAhPT0gci5ub2RlVHlwZSB8fCAhKG4uY29udGFpbnMgPyBuLmNvbnRhaW5zKHIpIDogZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiAxNiAmIGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24ocikpKVxyXG4gICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodClcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHQgPSB0LnBhcmVudE5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA9PT0gZSkgcmV0dXJuICEwO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMVxyXG4gICAgICAgICAgICAgICAgfSwgaiA9IHQgPyBmdW5jdGlvbihlLCB0KSB7IGlmIChlID09PSB0KSByZXR1cm4gbCA9ICEwLCAwOyB2YXIgbiA9ICFlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIXQuY29tcGFyZURvY3VtZW50UG9zaXRpb247IHJldHVybiBuIHx8ICgxICYgKG4gPSAoZS5vd25lckRvY3VtZW50IHx8IGUpID09ICh0Lm93bmVyRG9jdW1lbnQgfHwgdCkgPyBlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHQpIDogMSkgfHwgIWQuc29ydERldGFjaGVkICYmIHQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZSkgPT09IG4gPyBlID09IEMgfHwgZS5vd25lckRvY3VtZW50ID09IHAgJiYgeShwLCBlKSA/IC0xIDogdCA9PSBDIHx8IHQub3duZXJEb2N1bWVudCA9PSBwICYmIHkocCwgdCkgPyAxIDogdSA/IFAodSwgZSkgLSBQKHUsIHQpIDogMCA6IDQgJiBuID8gLTEgOiAxKSB9IDogZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlID09PSB0KSByZXR1cm4gbCA9ICEwLCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuLCByID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGUucGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHQucGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IFtlXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IFt0XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWkgfHwgIW8pIHJldHVybiBlID09IEMgPyAtMSA6IHQgPT0gQyA/IDEgOiBpID8gLTEgOiBvID8gMSA6IHUgPyBQKHUsIGUpIC0gUCh1LCB0KSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IG8pIHJldHVybiBwZShlLCB0KTtcclxuICAgICAgICAgICAgICAgICAgICBuID0gZTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobiA9IG4ucGFyZW50Tm9kZSkgYS51bnNoaWZ0KG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuID0gbi5wYXJlbnROb2RlKSBzLnVuc2hpZnQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFbcl0gPT09IHNbcl0pIHIrKztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gciA/IHBlKGFbcl0sIHNbcl0pIDogYVtyXSA9PSBwID8gLTEgOiBzW3JdID09IHAgPyAxIDogMFxyXG4gICAgICAgICAgICAgICAgfSksIENcclxuICAgICAgICAgICAgfSwgc2UubWF0Y2hlcyA9IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHNlKGUsIG51bGwsIG51bGwsIHQpIH0sIHNlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChUKGUpLCBkLm1hdGNoZXNTZWxlY3RvciAmJiBFICYmICFOW3QgKyBcIiBcIl0gJiYgKCFzIHx8ICFzLnRlc3QodCkpICYmICghdiB8fCAhdi50ZXN0KHQpKSkgdHJ5IHsgdmFyIG4gPSBjLmNhbGwoZSwgdCk7IGlmIChuIHx8IGQuZGlzY29ubmVjdGVkTWF0Y2ggfHwgZS5kb2N1bWVudCAmJiAxMSAhPT0gZS5kb2N1bWVudC5ub2RlVHlwZSkgcmV0dXJuIG4gfSBjYXRjaCAoZSkgeyBOKHQsICEwKSB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMCA8IHNlKHQsIEMsIG51bGwsIFtlXSkubGVuZ3RoXHJcbiAgICAgICAgICAgIH0sIHNlLmNvbnRhaW5zID0gZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gKGUub3duZXJEb2N1bWVudCB8fCBlKSAhPSBDICYmIFQoZSksIHkoZSwgdCkgfSwgc2UuYXR0ciA9IGZ1bmN0aW9uKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgIChlLm93bmVyRG9jdW1lbnQgfHwgZSkgIT0gQyAmJiBUKGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBiLmF0dHJIYW5kbGVbdC50b0xvd2VyQ2FzZSgpXSxcclxuICAgICAgICAgICAgICAgICAgICByID0gbiAmJiBELmNhbGwoYi5hdHRySGFuZGxlLCB0LnRvTG93ZXJDYXNlKCkpID8gbihlLCB0LCAhRSkgOiB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PSByID8gciA6IGQuYXR0cmlidXRlcyB8fCAhRSA/IGUuZ2V0QXR0cmlidXRlKHQpIDogKHIgPSBlLmdldEF0dHJpYnV0ZU5vZGUodCkpICYmIHIuc3BlY2lmaWVkID8gci52YWx1ZSA6IG51bGxcclxuICAgICAgICAgICAgfSwgc2UuZXNjYXBlID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gKGUgKyBcIlwiKS5yZXBsYWNlKHJlLCBpZSkgfSwgc2UuZXJyb3IgPSBmdW5jdGlvbihlKSB7IHRocm93IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgZSkgfSwgc2UudW5pcXVlU29ydCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0LCBuID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgciA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAobCA9ICFkLmRldGVjdER1cGxpY2F0ZXMsIHUgPSAhZC5zb3J0U3RhYmxlICYmIGUuc2xpY2UoMCksIGUuc29ydChqKSwgbCkgeyB3aGlsZSAodCA9IGVbaSsrXSkgdCA9PT0gZVtpXSAmJiAociA9IG4ucHVzaChpKSk7IHdoaWxlIChyLS0pIGUuc3BsaWNlKG5bcl0sIDEpIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB1ID0gbnVsbCwgZVxyXG4gICAgICAgICAgICB9LCBvID0gc2UuZ2V0VGV4dCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0LCBuID0gXCJcIixcclxuICAgICAgICAgICAgICAgICAgICByID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBpID0gZS5ub2RlVHlwZTtcclxuICAgICAgICAgICAgICAgIGlmIChpKSB7IGlmICgxID09PSBpIHx8IDkgPT09IGkgfHwgMTEgPT09IGkpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUudGV4dENvbnRlbnQpIHJldHVybiBlLnRleHRDb250ZW50OyBmb3IgKGUgPSBlLmZpcnN0Q2hpbGQ7IGU7IGUgPSBlLm5leHRTaWJsaW5nKSBuICs9IG8oZSkgfSBlbHNlIGlmICgzID09PSBpIHx8IDQgPT09IGkpIHJldHVybiBlLm5vZGVWYWx1ZSB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodCA9IGVbcisrXSkgbiArPSBvKHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5cclxuICAgICAgICAgICAgfSwgKGIgPSBzZS5zZWxlY3RvcnMgPSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZUxlbmd0aDogNTAsXHJcbiAgICAgICAgICAgICAgICBjcmVhdGVQc2V1ZG86IGxlLFxyXG4gICAgICAgICAgICAgICAgbWF0Y2g6IEcsXHJcbiAgICAgICAgICAgICAgICBhdHRySGFuZGxlOiB7fSxcclxuICAgICAgICAgICAgICAgIGZpbmQ6IHt9LFxyXG4gICAgICAgICAgICAgICAgcmVsYXRpdmU6IHsgXCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6ICEwIH0sIFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSwgXCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogITAgfSwgXCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH0gfSxcclxuICAgICAgICAgICAgICAgIHByZUZpbHRlcjogeyBBVFRSOiBmdW5jdGlvbihlKSB7IHJldHVybiBlWzFdID0gZVsxXS5yZXBsYWNlKHRlLCBuZSksIGVbM10gPSAoZVszXSB8fCBlWzRdIHx8IGVbNV0gfHwgXCJcIikucmVwbGFjZSh0ZSwgbmUpLCBcIn49XCIgPT09IGVbMl0gJiYgKGVbM10gPSBcIiBcIiArIGVbM10gKyBcIiBcIiksIGUuc2xpY2UoMCwgNCkgfSwgQ0hJTEQ6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGVbMV0gPSBlWzFdLnRvTG93ZXJDYXNlKCksIFwibnRoXCIgPT09IGVbMV0uc2xpY2UoMCwgMykgPyAoZVszXSB8fCBzZS5lcnJvcihlWzBdKSwgZVs0XSA9ICsoZVs0XSA/IGVbNV0gKyAoZVs2XSB8fCAxKSA6IDIgKiAoXCJldmVuXCIgPT09IGVbM10gfHwgXCJvZGRcIiA9PT0gZVszXSkpLCBlWzVdID0gKyhlWzddICsgZVs4XSB8fCBcIm9kZFwiID09PSBlWzNdKSkgOiBlWzNdICYmIHNlLmVycm9yKGVbMF0pLCBlIH0sIFBTRVVETzogZnVuY3Rpb24oZSkgeyB2YXIgdCwgbiA9ICFlWzZdICYmIGVbMl07IHJldHVybiBHLkNISUxELnRlc3QoZVswXSkgPyBudWxsIDogKGVbM10gPyBlWzJdID0gZVs0XSB8fCBlWzVdIHx8IFwiXCIgOiBuICYmIFgudGVzdChuKSAmJiAodCA9IGgobiwgITApKSAmJiAodCA9IG4uaW5kZXhPZihcIilcIiwgbi5sZW5ndGggLSB0KSAtIG4ubGVuZ3RoKSAmJiAoZVswXSA9IGVbMF0uc2xpY2UoMCwgdCksIGVbMl0gPSBuLnNsaWNlKDAsIHQpKSwgZS5zbGljZSgwLCAzKSkgfSB9LFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgVEFHOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gZS5yZXBsYWNlKHRlLCBuZSkudG9Mb3dlckNhc2UoKTsgcmV0dXJuIFwiKlwiID09PSBlID8gZnVuY3Rpb24oKSB7IHJldHVybiAhMCB9IDogZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5ub2RlTmFtZSAmJiBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHQgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIENMQVNTOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gbVtlICsgXCIgXCJdOyByZXR1cm4gdCB8fCAodCA9IG5ldyBSZWdFeHAoXCIoXnxcIiArIE0gKyBcIilcIiArIGUgKyBcIihcIiArIE0gKyBcInwkKVwiKSkgJiYgbShlLCBmdW5jdGlvbihlKSB7IHJldHVybiB0LnRlc3QoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZS5jbGFzc05hbWUgJiYgZS5jbGFzc05hbWUgfHwgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5nZXRBdHRyaWJ1dGUgJiYgZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKSB9KSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIEFUVFI6IGZ1bmN0aW9uKG4sIHIsIGkpIHsgcmV0dXJuIGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBzZS5hdHRyKGUsIG4pOyByZXR1cm4gbnVsbCA9PSB0ID8gXCIhPVwiID09PSByIDogIXIgfHwgKHQgKz0gXCJcIiwgXCI9XCIgPT09IHIgPyB0ID09PSBpIDogXCIhPVwiID09PSByID8gdCAhPT0gaSA6IFwiXj1cIiA9PT0gciA/IGkgJiYgMCA9PT0gdC5pbmRleE9mKGkpIDogXCIqPVwiID09PSByID8gaSAmJiAtMSA8IHQuaW5kZXhPZihpKSA6IFwiJD1cIiA9PT0gciA/IGkgJiYgdC5zbGljZSgtaS5sZW5ndGgpID09PSBpIDogXCJ+PVwiID09PSByID8gLTEgPCAoXCIgXCIgKyB0LnJlcGxhY2UoQiwgXCIgXCIpICsgXCIgXCIpLmluZGV4T2YoaSkgOiBcInw9XCIgPT09IHIgJiYgKHQgPT09IGkgfHwgdC5zbGljZSgwLCBpLmxlbmd0aCArIDEpID09PSBpICsgXCItXCIpKSB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgQ0hJTEQ6IGZ1bmN0aW9uKGgsIGUsIHQsIGcsIHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBcIm50aFwiICE9PSBoLnNsaWNlKDAsIDMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IFwibGFzdFwiICE9PSBoLnNsaWNlKC00KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBcIm9mLXR5cGVcIiA9PT0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgPT09IGcgJiYgMCA9PT0gdiA/IGZ1bmN0aW9uKGUpIHsgcmV0dXJuICEhZS5wYXJlbnROb2RlIH0gOiBmdW5jdGlvbihlLCB0LCBuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciwgaSwgbywgYSwgcywgdSwgbCA9IHkgIT09IG0gPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBlLnBhcmVudE5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IHggJiYgZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAhbiAmJiAheCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gITE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChhID0gYVtsXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA/IGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZiA6IDEgPT09IGEubm9kZVR5cGUpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBsID0gXCJvbmx5XCIgPT09IGggJiYgIXUgJiYgXCJuZXh0U2libGluZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1ID0gW20gPyBjLmZpcnN0Q2hpbGQgOiBjLmxhc3RDaGlsZF0sIG0gJiYgcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gKHMgPSAociA9IChpID0gKG8gPSAoYSA9IGMpW1NdIHx8IChhW1NdID0ge30pKVthLnVuaXF1ZUlEXSB8fCAob1thLnVuaXF1ZUlEXSA9IHt9KSlbaF0gfHwgW10pWzBdID09PSBrICYmIHJbMV0pICYmIHJbMl0sIGEgPSBzICYmIGMuY2hpbGROb2Rlc1tzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGEgPSArK3MgJiYgYSAmJiBhW2xdIHx8IChkID0gcyA9IDApIHx8IHUucG9wKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMSA9PT0gYS5ub2RlVHlwZSAmJiArK2QgJiYgYSA9PT0gZSkgeyBpW2hdID0gW2ssIHMsIGRdOyBicmVhayB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwICYmIChkID0gcyA9IChyID0gKGkgPSAobyA9IChhID0gZSlbU10gfHwgKGFbU10gPSB7fSkpW2EudW5pcXVlSURdIHx8IChvW2EudW5pcXVlSURdID0ge30pKVtoXSB8fCBbXSlbMF0gPT09IGsgJiYgclsxXSksICExID09PSBkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYSA9ICsrcyAmJiBhICYmIGFbbF0gfHwgKGQgPSBzID0gMCkgfHwgdS5wb3AoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoeCA/IGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZiA6IDEgPT09IGEubm9kZVR5cGUpICYmICsrZCAmJiAocCAmJiAoKGkgPSAobyA9IGFbU10gfHwgKGFbU10gPSB7fSkpW2EudW5pcXVlSURdIHx8IChvW2EudW5pcXVlSURdID0ge30pKVtoXSA9IFtrLCBkXSksIGEgPT09IGUpKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGQgLT0gdikgPT09IGcgfHwgZCAlIGcgPT0gMCAmJiAwIDw9IGQgLyBnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFBTRVVETzogZnVuY3Rpb24oZSwgbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCwgYSA9IGIucHNldWRvc1tlXSB8fCBiLnNldEZpbHRlcnNbZS50b0xvd2VyQ2FzZSgpXSB8fCBzZS5lcnJvcihcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFbU10gPyBhKG8pIDogMSA8IGEubGVuZ3RoID8gKHQgPSBbZSwgZSwgXCJcIiwgb10sIGIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShlLnRvTG93ZXJDYXNlKCkpID8gbGUoZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4sIHIgPSBhKGUsIG8pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSByLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIGVbbiA9IFAoZSwgcltpXSldID0gISh0W25dID0gcltpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBmdW5jdGlvbihlKSB7IHJldHVybiBhKGUsIDAsIHQpIH0pIDogYVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwc2V1ZG9zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm90OiBsZShmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gZihlLnJlcGxhY2UoJCwgXCIkMVwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzW1NdID8gbGUoZnVuY3Rpb24oZSwgdCwgbiwgcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIG8gPSBzKGUsIG51bGwsIHIsIFtdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYS0tKShpID0gb1thXSkgJiYgKGVbYV0gPSAhKHRbYV0gPSBpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiByWzBdID0gZSwgcyhyLCBudWxsLCBuLCBpKSwgclswXSA9IG51bGwsICFpLnBvcCgpIH1cclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICBoYXM6IGxlKGZ1bmN0aW9uKHQpIHsgcmV0dXJuIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIDAgPCBzZSh0LCBlKS5sZW5ndGggfSB9KSxcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluczogbGUoZnVuY3Rpb24odCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCA9IHQucmVwbGFjZSh0ZSwgbmUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkgeyByZXR1cm4gLTEgPCAoZS50ZXh0Q29udGVudCB8fCBvKGUpKS5pbmRleE9mKHQpIH1cclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICBsYW5nOiBsZShmdW5jdGlvbihuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBWLnRlc3QobiB8fCBcIlwiKSB8fCBzZS5lcnJvcihcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbiksIG4gPSBuLnJlcGxhY2UodGUsIG5lKS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsgaWYgKHQgPSBFID8gZS5sYW5nIDogZS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlLmdldEF0dHJpYnV0ZShcImxhbmdcIikpIHJldHVybiAodCA9IHQudG9Mb3dlckNhc2UoKSkgPT09IG4gfHwgMCA9PT0gdC5pbmRleE9mKG4gKyBcIi1cIikgfSB3aGlsZSAoKGUgPSBlLnBhcmVudE5vZGUpICYmIDEgPT09IGUubm9kZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogZnVuY3Rpb24oZSkgeyB2YXIgdCA9IG4ubG9jYXRpb24gJiYgbi5sb2NhdGlvbi5oYXNoOyByZXR1cm4gdCAmJiB0LnNsaWNlKDEpID09PSBlLmlkIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogZnVuY3Rpb24oZSkgeyByZXR1cm4gZSA9PT0gYSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbihlKSB7IHJldHVybiBlID09PSBDLmFjdGl2ZUVsZW1lbnQgJiYgKCFDLmhhc0ZvY3VzIHx8IEMuaGFzRm9jdXMoKSkgJiYgISEoZS50eXBlIHx8IGUuaHJlZiB8fCB+ZS50YWJJbmRleCkgfSxcclxuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiBnZSghMSksXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGdlKCEwKSxcclxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOyByZXR1cm4gXCJpbnB1dFwiID09PSB0ICYmICEhZS5jaGVja2VkIHx8IFwib3B0aW9uXCIgPT09IHQgJiYgISFlLnNlbGVjdGVkIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUucGFyZW50Tm9kZSAmJiBlLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCwgITAgPT09IGUuc2VsZWN0ZWQgfSxcclxuICAgICAgICAgICAgICAgICAgICBlbXB0eTogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGUgPSBlLmZpcnN0Q2hpbGQ7IGU7IGUgPSBlLm5leHRTaWJsaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUubm9kZVR5cGUgPCA2KSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBmdW5jdGlvbihlKSB7IHJldHVybiAhYi5wc2V1ZG9zLmVtcHR5KGUpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiBmdW5jdGlvbihlKSB7IHJldHVybiBKLnRlc3QoZS5ub2RlTmFtZSkgfSxcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogZnVuY3Rpb24oZSkgeyByZXR1cm4gUS50ZXN0KGUubm9kZU5hbWUpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOyByZXR1cm4gXCJpbnB1dFwiID09PSB0ICYmIFwiYnV0dG9uXCIgPT09IGUudHlwZSB8fCBcImJ1dHRvblwiID09PSB0IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogZnVuY3Rpb24oZSkgeyB2YXIgdDsgcmV0dXJuIFwiaW5wdXRcIiA9PT0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICYmIFwidGV4dFwiID09PSBlLnR5cGUgJiYgKG51bGwgPT0gKHQgPSBlLmdldEF0dHJpYnV0ZShcInR5cGVcIikpIHx8IFwidGV4dFwiID09PSB0LnRvTG93ZXJDYXNlKCkpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3Q6IHZlKGZ1bmN0aW9uKCkgeyByZXR1cm4gWzBdIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3Q6IHZlKGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIFt0IC0gMV0gfSksXHJcbiAgICAgICAgICAgICAgICAgICAgZXE6IHZlKGZ1bmN0aW9uKGUsIHQsIG4pIHsgcmV0dXJuIFtuIDwgMCA/IG4gKyB0IDogbl0gfSksXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbjogdmUoZnVuY3Rpb24oZSwgdCkgeyBmb3IgKHZhciBuID0gMDsgbiA8IHQ7IG4gKz0gMikgZS5wdXNoKG4pOyByZXR1cm4gZSB9KSxcclxuICAgICAgICAgICAgICAgICAgICBvZGQ6IHZlKGZ1bmN0aW9uKGUsIHQpIHsgZm9yICh2YXIgbiA9IDE7IG4gPCB0OyBuICs9IDIpIGUucHVzaChuKTsgcmV0dXJuIGUgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgbHQ6IHZlKGZ1bmN0aW9uKGUsIHQsIG4pIHsgZm9yICh2YXIgciA9IG4gPCAwID8gbiArIHQgOiB0IDwgbiA/IHQgOiBuOyAwIDw9IC0tcjspIGUucHVzaChyKTsgcmV0dXJuIGUgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgZ3Q6IHZlKGZ1bmN0aW9uKGUsIHQsIG4pIHsgZm9yICh2YXIgciA9IG4gPCAwID8gbiArIHQgOiBuOyArK3IgPCB0OykgZS5wdXNoKHIpOyByZXR1cm4gZSB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5wc2V1ZG9zLm50aCA9IGIucHNldWRvcy5lcSwgeyByYWRpbzogITAsIGNoZWNrYm94OiAhMCwgZmlsZTogITAsIHBhc3N3b3JkOiAhMCwgaW1hZ2U6ICEwIH0pIGIucHNldWRvc1tlXSA9IGRlKGUpO1xyXG4gICAgICAgIGZvciAoZSBpbiB7IHN1Ym1pdDogITAsIHJlc2V0OiAhMCB9KSBiLnBzZXVkb3NbZV0gPSBoZShlKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbWUoKSB7fVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB4ZShlKSB7IGZvciAodmFyIHQgPSAwLCBuID0gZS5sZW5ndGgsIHIgPSBcIlwiOyB0IDwgbjsgdCsrKSByICs9IGVbdF0udmFsdWU7IHJldHVybiByIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYmUocywgZSwgdCkge1xyXG4gICAgICAgICAgICB2YXIgdSA9IGUuZGlyLFxyXG4gICAgICAgICAgICAgICAgbCA9IGUubmV4dCxcclxuICAgICAgICAgICAgICAgIGMgPSBsIHx8IHUsXHJcbiAgICAgICAgICAgICAgICBmID0gdCAmJiBcInBhcmVudE5vZGVcIiA9PT0gYyxcclxuICAgICAgICAgICAgICAgIHAgPSByKys7XHJcbiAgICAgICAgICAgIHJldHVybiBlLmZpcnN0ID8gZnVuY3Rpb24oZSwgdCwgbikge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGUgPSBlW3VdKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgxID09PSBlLm5vZGVUeXBlIHx8IGYpIHJldHVybiBzKGUsIHQsIG4pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICExXHJcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihlLCB0LCBuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgciwgaSwgbywgYSA9IFtrLCBwXTtcclxuICAgICAgICAgICAgICAgIGlmIChuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGUgPSBlW3VdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDEgPT09IGUubm9kZVR5cGUgfHwgZikgJiYgcyhlLCB0LCBuKSkgcmV0dXJuICEwXHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZSA9IGVbdV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgxID09PSBlLm5vZGVUeXBlIHx8IGYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9IChvID0gZVtTXSB8fCAoZVtTXSA9IHt9KSlbZS51bmlxdWVJRF0gfHwgKG9bZS51bmlxdWVJRF0gPSB7fSksIGwgJiYgbCA9PT0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSBlID0gZVt1XSB8fCBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7IGlmICgociA9IGlbY10pICYmIHJbMF0gPT09IGsgJiYgclsxXSA9PT0gcCkgcmV0dXJuIGFbMl0gPSByWzJdOyBpZiAoKGlbY10gPSBhKVsyXSA9IHMoZSwgdCwgbikpIHJldHVybiAhMCB9IHJldHVybiAhMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3ZShpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxIDwgaS5sZW5ndGggPyBmdW5jdGlvbihlLCB0LCBuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IGkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHItLSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlbcl0oZSwgdCwgbikpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhMFxyXG4gICAgICAgICAgICB9IDogaVswXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gVGUoZSwgdCwgbiwgciwgaSkgeyBmb3IgKHZhciBvLCBhID0gW10sIHMgPSAwLCB1ID0gZS5sZW5ndGgsIGwgPSBudWxsICE9IHQ7IHMgPCB1OyBzKyspKG8gPSBlW3NdKSAmJiAobiAmJiAhbihvLCByLCBpKSB8fCAoYS5wdXNoKG8pLCBsICYmIHQucHVzaChzKSkpOyByZXR1cm4gYSB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIENlKGQsIGgsIGcsIHYsIHksIGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHYgJiYgIXZbU10gJiYgKHYgPSBDZSh2KSksIHkgJiYgIXlbU10gJiYgKHkgPSBDZSh5LCBlKSksIGxlKGZ1bmN0aW9uKGUsIHQsIG4sIHIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpLCBvLCBhLCBzID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGwgPSB0Lmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBjID0gZSB8fCBmdW5jdGlvbihlLCB0LCBuKSB7IGZvciAodmFyIHIgPSAwLCBpID0gdC5sZW5ndGg7IHIgPCBpOyByKyspIHNlKGUsIHRbcl0sIG4pOyByZXR1cm4gbiB9KGggfHwgXCIqXCIsIG4ubm9kZVR5cGUgPyBbbl0gOiBuLCBbXSksXHJcbiAgICAgICAgICAgICAgICAgICAgZiA9ICFkIHx8ICFlICYmIGggPyBjIDogVGUoYywgcywgZCwgbiwgciksXHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IGcgPyB5IHx8IChlID8gZCA6IGwgfHwgdikgPyBbXSA6IHQgOiBmO1xyXG4gICAgICAgICAgICAgICAgaWYgKGcgJiYgZyhmLCBwLCBuLCByKSwgdikgeyBpID0gVGUocCwgdSksIHYoaSwgW10sIG4sIHIpLCBvID0gaS5sZW5ndGg7IHdoaWxlIChvLS0pKGEgPSBpW29dKSAmJiAocFt1W29dXSA9ICEoZlt1W29dXSA9IGEpKSB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5IHx8IGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBbXSwgbyA9IHAubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG8tLSkoYSA9IHBbb10pICYmIGkucHVzaChmW29dID0gYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KG51bGwsIHAgPSBbXSwgaSwgcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gcC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChvLS0pKGEgPSBwW29dKSAmJiAtMSA8IChpID0geSA/IFAoZSwgYSkgOiBzW29dKSAmJiAoZVtpXSA9ICEodFtpXSA9IGEpKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBwID0gVGUocCA9PT0gdCA/IHAuc3BsaWNlKGwsIHAubGVuZ3RoKSA6IHApLCB5ID8geShudWxsLCB0LCBwLCByKSA6IEguYXBwbHkodCwgcClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIEVlKGUpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSwgdCwgbiwgciA9IGUubGVuZ3RoLCBvID0gYi5yZWxhdGl2ZVtlWzBdLnR5cGVdLCBhID0gbyB8fCBiLnJlbGF0aXZlW1wiIFwiXSwgcyA9IG8gPyAxIDogMCwgdSA9IGJlKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUgPT09IGkgfSwgYSwgITApLCBsID0gYmUoZnVuY3Rpb24oZSkgeyByZXR1cm4gLTEgPCBQKGksIGUpIH0sIGEsICEwKSwgYyA9IFtmdW5jdGlvbihlLCB0LCBuKSB7IHZhciByID0gIW8gJiYgKG4gfHwgdCAhPT0gdykgfHwgKChpID0gdCkubm9kZVR5cGUgPyB1KGUsIHQsIG4pIDogbChlLCB0LCBuKSk7IHJldHVybiBpID0gbnVsbCwgciB9XTsgcyA8IHI7IHMrKylcclxuICAgICAgICAgICAgICAgIGlmICh0ID0gYi5yZWxhdGl2ZVtlW3NdLnR5cGVdKSBjID0gW2JlKHdlKGMpLCB0KV07XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHQgPSBiLmZpbHRlcltlW3NdLnR5cGVdLmFwcGx5KG51bGwsIGVbc10ubWF0Y2hlcykpW1NdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobiA9ICsrczsgbiA8IHI7IG4rKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiLnJlbGF0aXZlW2Vbbl0udHlwZV0pIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ2UoMSA8IHMgJiYgd2UoYyksIDEgPCBzICYmIHhlKGUuc2xpY2UoMCwgcyAtIDEpLmNvbmNhdCh7IHZhbHVlOiBcIiBcIiA9PT0gZVtzIC0gMl0udHlwZSA/IFwiKlwiIDogXCJcIiB9KSkucmVwbGFjZSgkLCBcIiQxXCIpLCB0LCBzIDwgbiAmJiBFZShlLnNsaWNlKHMsIG4pKSwgbiA8IHIgJiYgRWUoZSA9IGUuc2xpY2UobikpLCBuIDwgciAmJiB4ZShlKSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYy5wdXNoKHQpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB3ZShjKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWUucHJvdG90eXBlID0gYi5maWx0ZXJzID0gYi5wc2V1ZG9zLCBiLnNldEZpbHRlcnMgPSBuZXcgbWUsIGggPSBzZS50b2tlbml6ZSA9IGZ1bmN0aW9uKGUsIHQpIHtcclxuICAgICAgICAgICAgdmFyIG4sIHIsIGksIG8sIGEsIHMsIHUsIGwgPSB4W2UgKyBcIiBcIl07XHJcbiAgICAgICAgICAgIGlmIChsKSByZXR1cm4gdCA/IDAgOiBsLnNsaWNlKDApO1xyXG4gICAgICAgICAgICBhID0gZSwgcyA9IFtdLCB1ID0gYi5wcmVGaWx0ZXI7XHJcbiAgICAgICAgICAgIHdoaWxlIChhKSB7IGZvciAobyBpbiBuICYmICEociA9IF8uZXhlYyhhKSkgfHwgKHIgJiYgKGEgPSBhLnNsaWNlKHJbMF0ubGVuZ3RoKSB8fCBhKSwgcy5wdXNoKGkgPSBbXSkpLCBuID0gITEsIChyID0gei5leGVjKGEpKSAmJiAobiA9IHIuc2hpZnQoKSwgaS5wdXNoKHsgdmFsdWU6IG4sIHR5cGU6IHJbMF0ucmVwbGFjZSgkLCBcIiBcIikgfSksIGEgPSBhLnNsaWNlKG4ubGVuZ3RoKSksIGIuZmlsdGVyKSAhKHIgPSBHW29dLmV4ZWMoYSkpIHx8IHVbb10gJiYgIShyID0gdVtvXShyKSkgfHwgKG4gPSByLnNoaWZ0KCksIGkucHVzaCh7IHZhbHVlOiBuLCB0eXBlOiBvLCBtYXRjaGVzOiByIH0pLCBhID0gYS5zbGljZShuLmxlbmd0aCkpOyBpZiAoIW4pIGJyZWFrIH1cclxuICAgICAgICAgICAgcmV0dXJuIHQgPyBhLmxlbmd0aCA6IGEgPyBzZS5lcnJvcihlKSA6IHgoZSwgcykuc2xpY2UoMClcclxuICAgICAgICB9LCBmID0gc2UuY29tcGlsZSA9IGZ1bmN0aW9uKGUsIHQpIHtcclxuICAgICAgICAgICAgdmFyIG4sIHYsIHksIG0sIHgsIHIsIGkgPSBbXSxcclxuICAgICAgICAgICAgICAgIG8gPSBbXSxcclxuICAgICAgICAgICAgICAgIGEgPSBBW2UgKyBcIiBcIl07XHJcbiAgICAgICAgICAgIGlmICghYSkge1xyXG4gICAgICAgICAgICAgICAgdCB8fCAodCA9IGgoZSkpLCBuID0gdC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobi0tKShhID0gRWUodFtuXSkpW1NdID8gaS5wdXNoKGEpIDogby5wdXNoKGEpO1xyXG4gICAgICAgICAgICAgICAgKGEgPSBBKGUsICh2ID0gbywgbSA9IDAgPCAoeSA9IGkpLmxlbmd0aCwgeCA9IDAgPCB2Lmxlbmd0aCwgciA9IGZ1bmN0aW9uKGUsIHQsIG4sIHIsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbywgYSwgcywgdSA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBcIjBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGUgJiYgW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBlIHx8IHggJiYgYi5maW5kLlRBRyhcIipcIiwgaSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSBrICs9IG51bGwgPT0gcCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IC4xLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpICYmICh3ID0gdCA9PSBDIHx8IHQgfHwgaSk7IGwgIT09IGcgJiYgbnVsbCAhPSAobyA9IGRbbF0pOyBsKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggJiYgbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IDAsIHQgfHwgby5vd25lckRvY3VtZW50ID09IEMgfHwgKFQobyksIG4gPSAhRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocyA9IHZbYSsrXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocyhvLCB0IHx8IEMsIG4pKSB7IHIucHVzaChvKTsgYnJlYWsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSAmJiAoayA9IGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbSAmJiAoKG8gPSAhcyAmJiBvKSAmJiB1LS0sIGUgJiYgYy5wdXNoKG8pKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodSArPSBsLCBtICYmIGwgIT09IHUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzID0geVthKytdKSBzKGMsIGYsIHQsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPCB1KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsLS0pIGNbbF0gfHwgZltsXSB8fCAoZltsXSA9IHEuY2FsbChyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gVGUoZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBILmFwcGx5KHIsIGYpLCBpICYmICFlICYmIDAgPCBmLmxlbmd0aCAmJiAxIDwgdSArIHkubGVuZ3RoICYmIHNlLnVuaXF1ZVNvcnQocilcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgJiYgKGsgPSBoLCB3ID0gcCksIGNcclxuICAgICAgICAgICAgICAgIH0sIG0gPyBsZShyKSA6IHIpKSkuc2VsZWN0b3IgPSBlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICB9LCBnID0gc2Uuc2VsZWN0ID0gZnVuY3Rpb24oZSwgdCwgbiwgcikge1xyXG4gICAgICAgICAgICB2YXIgaSwgbywgYSwgcywgdSwgbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSAmJiBlLFxyXG4gICAgICAgICAgICAgICAgYyA9ICFyICYmIGgoZSA9IGwuc2VsZWN0b3IgfHwgZSk7XHJcbiAgICAgICAgICAgIGlmIChuID0gbiB8fCBbXSwgMSA9PT0gYy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmICgyIDwgKG8gPSBjWzBdID0gY1swXS5zbGljZSgwKSkubGVuZ3RoICYmIFwiSURcIiA9PT0gKGEgPSBvWzBdKS50eXBlICYmIDkgPT09IHQubm9kZVR5cGUgJiYgRSAmJiBiLnJlbGF0aXZlW29bMV0udHlwZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gKGIuZmluZC5JRChhLm1hdGNoZXNbMF0ucmVwbGFjZSh0ZSwgbmUpLCB0KSB8fCBbXSlbMF0pKSByZXR1cm4gbjtcclxuICAgICAgICAgICAgICAgICAgICBsICYmICh0ID0gdC5wYXJlbnROb2RlKSwgZSA9IGUuc2xpY2Uoby5zaGlmdCgpLnZhbHVlLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGkgPSBHLm5lZWRzQ29udGV4dC50ZXN0KGUpID8gMCA6IG8ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkgeyBpZiAoYSA9IG9baV0sIGIucmVsYXRpdmVbcyA9IGEudHlwZV0pIGJyZWFrOyBpZiAoKHUgPSBiLmZpbmRbc10pICYmIChyID0gdShhLm1hdGNoZXNbMF0ucmVwbGFjZSh0ZSwgbmUpLCBlZS50ZXN0KG9bMF0udHlwZSkgJiYgeWUodC5wYXJlbnROb2RlKSB8fCB0KSkpIHsgaWYgKG8uc3BsaWNlKGksIDEpLCAhKGUgPSByLmxlbmd0aCAmJiB4ZShvKSkpIHJldHVybiBILmFwcGx5KG4sIHIpLCBuOyBicmVhayB9IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKGwgfHwgZihlLCBjKSkociwgdCwgIUUsIG4sICF0IHx8IGVlLnRlc3QoZSkgJiYgeWUodC5wYXJlbnROb2RlKSB8fCB0KSwgblxyXG4gICAgICAgIH0sIGQuc29ydFN0YWJsZSA9IFMuc3BsaXQoXCJcIikuc29ydChqKS5qb2luKFwiXCIpID09PSBTLCBkLmRldGVjdER1cGxpY2F0ZXMgPSAhIWwsIFQoKSwgZC5zb3J0RGV0YWNoZWQgPSBjZShmdW5jdGlvbihlKSB7IHJldHVybiAxICYgZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihDLmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSkgfSksIGNlKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCIsIFwiI1wiID09PSBlLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSB9KSB8fCBmZShcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oZSwgdCwgbikgeyBpZiAoIW4pIHJldHVybiBlLmdldEF0dHJpYnV0ZSh0LCBcInR5cGVcIiA9PT0gdC50b0xvd2VyQ2FzZSgpID8gMSA6IDIpIH0pLCBkLmF0dHJpYnV0ZXMgJiYgY2UoZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCIsIGUuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBcIlwiKSwgXCJcIiA9PT0gZS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIH0pIHx8IGZlKFwidmFsdWVcIiwgZnVuY3Rpb24oZSwgdCwgbikgeyBpZiAoIW4gJiYgXCJpbnB1dFwiID09PSBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHJldHVybiBlLmRlZmF1bHRWYWx1ZSB9KSwgY2UoZnVuY3Rpb24oZSkgeyByZXR1cm4gbnVsbCA9PSBlLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpIH0pIHx8IGZlKFIsIGZ1bmN0aW9uKGUsIHQsIG4pIHsgdmFyIHI7IGlmICghbikgcmV0dXJuICEwID09PSBlW3RdID8gdC50b0xvd2VyQ2FzZSgpIDogKHIgPSBlLmdldEF0dHJpYnV0ZU5vZGUodCkpICYmIHIuc3BlY2lmaWVkID8gci52YWx1ZSA6IG51bGwgfSksIHNlXHJcbiAgICB9KEMpO1xyXG4gICAgUy5maW5kID0gZCwgUy5leHByID0gZC5zZWxlY3RvcnMsIFMuZXhwcltcIjpcIl0gPSBTLmV4cHIucHNldWRvcywgUy51bmlxdWVTb3J0ID0gUy51bmlxdWUgPSBkLnVuaXF1ZVNvcnQsIFMudGV4dCA9IGQuZ2V0VGV4dCwgUy5pc1hNTERvYyA9IGQuaXNYTUwsIFMuY29udGFpbnMgPSBkLmNvbnRhaW5zLCBTLmVzY2FwZVNlbGVjdG9yID0gZC5lc2NhcGU7XHJcbiAgICB2YXIgaCA9IGZ1bmN0aW9uKGUsIHQsIG4pIHtcclxuICAgICAgICAgICAgdmFyIHIgPSBbXSxcclxuICAgICAgICAgICAgICAgIGkgPSB2b2lkIDAgIT09IG47XHJcbiAgICAgICAgICAgIHdoaWxlICgoZSA9IGVbdF0pICYmIDkgIT09IGUubm9kZVR5cGUpXHJcbiAgICAgICAgICAgICAgICBpZiAoMSA9PT0gZS5ub2RlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpICYmIFMoZSkuaXMobikpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIHIucHVzaChlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gclxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgVCA9IGZ1bmN0aW9uKGUsIHQpIHsgZm9yICh2YXIgbiA9IFtdOyBlOyBlID0gZS5uZXh0U2libGluZykgMSA9PT0gZS5ub2RlVHlwZSAmJiBlICE9PSB0ICYmIG4ucHVzaChlKTsgcmV0dXJuIG4gfSxcclxuICAgICAgICBrID0gUy5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcclxuXHJcbiAgICBmdW5jdGlvbiBBKGUsIHQpIHsgcmV0dXJuIGUubm9kZU5hbWUgJiYgZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0LnRvTG93ZXJDYXNlKCkgfVxyXG4gICAgdmFyIE4gPSAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaTtcclxuXHJcbiAgICBmdW5jdGlvbiBqKGUsIG4sIHIpIHsgcmV0dXJuIG0obikgPyBTLmdyZXAoZSwgZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gISFuLmNhbGwoZSwgdCwgZSkgIT09IHIgfSkgOiBuLm5vZGVUeXBlID8gUy5ncmVwKGUsIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUgPT09IG4gIT09IHIgfSkgOiBcInN0cmluZ1wiICE9IHR5cGVvZiBuID8gUy5ncmVwKGUsIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIC0xIDwgaS5jYWxsKG4sIGUpICE9PSByIH0pIDogUy5maWx0ZXIobiwgZSwgcikgfVxyXG4gICAgUy5maWx0ZXIgPSBmdW5jdGlvbihlLCB0LCBuKSB7IHZhciByID0gdFswXTsgcmV0dXJuIG4gJiYgKGUgPSBcIjpub3QoXCIgKyBlICsgXCIpXCIpLCAxID09PSB0Lmxlbmd0aCAmJiAxID09PSByLm5vZGVUeXBlID8gUy5maW5kLm1hdGNoZXNTZWxlY3RvcihyLCBlKSA/IFtyXSA6IFtdIDogUy5maW5kLm1hdGNoZXMoZSwgUy5ncmVwKHQsIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIDEgPT09IGUubm9kZVR5cGUgfSkpIH0sIFMuZm4uZXh0ZW5kKHtcclxuICAgICAgICBmaW5kOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciB0LCBuLCByID0gdGhpcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBpID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUpIHJldHVybiB0aGlzLnB1c2hTdGFjayhTKGUpLmZpbHRlcihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodCA9IDA7IHQgPCByOyB0KyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFMuY29udGFpbnMoaVt0XSwgdGhpcykpIHJldHVybiAhMFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIGZvciAobiA9IHRoaXMucHVzaFN0YWNrKFtdKSwgdCA9IDA7IHQgPCByOyB0KyspIFMuZmluZChlLCBpW3RdLCBuKTtcclxuICAgICAgICAgICAgcmV0dXJuIDEgPCByID8gUy51bmlxdWVTb3J0KG4pIDogblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbihlKSB7IHJldHVybiB0aGlzLnB1c2hTdGFjayhqKHRoaXMsIGUgfHwgW10sICExKSkgfSxcclxuICAgICAgICBub3Q6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGoodGhpcywgZSB8fCBbXSwgITApKSB9LFxyXG4gICAgICAgIGlzOiBmdW5jdGlvbihlKSB7IHJldHVybiAhIWoodGhpcywgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiBrLnRlc3QoZSkgPyBTKGUpIDogZSB8fCBbXSwgITEpLmxlbmd0aCB9XHJcbiAgICB9KTtcclxuICAgIHZhciBELCBxID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC87XHJcbiAgICAoUy5mbi5pbml0ID0gZnVuY3Rpb24oZSwgdCwgbikge1xyXG4gICAgICAgIHZhciByLCBpO1xyXG4gICAgICAgIGlmICghZSkgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgaWYgKG4gPSBuIHx8IEQsIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcclxuICAgICAgICAgICAgaWYgKCEociA9IFwiPFwiID09PSBlWzBdICYmIFwiPlwiID09PSBlW2UubGVuZ3RoIC0gMV0gJiYgMyA8PSBlLmxlbmd0aCA/IFtudWxsLCBlLCBudWxsXSA6IHEuZXhlYyhlKSkgfHwgIXJbMV0gJiYgdCkgcmV0dXJuICF0IHx8IHQuanF1ZXJ5ID8gKHQgfHwgbikuZmluZChlKSA6IHRoaXMuY29uc3RydWN0b3IodCkuZmluZChlKTtcclxuICAgICAgICAgICAgaWYgKHJbMV0pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ID0gdCBpbnN0YW5jZW9mIFMgPyB0WzBdIDogdCwgUy5tZXJnZSh0aGlzLCBTLnBhcnNlSFRNTChyWzFdLCB0ICYmIHQubm9kZVR5cGUgPyB0Lm93bmVyRG9jdW1lbnQgfHwgdCA6IEUsICEwKSksIE4udGVzdChyWzFdKSAmJiBTLmlzUGxhaW5PYmplY3QodCkpXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyIGluIHQpIG0odGhpc1tyXSkgPyB0aGlzW3JdKHRbcl0pIDogdGhpcy5hdHRyKHIsIHRbcl0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKGkgPSBFLmdldEVsZW1lbnRCeUlkKHJbMl0pKSAmJiAodGhpc1swXSA9IGksIHRoaXMubGVuZ3RoID0gMSksIHRoaXNcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGUubm9kZVR5cGUgPyAodGhpc1swXSA9IGUsIHRoaXMubGVuZ3RoID0gMSwgdGhpcykgOiBtKGUpID8gdm9pZCAwICE9PSBuLnJlYWR5ID8gbi5yZWFkeShlKSA6IGUoUykgOiBTLm1ha2VBcnJheShlLCB0aGlzKVxyXG4gICAgfSkucHJvdG90eXBlID0gUy5mbiwgRCA9IFMoRSk7XHJcbiAgICB2YXIgTCA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxyXG4gICAgICAgIEggPSB7IGNoaWxkcmVuOiAhMCwgY29udGVudHM6ICEwLCBuZXh0OiAhMCwgcHJldjogITAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBPKGUsIHQpIHsgd2hpbGUgKChlID0gZVt0XSkgJiYgMSAhPT0gZS5ub2RlVHlwZSk7IHJldHVybiBlIH1cclxuICAgIFMuZm4uZXh0ZW5kKHtcclxuICAgICAgICBoYXM6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIHQgPSBTKGUsIHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgbiA9IHQubGVuZ3RoO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IG47IGUrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUy5jb250YWlucyh0aGlzLCB0W2VdKSkgcmV0dXJuICEwXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9zZXN0OiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgIHZhciBuLCByID0gMCxcclxuICAgICAgICAgICAgICAgIGkgPSB0aGlzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIG8gPSBbXSxcclxuICAgICAgICAgICAgICAgIGEgPSBcInN0cmluZ1wiICE9IHR5cGVvZiBlICYmIFMoZSk7XHJcbiAgICAgICAgICAgIGlmICghay50ZXN0KGUpKVxyXG4gICAgICAgICAgICAgICAgZm9yICg7IHIgPCBpOyByKyspXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChuID0gdGhpc1tyXTsgbiAmJiBuICE9PSB0OyBuID0gbi5wYXJlbnROb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobi5ub2RlVHlwZSA8IDExICYmIChhID8gLTEgPCBhLmluZGV4KG4pIDogMSA9PT0gbi5ub2RlVHlwZSAmJiBTLmZpbmQubWF0Y2hlc1NlbGVjdG9yKG4sIGUpKSkgeyBvLnB1c2gobik7IGJyZWFrIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKDEgPCBvLmxlbmd0aCA/IFMudW5pcXVlU29ydChvKSA6IG8pXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbmRleDogZnVuY3Rpb24oZSkgeyByZXR1cm4gZSA/IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBpLmNhbGwoUyhlKSwgdGhpc1swXSkgOiBpLmNhbGwodGhpcywgZS5qcXVlcnkgPyBlWzBdIDogZSkgOiB0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTEgfSxcclxuICAgICAgICBhZGQ6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHRoaXMucHVzaFN0YWNrKFMudW5pcXVlU29ydChTLm1lcmdlKHRoaXMuZ2V0KCksIFMoZSwgdCkpKSkgfSxcclxuICAgICAgICBhZGRCYWNrOiBmdW5jdGlvbihlKSB7IHJldHVybiB0aGlzLmFkZChudWxsID09IGUgPyB0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKGUpKSB9XHJcbiAgICB9KSwgUy5lYWNoKHsgcGFyZW50OiBmdW5jdGlvbihlKSB7IHZhciB0ID0gZS5wYXJlbnROb2RlOyByZXR1cm4gdCAmJiAxMSAhPT0gdC5ub2RlVHlwZSA/IHQgOiBudWxsIH0sIHBhcmVudHM6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGgoZSwgXCJwYXJlbnROb2RlXCIpIH0sIHBhcmVudHNVbnRpbDogZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gaChlLCBcInBhcmVudE5vZGVcIiwgbikgfSwgbmV4dDogZnVuY3Rpb24oZSkgeyByZXR1cm4gTyhlLCBcIm5leHRTaWJsaW5nXCIpIH0sIHByZXY6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIE8oZSwgXCJwcmV2aW91c1NpYmxpbmdcIikgfSwgbmV4dEFsbDogZnVuY3Rpb24oZSkgeyByZXR1cm4gaChlLCBcIm5leHRTaWJsaW5nXCIpIH0sIHByZXZBbGw6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGgoZSwgXCJwcmV2aW91c1NpYmxpbmdcIikgfSwgbmV4dFVudGlsOiBmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiBoKGUsIFwibmV4dFNpYmxpbmdcIiwgbikgfSwgcHJldlVudGlsOiBmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiBoKGUsIFwicHJldmlvdXNTaWJsaW5nXCIsIG4pIH0sIHNpYmxpbmdzOiBmdW5jdGlvbihlKSB7IHJldHVybiBUKChlLnBhcmVudE5vZGUgfHwge30pLmZpcnN0Q2hpbGQsIGUpIH0sIGNoaWxkcmVuOiBmdW5jdGlvbihlKSB7IHJldHVybiBUKGUuZmlyc3RDaGlsZCkgfSwgY29udGVudHM6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIG51bGwgIT0gZS5jb250ZW50RG9jdW1lbnQgJiYgcihlLmNvbnRlbnREb2N1bWVudCkgPyBlLmNvbnRlbnREb2N1bWVudCA6IChBKGUsIFwidGVtcGxhdGVcIikgJiYgKGUgPSBlLmNvbnRlbnQgfHwgZSksIFMubWVyZ2UoW10sIGUuY2hpbGROb2RlcykpIH0gfSwgZnVuY3Rpb24ociwgaSkgeyBTLmZuW3JdID0gZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiA9IFMubWFwKHRoaXMsIGksIGUpOyByZXR1cm4gXCJVbnRpbFwiICE9PSByLnNsaWNlKC01KSAmJiAodCA9IGUpLCB0ICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgKG4gPSBTLmZpbHRlcih0LCBuKSksIDEgPCB0aGlzLmxlbmd0aCAmJiAoSFtyXSB8fCBTLnVuaXF1ZVNvcnQobiksIEwudGVzdChyKSAmJiBuLnJldmVyc2UoKSksIHRoaXMucHVzaFN0YWNrKG4pIH0gfSk7XHJcbiAgICB2YXIgUCA9IC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZztcclxuXHJcbiAgICBmdW5jdGlvbiBSKGUpIHsgcmV0dXJuIGUgfVxyXG5cclxuICAgIGZ1bmN0aW9uIE0oZSkgeyB0aHJvdyBlIH1cclxuXHJcbiAgICBmdW5jdGlvbiBJKGUsIHQsIG4sIHIpIHsgdmFyIGk7IHRyeSB7IGUgJiYgbShpID0gZS5wcm9taXNlKSA/IGkuY2FsbChlKS5kb25lKHQpLmZhaWwobikgOiBlICYmIG0oaSA9IGUudGhlbikgPyBpLmNhbGwoZSwgdCwgbikgOiB0LmFwcGx5KHZvaWQgMCwgW2VdLnNsaWNlKHIpKSB9IGNhdGNoIChlKSB7IG4uYXBwbHkodm9pZCAwLCBbZV0pIH0gfVxyXG4gICAgUy5DYWxsYmFja3MgPSBmdW5jdGlvbihyKSB7XHJcbiAgICAgICAgdmFyIGUsIG47XHJcbiAgICAgICAgciA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIHIgPyAoZSA9IHIsIG4gPSB7fSwgUy5lYWNoKGUubWF0Y2goUCkgfHwgW10sIGZ1bmN0aW9uKGUsIHQpIHsgblt0XSA9ICEwIH0pLCBuKSA6IFMuZXh0ZW5kKHt9LCByKTtcclxuICAgICAgICB2YXIgaSwgdCwgbywgYSwgcyA9IFtdLFxyXG4gICAgICAgICAgICB1ID0gW10sXHJcbiAgICAgICAgICAgIGwgPSAtMSxcclxuICAgICAgICAgICAgYyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChhID0gYSB8fCByLm9uY2UsIG8gPSBpID0gITA7IHUubGVuZ3RoOyBsID0gLTEpIHsgdCA9IHUuc2hpZnQoKTsgd2hpbGUgKCsrbCA8IHMubGVuZ3RoKSAhMSA9PT0gc1tsXS5hcHBseSh0WzBdLCB0WzFdKSAmJiByLnN0b3BPbkZhbHNlICYmIChsID0gcy5sZW5ndGgsIHQgPSAhMSkgfVxyXG4gICAgICAgICAgICAgICAgci5tZW1vcnkgfHwgKHQgPSAhMSksIGkgPSAhMSwgYSAmJiAocyA9IHQgPyBbXSA6IFwiXCIpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGYgPSB7IGFkZDogZnVuY3Rpb24oKSB7IHJldHVybiBzICYmICh0ICYmICFpICYmIChsID0gcy5sZW5ndGggLSAxLCB1LnB1c2godCkpLCBmdW5jdGlvbiBuKGUpIHsgUy5lYWNoKGUsIGZ1bmN0aW9uKGUsIHQpIHsgbSh0KSA/IHIudW5pcXVlICYmIGYuaGFzKHQpIHx8IHMucHVzaCh0KSA6IHQgJiYgdC5sZW5ndGggJiYgXCJzdHJpbmdcIiAhPT0gdyh0KSAmJiBuKHQpIH0pIH0oYXJndW1lbnRzKSwgdCAmJiAhaSAmJiBjKCkpLCB0aGlzIH0sIHJlbW92ZTogZnVuY3Rpb24oKSB7IHJldHVybiBTLmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihlLCB0KSB7IHZhciBuOyB3aGlsZSAoLTEgPCAobiA9IFMuaW5BcnJheSh0LCBzLCBuKSkpIHMuc3BsaWNlKG4sIDEpLCBuIDw9IGwgJiYgbC0tIH0pLCB0aGlzIH0sIGhhczogZnVuY3Rpb24oZSkgeyByZXR1cm4gZSA/IC0xIDwgUy5pbkFycmF5KGUsIHMpIDogMCA8IHMubGVuZ3RoIH0sIGVtcHR5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHMgJiYgKHMgPSBbXSksIHRoaXMgfSwgZGlzYWJsZTogZnVuY3Rpb24oKSB7IHJldHVybiBhID0gdSA9IFtdLCBzID0gdCA9IFwiXCIsIHRoaXMgfSwgZGlzYWJsZWQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gIXMgfSwgbG9jazogZnVuY3Rpb24oKSB7IHJldHVybiBhID0gdSA9IFtdLCB0IHx8IGkgfHwgKHMgPSB0ID0gXCJcIiksIHRoaXMgfSwgbG9ja2VkOiBmdW5jdGlvbigpIHsgcmV0dXJuICEhYSB9LCBmaXJlV2l0aDogZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gYSB8fCAodCA9IFtlLCAodCA9IHQgfHwgW10pLnNsaWNlID8gdC5zbGljZSgpIDogdF0sIHUucHVzaCh0KSwgaSB8fCBjKCkpLCB0aGlzIH0sIGZpcmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZi5maXJlV2l0aCh0aGlzLCBhcmd1bWVudHMpLCB0aGlzIH0sIGZpcmVkOiBmdW5jdGlvbigpIHsgcmV0dXJuICEhbyB9IH07XHJcbiAgICAgICAgcmV0dXJuIGZcclxuICAgIH0sIFMuZXh0ZW5kKHtcclxuICAgICAgICBEZWZlcnJlZDogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgbyA9IFtcclxuICAgICAgICAgICAgICAgICAgICBbXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBTLkNhbGxiYWNrcyhcIm1lbW9yeVwiKSwgUy5DYWxsYmFja3MoXCJtZW1vcnlcIiksIDJdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtcInJlc29sdmVcIiwgXCJkb25lXCIsIFMuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFMuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIDAsIFwicmVzb2x2ZWRcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgW1wicmVqZWN0XCIsIFwiZmFpbFwiLCBTLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBTLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCAxLCBcInJlamVjdGVkXCJdXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgaSA9IFwicGVuZGluZ1wiLFxyXG4gICAgICAgICAgICAgICAgYSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogZnVuY3Rpb24oKSB7IHJldHVybiBpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHMuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSwgdGhpcyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24oZSkgeyByZXR1cm4gYS50aGVuKG51bGwsIGUpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGlwZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUy5EZWZlcnJlZChmdW5jdGlvbihyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTLmVhY2gobywgZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gbShpW3RbNF1dKSAmJiBpW3RbNF1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNbdFsxXV0oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gbiAmJiBuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgJiYgbShlLnByb21pc2UpID8gZS5wcm9taXNlKCkucHJvZ3Jlc3Moci5ub3RpZnkpLmRvbmUoci5yZXNvbHZlKS5mYWlsKHIucmVqZWN0KSA6IHJbdFswXSArIFwiV2l0aFwiXSh0aGlzLCBuID8gW2VdIDogYXJndW1lbnRzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgaSA9IG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkucHJvbWlzZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbih0LCBuLCByKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGwoaSwgbywgYSwgcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IGFyZ3VtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUsIHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgdSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGUgPSBhLmFwcGx5KG4sIHIpKSA9PT0gby5wcm9taXNlKCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGUgJiYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSAmJiBlLnRoZW4sIG0odCkgPyBzID8gdC5jYWxsKGUsIGwodSwgbywgUiwgcyksIGwodSwgbywgTSwgcykpIDogKHUrKywgdC5jYWxsKGUsIGwodSwgbywgUiwgcyksIGwodSwgbywgTSwgcyksIGwodSwgbywgUiwgby5ub3RpZnlXaXRoKSkpIDogKGEgIT09IFIgJiYgKG4gPSB2b2lkIDAsIHIgPSBbZV0pLCAocyB8fCBvLnJlc29sdmVXaXRoKShuLCByKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHMgPyBlIDogZnVuY3Rpb24oKSB7IHRyeSB7IGUoKSB9IGNhdGNoIChlKSB7IFMuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayAmJiBTLkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soZSwgdC5zdGFja1RyYWNlKSwgdSA8PSBpICsgMSAmJiAoYSAhPT0gTSAmJiAobiA9IHZvaWQgMCwgciA9IFtlXSksIG8ucmVqZWN0V2l0aChuLCByKSkgfSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPyB0KCkgOiAoUy5EZWZlcnJlZC5nZXRTdGFja0hvb2sgJiYgKHQuc3RhY2tUcmFjZSA9IFMuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCkpLCBDLnNldFRpbWVvdXQodCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFMuRGVmZXJyZWQoZnVuY3Rpb24oZSkgeyBvWzBdWzNdLmFkZChsKDAsIGUsIG0ocikgPyByIDogUiwgZS5ub3RpZnlXaXRoKSksIG9bMV1bM10uYWRkKGwoMCwgZSwgbSh0KSA/IHQgOiBSKSksIG9bMl1bM10uYWRkKGwoMCwgZSwgbShuKSA/IG4gOiBNKSkgfSkucHJvbWlzZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBmdW5jdGlvbihlKSB7IHJldHVybiBudWxsICE9IGUgPyBTLmV4dGVuZChlLCBhKSA6IGEgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHMgPSB7fTtcclxuICAgICAgICAgICAgcmV0dXJuIFMuZWFjaChvLCBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRbMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgciA9IHRbNV07XHJcbiAgICAgICAgICAgICAgICBhW3RbMV1dID0gbi5hZGQsIHIgJiYgbi5hZGQoZnVuY3Rpb24oKSB7IGkgPSByIH0sIG9bMyAtIGVdWzJdLmRpc2FibGUsIG9bMyAtIGVdWzNdLmRpc2FibGUsIG9bMF1bMl0ubG9jaywgb1swXVszXS5sb2NrKSwgbi5hZGQodFszXS5maXJlKSwgc1t0WzBdXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc1t0WzBdICsgXCJXaXRoXCJdKHRoaXMgPT09IHMgPyB2b2lkIDAgOiB0aGlzLCBhcmd1bWVudHMpLCB0aGlzIH0sIHNbdFswXSArIFwiV2l0aFwiXSA9IG4uZmlyZVdpdGhcclxuICAgICAgICAgICAgfSksIGEucHJvbWlzZShzKSwgZSAmJiBlLmNhbGwocywgcyksIHNcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdoZW46IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgdCA9IG4sXHJcbiAgICAgICAgICAgICAgICByID0gQXJyYXkodCksXHJcbiAgICAgICAgICAgICAgICBpID0gcy5jYWxsKGFyZ3VtZW50cyksXHJcbiAgICAgICAgICAgICAgICBvID0gUy5EZWZlcnJlZCgpLFxyXG4gICAgICAgICAgICAgICAgYSA9IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIGZ1bmN0aW9uKGUpIHsgclt0XSA9IHRoaXMsIGlbdF0gPSAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IHMuY2FsbChhcmd1bWVudHMpIDogZSwgLS1uIHx8IG8ucmVzb2x2ZVdpdGgociwgaSkgfSB9O1xyXG4gICAgICAgICAgICBpZiAobiA8PSAxICYmIChJKGUsIG8uZG9uZShhKHQpKS5yZXNvbHZlLCBvLnJlamVjdCwgIW4pLCBcInBlbmRpbmdcIiA9PT0gby5zdGF0ZSgpIHx8IG0oaVt0XSAmJiBpW3RdLnRoZW4pKSkgcmV0dXJuIG8udGhlbigpO1xyXG4gICAgICAgICAgICB3aGlsZSAodC0tKSBJKGlbdF0sIGEodCksIG8ucmVqZWN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIG8ucHJvbWlzZSgpXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgVyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xyXG4gICAgUy5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oZSwgdCkgeyBDLmNvbnNvbGUgJiYgQy5jb25zb2xlLndhcm4gJiYgZSAmJiBXLnRlc3QoZS5uYW1lKSAmJiBDLmNvbnNvbGUud2FybihcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZS5tZXNzYWdlLCBlLnN0YWNrLCB0KSB9LCBTLnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oZSkgeyBDLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRocm93IGUgfSkgfTtcclxuICAgIHZhciBGID0gUy5EZWZlcnJlZCgpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEIoKSB7IEUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgQiksIEMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgQiksIFMucmVhZHkoKSB9XHJcbiAgICBTLmZuLnJlYWR5ID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gRi50aGVuKGUpW1wiY2F0Y2hcIl0oZnVuY3Rpb24oZSkgeyBTLnJlYWR5RXhjZXB0aW9uKGUpIH0pLCB0aGlzIH0sIFMuZXh0ZW5kKHtcclxuICAgICAgICBpc1JlYWR5OiAhMSxcclxuICAgICAgICByZWFkeVdhaXQ6IDEsXHJcbiAgICAgICAgcmVhZHk6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgKCEwID09PSBlID8gLS1TLnJlYWR5V2FpdCA6IFMuaXNSZWFkeSkgfHwgKFMuaXNSZWFkeSA9ICEwKSAhPT0gZSAmJiAwIDwgLS1TLnJlYWR5V2FpdCB8fCBGLnJlc29sdmVXaXRoKEUsIFtTXSlcclxuICAgICAgICB9XHJcbiAgICB9KSwgUy5yZWFkeS50aGVuID0gRi50aGVuLCBcImNvbXBsZXRlXCIgPT09IEUucmVhZHlTdGF0ZSB8fCBcImxvYWRpbmdcIiAhPT0gRS5yZWFkeVN0YXRlICYmICFFLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCA/IEMuc2V0VGltZW91dChTLnJlYWR5KSA6IChFLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIEIpLCBDLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIEIpKTtcclxuICAgIHZhciAkID0gZnVuY3Rpb24oZSwgdCwgbiwgciwgaSwgbywgYSkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IDAsXHJcbiAgICAgICAgICAgICAgICB1ID0gZS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBsID0gbnVsbCA9PSBuO1xyXG4gICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdyhuKSlcclxuICAgICAgICAgICAgICAgIGZvciAocyBpbiBpID0gITAsIG4pICQoZSwgdCwgcywgbltzXSwgITAsIG8sIGEpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2b2lkIDAgIT09IHIgJiYgKGkgPSAhMCwgbShyKSB8fCAoYSA9ICEwKSwgbCAmJiAoYSA/ICh0LmNhbGwoZSwgciksIHQgPSBudWxsKSA6IChsID0gdCwgdCA9IGZ1bmN0aW9uKGUsIHQsIG4pIHsgcmV0dXJuIGwuY2FsbChTKGUpLCBuKSB9KSksIHQpKVxyXG4gICAgICAgICAgICAgICAgZm9yICg7IHMgPCB1OyBzKyspIHQoZVtzXSwgbiwgYSA/IHIgOiByLmNhbGwoZVtzXSwgcywgdChlW3NdLCBuKSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gaSA/IGUgOiBsID8gdC5jYWxsKGUpIDogdSA/IHQoZVswXSwgbikgOiBvXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfID0gL14tbXMtLyxcclxuICAgICAgICB6ID0gLy0oW2Etel0pL2c7XHJcblxyXG4gICAgZnVuY3Rpb24gVShlLCB0KSB7IHJldHVybiB0LnRvVXBwZXJDYXNlKCkgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFgoZSkgeyByZXR1cm4gZS5yZXBsYWNlKF8sIFwibXMtXCIpLnJlcGxhY2UoeiwgVSkgfVxyXG4gICAgdmFyIFYgPSBmdW5jdGlvbihlKSB7IHJldHVybiAxID09PSBlLm5vZGVUeXBlIHx8IDkgPT09IGUubm9kZVR5cGUgfHwgIStlLm5vZGVUeXBlIH07XHJcblxyXG4gICAgZnVuY3Rpb24gRygpIHsgdGhpcy5leHBhbmRvID0gUy5leHBhbmRvICsgRy51aWQrKyB9XHJcbiAgICBHLnVpZCA9IDEsIEcucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNhY2hlOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gZVt0aGlzLmV4cGFuZG9dOyByZXR1cm4gdCB8fCAodCA9IHt9LCBWKGUpICYmIChlLm5vZGVUeXBlID8gZVt0aGlzLmV4cGFuZG9dID0gdCA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0aGlzLmV4cGFuZG8sIHsgdmFsdWU6IHQsIGNvbmZpZ3VyYWJsZTogITAgfSkpKSwgdCB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24oZSwgdCwgbikge1xyXG4gICAgICAgICAgICB2YXIgciwgaSA9IHRoaXMuY2FjaGUoZSk7XHJcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0KSBpW1godCldID0gbjtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZm9yIChyIGluIHQpIGlbWChyKV0gPSB0W3JdO1xyXG4gICAgICAgICAgICByZXR1cm4gaVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihlLCB0KSB7IHJldHVybiB2b2lkIDAgPT09IHQgPyB0aGlzLmNhY2hlKGUpIDogZVt0aGlzLmV4cGFuZG9dICYmIGVbdGhpcy5leHBhbmRvXVtYKHQpXSB9LFxyXG4gICAgICAgIGFjY2VzczogZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gdm9pZCAwID09PSB0IHx8IHQgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCAmJiB2b2lkIDAgPT09IG4gPyB0aGlzLmdldChlLCB0KSA6ICh0aGlzLnNldChlLCB0LCBuKSwgdm9pZCAwICE9PSBuID8gbiA6IHQpIH0sXHJcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihlLCB0KSB7IHZhciBuLCByID0gZVt0aGlzLmV4cGFuZG9dOyBpZiAodm9pZCAwICE9PSByKSB7IGlmICh2b2lkIDAgIT09IHQpIHsgbiA9ICh0ID0gQXJyYXkuaXNBcnJheSh0KSA/IHQubWFwKFgpIDogKHQgPSBYKHQpKSBpbiByID8gW3RdIDogdC5tYXRjaChQKSB8fCBbXSkubGVuZ3RoOyB3aGlsZSAobi0tKSBkZWxldGUgclt0W25dXSB9KHZvaWQgMCA9PT0gdCB8fCBTLmlzRW1wdHlPYmplY3QocikpICYmIChlLm5vZGVUeXBlID8gZVt0aGlzLmV4cGFuZG9dID0gdm9pZCAwIDogZGVsZXRlIGVbdGhpcy5leHBhbmRvXSkgfSB9LFxyXG4gICAgICAgIGhhc0RhdGE6IGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBlW3RoaXMuZXhwYW5kb107IHJldHVybiB2b2lkIDAgIT09IHQgJiYgIVMuaXNFbXB0eU9iamVjdCh0KSB9XHJcbiAgICB9O1xyXG4gICAgdmFyIFkgPSBuZXcgRyxcclxuICAgICAgICBRID0gbmV3IEcsXHJcbiAgICAgICAgSiA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcclxuICAgICAgICBLID0gL1tBLVpdL2c7XHJcblxyXG4gICAgZnVuY3Rpb24gWihlLCB0LCBuKSB7XHJcbiAgICAgICAgdmFyIHIsIGk7XHJcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gbiAmJiAxID09PSBlLm5vZGVUeXBlKVxyXG4gICAgICAgICAgICBpZiAociA9IFwiZGF0YS1cIiArIHQucmVwbGFjZShLLCBcIi0kJlwiKS50b0xvd2VyQ2FzZSgpLCBcInN0cmluZ1wiID09IHR5cGVvZihuID0gZS5nZXRBdHRyaWJ1dGUocikpKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkgeyBuID0gXCJ0cnVlXCIgPT09IChpID0gbikgfHwgXCJmYWxzZVwiICE9PSBpICYmIChcIm51bGxcIiA9PT0gaSA/IG51bGwgOiBpID09PSAraSArIFwiXCIgPyAraSA6IEoudGVzdChpKSA/IEpTT04ucGFyc2UoaSkgOiBpKSB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgICAgICAgICAgUS5zZXQoZSwgdCwgbilcclxuICAgICAgICAgICAgfSBlbHNlIG4gPSB2b2lkIDA7XHJcbiAgICAgICAgcmV0dXJuIG5cclxuICAgIH1cclxuICAgIFMuZXh0ZW5kKHsgaGFzRGF0YTogZnVuY3Rpb24oZSkgeyByZXR1cm4gUS5oYXNEYXRhKGUpIHx8IFkuaGFzRGF0YShlKSB9LCBkYXRhOiBmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiBRLmFjY2VzcyhlLCB0LCBuKSB9LCByZW1vdmVEYXRhOiBmdW5jdGlvbihlLCB0KSB7IFEucmVtb3ZlKGUsIHQpIH0sIF9kYXRhOiBmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiBZLmFjY2VzcyhlLCB0LCBuKSB9LCBfcmVtb3ZlRGF0YTogZnVuY3Rpb24oZSwgdCkgeyBZLnJlbW92ZShlLCB0KSB9IH0pLCBTLmZuLmV4dGVuZCh7XHJcbiAgICAgICAgZGF0YTogZnVuY3Rpb24obiwgZSkge1xyXG4gICAgICAgICAgICB2YXIgdCwgciwgaSwgbyA9IHRoaXNbMF0sXHJcbiAgICAgICAgICAgICAgICBhID0gbyAmJiBvLmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IG4pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCAmJiAoaSA9IFEuZ2V0KG8pLCAxID09PSBvLm5vZGVUeXBlICYmICFZLmdldChvLCBcImhhc0RhdGFBdHRyc1wiKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ID0gYS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHQtLSkgYVt0XSAmJiAwID09PSAociA9IGFbdF0ubmFtZSkuaW5kZXhPZihcImRhdGEtXCIpICYmIChyID0gWChyLnNsaWNlKDUpKSwgWihvLCByLCBpW3JdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgWS5zZXQobywgXCJoYXNEYXRhQXR0cnNcIiwgITApXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiID09IHR5cGVvZiBuID8gdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyBRLnNldCh0aGlzLCBuKSB9KSA6ICQodGhpcywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAobyAmJiB2b2lkIDAgPT09IGUpIHJldHVybiB2b2lkIDAgIT09ICh0ID0gUS5nZXQobywgbikpID8gdCA6IHZvaWQgMCAhPT0gKHQgPSBaKG8sIG4pKSA/IHQgOiB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IFEuc2V0KHRoaXMsIG4sIGUpIH0pXHJcbiAgICAgICAgICAgIH0sIG51bGwsIGUsIDEgPCBhcmd1bWVudHMubGVuZ3RoLCBudWxsLCAhMClcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgUS5yZW1vdmUodGhpcywgZSkgfSkgfVxyXG4gICAgfSksIFMuZXh0ZW5kKHtcclxuICAgICAgICBxdWV1ZTogZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgcjsgaWYgKGUpIHJldHVybiB0ID0gKHQgfHwgXCJmeFwiKSArIFwicXVldWVcIiwgciA9IFkuZ2V0KGUsIHQpLCBuICYmICghciB8fCBBcnJheS5pc0FycmF5KG4pID8gciA9IFkuYWNjZXNzKGUsIHQsIFMubWFrZUFycmF5KG4pKSA6IHIucHVzaChuKSksIHIgfHwgW10gfSxcclxuICAgICAgICBkZXF1ZXVlOiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgIHQgPSB0IHx8IFwiZnhcIjtcclxuICAgICAgICAgICAgdmFyIG4gPSBTLnF1ZXVlKGUsIHQpLFxyXG4gICAgICAgICAgICAgICAgciA9IG4ubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgaSA9IG4uc2hpZnQoKSxcclxuICAgICAgICAgICAgICAgIG8gPSBTLl9xdWV1ZUhvb2tzKGUsIHQpO1xyXG4gICAgICAgICAgICBcImlucHJvZ3Jlc3NcIiA9PT0gaSAmJiAoaSA9IG4uc2hpZnQoKSwgci0tKSwgaSAmJiAoXCJmeFwiID09PSB0ICYmIG4udW5zaGlmdChcImlucHJvZ3Jlc3NcIiksIGRlbGV0ZSBvLnN0b3AsIGkuY2FsbChlLCBmdW5jdGlvbigpIHsgUy5kZXF1ZXVlKGUsIHQpIH0sIG8pKSwgIXIgJiYgbyAmJiBvLmVtcHR5LmZpcmUoKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3F1ZXVlSG9va3M6IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4gPSB0ICsgXCJxdWV1ZUhvb2tzXCI7IHJldHVybiBZLmdldChlLCBuKSB8fCBZLmFjY2VzcyhlLCBuLCB7IGVtcHR5OiBTLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpIHsgWS5yZW1vdmUoZSwgW3QgKyBcInF1ZXVlXCIsIG5dKSB9KSB9KSB9XHJcbiAgICB9KSwgUy5mbi5leHRlbmQoe1xyXG4gICAgICAgIHF1ZXVlOiBmdW5jdGlvbih0LCBuKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gMjtcclxuICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgIT0gdHlwZW9mIHQgJiYgKG4gPSB0LCB0ID0gXCJmeFwiLCBlLS0pLCBhcmd1bWVudHMubGVuZ3RoIDwgZSA/IFMucXVldWUodGhpc1swXSwgdCkgOiB2b2lkIDAgPT09IG4gPyB0aGlzIDogdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBTLnF1ZXVlKHRoaXMsIHQsIG4pO1xyXG4gICAgICAgICAgICAgICAgUy5fcXVldWVIb29rcyh0aGlzLCB0KSwgXCJmeFwiID09PSB0ICYmIFwiaW5wcm9ncmVzc1wiICE9PSBlWzBdICYmIFMuZGVxdWV1ZSh0aGlzLCB0KVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVxdWV1ZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyBTLmRlcXVldWUodGhpcywgZSkgfSkgfSxcclxuICAgICAgICBjbGVhclF1ZXVlOiBmdW5jdGlvbihlKSB7IHJldHVybiB0aGlzLnF1ZXVlKGUgfHwgXCJmeFwiLCBbXSkgfSxcclxuICAgICAgICBwcm9taXNlOiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgIHZhciBuLCByID0gMSxcclxuICAgICAgICAgICAgICAgIGkgPSBTLkRlZmVycmVkKCksXHJcbiAgICAgICAgICAgICAgICBvID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGEgPSB0aGlzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHMgPSBmdW5jdGlvbigpIHstLXIgfHwgaS5yZXNvbHZlV2l0aChvLCBbb10pIH07XHJcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgJiYgKHQgPSBlLCBlID0gdm9pZCAwKSwgZSA9IGUgfHwgXCJmeFwiO1xyXG4gICAgICAgICAgICB3aGlsZSAoYS0tKShuID0gWS5nZXQob1thXSwgZSArIFwicXVldWVIb29rc1wiKSkgJiYgbi5lbXB0eSAmJiAocisrLCBuLmVtcHR5LmFkZChzKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzKCksIGkucHJvbWlzZSh0KVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIGVlID0gL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8uc291cmNlLFxyXG4gICAgICAgIHRlID0gbmV3IFJlZ0V4cChcIl4oPzooWystXSk9fCkoXCIgKyBlZSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIpLFxyXG4gICAgICAgIG5lID0gW1wiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCJdLFxyXG4gICAgICAgIHJlID0gRS5kb2N1bWVudEVsZW1lbnQsXHJcbiAgICAgICAgaWUgPSBmdW5jdGlvbihlKSB7IHJldHVybiBTLmNvbnRhaW5zKGUub3duZXJEb2N1bWVudCwgZSkgfSxcclxuICAgICAgICBvZSA9IHsgY29tcG9zZWQ6ICEwIH07XHJcbiAgICByZS5nZXRSb290Tm9kZSAmJiAoaWUgPSBmdW5jdGlvbihlKSB7IHJldHVybiBTLmNvbnRhaW5zKGUub3duZXJEb2N1bWVudCwgZSkgfHwgZS5nZXRSb290Tm9kZShvZSkgPT09IGUub3duZXJEb2N1bWVudCB9KTtcclxuICAgIHZhciBhZSA9IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIFwibm9uZVwiID09PSAoZSA9IHQgfHwgZSkuc3R5bGUuZGlzcGxheSB8fCBcIlwiID09PSBlLnN0eWxlLmRpc3BsYXkgJiYgaWUoZSkgJiYgXCJub25lXCIgPT09IFMuY3NzKGUsIFwiZGlzcGxheVwiKSB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHNlKGUsIHQsIG4sIHIpIHtcclxuICAgICAgICB2YXIgaSwgbywgYSA9IDIwLFxyXG4gICAgICAgICAgICBzID0gciA/IGZ1bmN0aW9uKCkgeyByZXR1cm4gci5jdXIoKSB9IDogZnVuY3Rpb24oKSB7IHJldHVybiBTLmNzcyhlLCB0LCBcIlwiKSB9LFxyXG4gICAgICAgICAgICB1ID0gcygpLFxyXG4gICAgICAgICAgICBsID0gbiAmJiBuWzNdIHx8IChTLmNzc051bWJlclt0XSA/IFwiXCIgOiBcInB4XCIpLFxyXG4gICAgICAgICAgICBjID0gZS5ub2RlVHlwZSAmJiAoUy5jc3NOdW1iZXJbdF0gfHwgXCJweFwiICE9PSBsICYmICt1KSAmJiB0ZS5leGVjKFMuY3NzKGUsIHQpKTtcclxuICAgICAgICBpZiAoYyAmJiBjWzNdICE9PSBsKSB7XHJcbiAgICAgICAgICAgIHUgLz0gMiwgbCA9IGwgfHwgY1szXSwgYyA9ICt1IHx8IDE7XHJcbiAgICAgICAgICAgIHdoaWxlIChhLS0pIFMuc3R5bGUoZSwgdCwgYyArIGwpLCAoMSAtIG8pICogKDEgLSAobyA9IHMoKSAvIHUgfHwgLjUpKSA8PSAwICYmIChhID0gMCksIGMgLz0gbztcclxuICAgICAgICAgICAgYyAqPSAyLCBTLnN0eWxlKGUsIHQsIGMgKyBsKSwgbiA9IG4gfHwgW11cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG4gJiYgKGMgPSArYyB8fCArdSB8fCAwLCBpID0gblsxXSA/IGMgKyAoblsxXSArIDEpICogblsyXSA6ICtuWzJdLCByICYmIChyLnVuaXQgPSBsLCByLnN0YXJ0ID0gYywgci5lbmQgPSBpKSksIGlcclxuICAgIH1cclxuICAgIHZhciB1ZSA9IHt9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGxlKGUsIHQpIHsgZm9yICh2YXIgbiwgciwgaSwgbywgYSwgcywgdSwgbCA9IFtdLCBjID0gMCwgZiA9IGUubGVuZ3RoOyBjIDwgZjsgYysrKShyID0gZVtjXSkuc3R5bGUgJiYgKG4gPSByLnN0eWxlLmRpc3BsYXksIHQgPyAoXCJub25lXCIgPT09IG4gJiYgKGxbY10gPSBZLmdldChyLCBcImRpc3BsYXlcIikgfHwgbnVsbCwgbFtjXSB8fCAoci5zdHlsZS5kaXNwbGF5ID0gXCJcIikpLCBcIlwiID09PSByLnN0eWxlLmRpc3BsYXkgJiYgYWUocikgJiYgKGxbY10gPSAodSA9IGEgPSBvID0gdm9pZCAwLCBhID0gKGkgPSByKS5vd25lckRvY3VtZW50LCBzID0gaS5ub2RlTmFtZSwgKHUgPSB1ZVtzXSkgfHwgKG8gPSBhLmJvZHkuYXBwZW5kQ2hpbGQoYS5jcmVhdGVFbGVtZW50KHMpKSwgdSA9IFMuY3NzKG8sIFwiZGlzcGxheVwiKSwgby5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG8pLCBcIm5vbmVcIiA9PT0gdSAmJiAodSA9IFwiYmxvY2tcIiksIHVlW3NdID0gdSkpKSkgOiBcIm5vbmVcIiAhPT0gbiAmJiAobFtjXSA9IFwibm9uZVwiLCBZLnNldChyLCBcImRpc3BsYXlcIiwgbikpKTsgZm9yIChjID0gMDsgYyA8IGY7IGMrKykgbnVsbCAhPSBsW2NdICYmIChlW2NdLnN0eWxlLmRpc3BsYXkgPSBsW2NdKTsgcmV0dXJuIGUgfVxyXG4gICAgUy5mbi5leHRlbmQoeyBzaG93OiBmdW5jdGlvbigpIHsgcmV0dXJuIGxlKHRoaXMsICEwKSB9LCBoaWRlOiBmdW5jdGlvbigpIHsgcmV0dXJuIGxlKHRoaXMpIH0sIHRvZ2dsZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gXCJib29sZWFuXCIgPT0gdHlwZW9mIGUgPyBlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKSA6IHRoaXMuZWFjaChmdW5jdGlvbigpIHsgYWUodGhpcykgPyBTKHRoaXMpLnNob3coKSA6IFModGhpcykuaGlkZSgpIH0pIH0gfSk7XHJcbiAgICB2YXIgY2UsIGZlLCBwZSA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pLFxyXG4gICAgICAgIGRlID0gLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pLFxyXG4gICAgICAgIGhlID0gL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaTtcclxuICAgIGNlID0gRS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkuYXBwZW5kQ2hpbGQoRS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSwgKGZlID0gRS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikpLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJyYWRpb1wiKSwgZmUuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiksIGZlLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJ0XCIpLCBjZS5hcHBlbmRDaGlsZChmZSksIHkuY2hlY2tDbG9uZSA9IGNlLmNsb25lTm9kZSghMCkuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuY2hlY2tlZCwgY2UuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCIsIHkubm9DbG9uZUNoZWNrZWQgPSAhIWNlLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZSwgY2UuaW5uZXJIVE1MID0gXCI8b3B0aW9uPjwvb3B0aW9uPlwiLCB5Lm9wdGlvbiA9ICEhY2UubGFzdENoaWxkO1xyXG4gICAgdmFyIGdlID0geyB0aGVhZDogWzEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCJdLCBjb2w6IFsyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiXSwgdHI6IFsyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiXSwgdGQ6IFszLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiXSwgX2RlZmF1bHQ6IFswLCBcIlwiLCBcIlwiXSB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHZlKGUsIHQpIHsgdmFyIG47IHJldHVybiBuID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUodCB8fCBcIipcIikgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBlLnF1ZXJ5U2VsZWN0b3JBbGwgPyBlLnF1ZXJ5U2VsZWN0b3JBbGwodCB8fCBcIipcIikgOiBbXSwgdm9pZCAwID09PSB0IHx8IHQgJiYgQShlLCB0KSA/IFMubWVyZ2UoW2VdLCBuKSA6IG4gfVxyXG5cclxuICAgIGZ1bmN0aW9uIHllKGUsIHQpIHsgZm9yICh2YXIgbiA9IDAsIHIgPSBlLmxlbmd0aDsgbiA8IHI7IG4rKykgWS5zZXQoZVtuXSwgXCJnbG9iYWxFdmFsXCIsICF0IHx8IFkuZ2V0KHRbbl0sIFwiZ2xvYmFsRXZhbFwiKSkgfVxyXG4gICAgZ2UudGJvZHkgPSBnZS50Zm9vdCA9IGdlLmNvbGdyb3VwID0gZ2UuY2FwdGlvbiA9IGdlLnRoZWFkLCBnZS50aCA9IGdlLnRkLCB5Lm9wdGlvbiB8fCAoZ2Uub3B0Z3JvdXAgPSBnZS5vcHRpb24gPSBbMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCJdKTtcclxuICAgIHZhciBtZSA9IC88fCYjP1xcdys7LztcclxuXHJcbiAgICBmdW5jdGlvbiB4ZShlLCB0LCBuLCByLCBpKSB7XHJcbiAgICAgICAgZm9yICh2YXIgbywgYSwgcywgdSwgbCwgYywgZiA9IHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBwID0gW10sIGQgPSAwLCBoID0gZS5sZW5ndGg7IGQgPCBoOyBkKyspXHJcbiAgICAgICAgICAgIGlmICgobyA9IGVbZF0pIHx8IDAgPT09IG8pXHJcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdyhvKSkgUy5tZXJnZShwLCBvLm5vZGVUeXBlID8gW29dIDogbyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZS50ZXN0KG8pKSB7XHJcbiAgICAgICAgICAgIGEgPSBhIHx8IGYuYXBwZW5kQ2hpbGQodC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSwgcyA9IChkZS5leGVjKG8pIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKSwgdSA9IGdlW3NdIHx8IGdlLl9kZWZhdWx0LCBhLmlubmVySFRNTCA9IHVbMV0gKyBTLmh0bWxQcmVmaWx0ZXIobykgKyB1WzJdLCBjID0gdVswXTtcclxuICAgICAgICAgICAgd2hpbGUgKGMtLSkgYSA9IGEubGFzdENoaWxkO1xyXG4gICAgICAgICAgICBTLm1lcmdlKHAsIGEuY2hpbGROb2RlcyksIChhID0gZi5maXJzdENoaWxkKS50ZXh0Q29udGVudCA9IFwiXCJcclxuICAgICAgICB9IGVsc2UgcC5wdXNoKHQuY3JlYXRlVGV4dE5vZGUobykpO1xyXG4gICAgICAgIGYudGV4dENvbnRlbnQgPSBcIlwiLCBkID0gMDtcclxuICAgICAgICB3aGlsZSAobyA9IHBbZCsrXSlcclxuICAgICAgICAgICAgaWYgKHIgJiYgLTEgPCBTLmluQXJyYXkobywgcikpIGkgJiYgaS5wdXNoKG8pO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChsID0gaWUobyksIGEgPSB2ZShmLmFwcGVuZENoaWxkKG8pLCBcInNjcmlwdFwiKSwgbCAmJiB5ZShhKSwgbikgeyBjID0gMDsgd2hpbGUgKG8gPSBhW2MrK10pIGhlLnRlc3Qoby50eXBlIHx8IFwiXCIpICYmIG4ucHVzaChvKSB9XHJcbiAgICAgICAgcmV0dXJuIGZcclxuICAgIH1cclxuICAgIHZhciBiZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XHJcblxyXG4gICAgZnVuY3Rpb24gd2UoKSB7IHJldHVybiAhMCB9XHJcblxyXG4gICAgZnVuY3Rpb24gVGUoKSB7IHJldHVybiAhMSB9XHJcblxyXG4gICAgZnVuY3Rpb24gQ2UoZSwgdCkgeyByZXR1cm4gZSA9PT0gZnVuY3Rpb24oKSB7IHRyeSB7IHJldHVybiBFLmFjdGl2ZUVsZW1lbnQgfSBjYXRjaCAoZSkge30gfSgpID09IChcImZvY3VzXCIgPT09IHQpIH1cclxuXHJcbiAgICBmdW5jdGlvbiBFZShlLCB0LCBuLCByLCBpLCBvKSB7XHJcbiAgICAgICAgdmFyIGEsIHM7XHJcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIHQpIHsgZm9yIChzIGluIFwic3RyaW5nXCIgIT0gdHlwZW9mIG4gJiYgKHIgPSByIHx8IG4sIG4gPSB2b2lkIDApLCB0KSBFZShlLCBzLCBuLCByLCB0W3NdLCBvKTsgcmV0dXJuIGUgfVxyXG4gICAgICAgIGlmIChudWxsID09IHIgJiYgbnVsbCA9PSBpID8gKGkgPSBuLCByID0gbiA9IHZvaWQgMCkgOiBudWxsID09IGkgJiYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIG4gPyAoaSA9IHIsIHIgPSB2b2lkIDApIDogKGkgPSByLCByID0gbiwgbiA9IHZvaWQgMCkpLCAhMSA9PT0gaSkgaSA9IFRlO1xyXG4gICAgICAgIGVsc2UgaWYgKCFpKSByZXR1cm4gZTtcclxuICAgICAgICByZXR1cm4gMSA9PT0gbyAmJiAoYSA9IGksIChpID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gUygpLm9mZihlKSwgYS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH0pLmd1aWQgPSBhLmd1aWQgfHwgKGEuZ3VpZCA9IFMuZ3VpZCsrKSksIGUuZWFjaChmdW5jdGlvbigpIHsgUy5ldmVudC5hZGQodGhpcywgdCwgaSwgciwgbikgfSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBTZShlLCBpLCBvKSB7XHJcbiAgICAgICAgbyA/IChZLnNldChlLCBpLCAhMSksIFMuZXZlbnQuYWRkKGUsIGksIHtcclxuICAgICAgICAgICAgbmFtZXNwYWNlOiAhMSxcclxuICAgICAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQsIG4sIHIgPSBZLmdldCh0aGlzLCBpKTtcclxuICAgICAgICAgICAgICAgIGlmICgxICYgZS5pc1RyaWdnZXIgJiYgdGhpc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmxlbmd0aCkoUy5ldmVudC5zcGVjaWFsW2ldIHx8IHt9KS5kZWxlZ2F0ZVR5cGUgJiYgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyID0gcy5jYWxsKGFyZ3VtZW50cyksIFkuc2V0KHRoaXMsIGksIHIpLCB0ID0gbyh0aGlzLCBpKSwgdGhpc1tpXSgpLCByICE9PSAobiA9IFkuZ2V0KHRoaXMsIGkpKSB8fCB0ID8gWS5zZXQodGhpcywgaSwgITEpIDogbiA9IHt9LCByICE9PSBuKSByZXR1cm4gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgZS5wcmV2ZW50RGVmYXVsdCgpLCBuICYmIG4udmFsdWVcclxuICAgICAgICAgICAgICAgIH0gZWxzZSByLmxlbmd0aCAmJiAoWS5zZXQodGhpcywgaSwgeyB2YWx1ZTogUy5ldmVudC50cmlnZ2VyKFMuZXh0ZW5kKHJbMF0sIFMuRXZlbnQucHJvdG90eXBlKSwgci5zbGljZSgxKSwgdGhpcykgfSksIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSkgOiB2b2lkIDAgPT09IFkuZ2V0KGUsIGkpICYmIFMuZXZlbnQuYWRkKGUsIGksIHdlKVxyXG4gICAgfVxyXG4gICAgUy5ldmVudCA9IHtcclxuICAgICAgICBnbG9iYWw6IHt9LFxyXG4gICAgICAgIGFkZDogZnVuY3Rpb24odCwgZSwgbiwgciwgaSkgeyB2YXIgbywgYSwgcywgdSwgbCwgYywgZiwgcCwgZCwgaCwgZywgdiA9IFkuZ2V0KHQpOyBpZiAoVih0KSkgeyBuLmhhbmRsZXIgJiYgKG4gPSAobyA9IG4pLmhhbmRsZXIsIGkgPSBvLnNlbGVjdG9yKSwgaSAmJiBTLmZpbmQubWF0Y2hlc1NlbGVjdG9yKHJlLCBpKSwgbi5ndWlkIHx8IChuLmd1aWQgPSBTLmd1aWQrKyksICh1ID0gdi5ldmVudHMpIHx8ICh1ID0gdi5ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSwgKGEgPSB2LmhhbmRsZSkgfHwgKGEgPSB2LmhhbmRsZSA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFMgJiYgUy5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/IFMuZXZlbnQuZGlzcGF0Y2guYXBwbHkodCwgYXJndW1lbnRzKSA6IHZvaWQgMCB9KSwgbCA9IChlID0gKGUgfHwgXCJcIikubWF0Y2goUCkgfHwgW1wiXCJdKS5sZW5ndGg7IHdoaWxlIChsLS0pIGQgPSBnID0gKHMgPSBiZS5leGVjKGVbbF0pIHx8IFtdKVsxXSwgaCA9IChzWzJdIHx8IFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksIGQgJiYgKGYgPSBTLmV2ZW50LnNwZWNpYWxbZF0gfHwge30sIGQgPSAoaSA/IGYuZGVsZWdhdGVUeXBlIDogZi5iaW5kVHlwZSkgfHwgZCwgZiA9IFMuZXZlbnQuc3BlY2lhbFtkXSB8fCB7fSwgYyA9IFMuZXh0ZW5kKHsgdHlwZTogZCwgb3JpZ1R5cGU6IGcsIGRhdGE6IHIsIGhhbmRsZXI6IG4sIGd1aWQ6IG4uZ3VpZCwgc2VsZWN0b3I6IGksIG5lZWRzQ29udGV4dDogaSAmJiBTLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoaSksIG5hbWVzcGFjZTogaC5qb2luKFwiLlwiKSB9LCBvKSwgKHAgPSB1W2RdKSB8fCAoKHAgPSB1W2RdID0gW10pLmRlbGVnYXRlQ291bnQgPSAwLCBmLnNldHVwICYmICExICE9PSBmLnNldHVwLmNhbGwodCwgciwgaCwgYSkgfHwgdC5hZGRFdmVudExpc3RlbmVyICYmIHQuYWRkRXZlbnRMaXN0ZW5lcihkLCBhKSksIGYuYWRkICYmIChmLmFkZC5jYWxsKHQsIGMpLCBjLmhhbmRsZXIuZ3VpZCB8fCAoYy5oYW5kbGVyLmd1aWQgPSBuLmd1aWQpKSwgaSA/IHAuc3BsaWNlKHAuZGVsZWdhdGVDb3VudCsrLCAwLCBjKSA6IHAucHVzaChjKSwgUy5ldmVudC5nbG9iYWxbZF0gPSAhMCkgfSB9LFxyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oZSwgdCwgbiwgciwgaSkge1xyXG4gICAgICAgICAgICB2YXIgbywgYSwgcywgdSwgbCwgYywgZiwgcCwgZCwgaCwgZywgdiA9IFkuaGFzRGF0YShlKSAmJiBZLmdldChlKTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgKHUgPSB2LmV2ZW50cykpIHtcclxuICAgICAgICAgICAgICAgIGwgPSAodCA9ICh0IHx8IFwiXCIpLm1hdGNoKFApIHx8IFtcIlwiXSkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGwtLSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZCA9IGcgPSAocyA9IGJlLmV4ZWModFtsXSkgfHwgW10pWzFdLCBoID0gKHNbMl0gfHwgXCJcIikuc3BsaXQoXCIuXCIpLnNvcnQoKSwgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gUy5ldmVudC5zcGVjaWFsW2RdIHx8IHt9LCBwID0gdVtkID0gKHIgPyBmLmRlbGVnYXRlVHlwZSA6IGYuYmluZFR5cGUpIHx8IGRdIHx8IFtdLCBzID0gc1syXSAmJiBuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIgKyBoLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIpLCBhID0gbyA9IHAubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoby0tKSBjID0gcFtvXSwgIWkgJiYgZyAhPT0gYy5vcmlnVHlwZSB8fCBuICYmIG4uZ3VpZCAhPT0gYy5ndWlkIHx8IHMgJiYgIXMudGVzdChjLm5hbWVzcGFjZSkgfHwgciAmJiByICE9PSBjLnNlbGVjdG9yICYmIChcIioqXCIgIT09IHIgfHwgIWMuc2VsZWN0b3IpIHx8IChwLnNwbGljZShvLCAxKSwgYy5zZWxlY3RvciAmJiBwLmRlbGVnYXRlQ291bnQtLSwgZi5yZW1vdmUgJiYgZi5yZW1vdmUuY2FsbChlLCBjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgJiYgIXAubGVuZ3RoICYmIChmLnRlYXJkb3duICYmICExICE9PSBmLnRlYXJkb3duLmNhbGwoZSwgaCwgdi5oYW5kbGUpIHx8IFMucmVtb3ZlRXZlbnQoZSwgZCwgdi5oYW5kbGUpLCBkZWxldGUgdVtkXSlcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChkIGluIHUpIFMuZXZlbnQucmVtb3ZlKGUsIGQgKyB0W2xdLCBuLCByLCAhMCk7XHJcbiAgICAgICAgICAgICAgICBTLmlzRW1wdHlPYmplY3QodSkgJiYgWS5yZW1vdmUoZSwgXCJoYW5kbGUgZXZlbnRzXCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciB0LCBuLCByLCBpLCBvLCBhLCBzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgdSA9IFMuZXZlbnQuZml4KGUpLFxyXG4gICAgICAgICAgICAgICAgbCA9IChZLmdldCh0aGlzLCBcImV2ZW50c1wiKSB8fCBPYmplY3QuY3JlYXRlKG51bGwpKVt1LnR5cGVdIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgYyA9IFMuZXZlbnQuc3BlY2lhbFt1LnR5cGVdIHx8IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHNbMF0gPSB1LCB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykgc1t0XSA9IGFyZ3VtZW50c1t0XTtcclxuICAgICAgICAgICAgaWYgKHUuZGVsZWdhdGVUYXJnZXQgPSB0aGlzLCAhYy5wcmVEaXNwYXRjaCB8fCAhMSAhPT0gYy5wcmVEaXNwYXRjaC5jYWxsKHRoaXMsIHUpKSB7IGEgPSBTLmV2ZW50LmhhbmRsZXJzLmNhbGwodGhpcywgdSwgbCksIHQgPSAwOyB3aGlsZSAoKGkgPSBhW3QrK10pICYmICF1LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHsgdS5jdXJyZW50VGFyZ2V0ID0gaS5lbGVtLCBuID0gMDsgd2hpbGUgKChvID0gaS5oYW5kbGVyc1tuKytdKSAmJiAhdS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSB1LnJuYW1lc3BhY2UgJiYgITEgIT09IG8ubmFtZXNwYWNlICYmICF1LnJuYW1lc3BhY2UudGVzdChvLm5hbWVzcGFjZSkgfHwgKHUuaGFuZGxlT2JqID0gbywgdS5kYXRhID0gby5kYXRhLCB2b2lkIDAgIT09IChyID0gKChTLmV2ZW50LnNwZWNpYWxbby5vcmlnVHlwZV0gfHwge30pLmhhbmRsZSB8fCBvLmhhbmRsZXIpLmFwcGx5KGkuZWxlbSwgcykpICYmICExID09PSAodS5yZXN1bHQgPSByKSAmJiAodS5wcmV2ZW50RGVmYXVsdCgpLCB1LnN0b3BQcm9wYWdhdGlvbigpKSkgfSByZXR1cm4gYy5wb3N0RGlzcGF0Y2ggJiYgYy5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLCB1KSwgdS5yZXN1bHQgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFuZGxlcnM6IGZ1bmN0aW9uKGUsIHQpIHtcclxuICAgICAgICAgICAgdmFyIG4sIHIsIGksIG8sIGEsIHMgPSBbXSxcclxuICAgICAgICAgICAgICAgIHUgPSB0LmRlbGVnYXRlQ291bnQsXHJcbiAgICAgICAgICAgICAgICBsID0gZS50YXJnZXQ7XHJcbiAgICAgICAgICAgIGlmICh1ICYmIGwubm9kZVR5cGUgJiYgIShcImNsaWNrXCIgPT09IGUudHlwZSAmJiAxIDw9IGUuYnV0dG9uKSlcclxuICAgICAgICAgICAgICAgIGZvciAoOyBsICE9PSB0aGlzOyBsID0gbC5wYXJlbnROb2RlIHx8IHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKDEgPT09IGwubm9kZVR5cGUgJiYgKFwiY2xpY2tcIiAhPT0gZS50eXBlIHx8ICEwICE9PSBsLmRpc2FibGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG8gPSBbXSwgYSA9IHt9LCBuID0gMDsgbiA8IHU7IG4rKykgdm9pZCAwID09PSBhW2kgPSAociA9IHRbbl0pLnNlbGVjdG9yICsgXCIgXCJdICYmIChhW2ldID0gci5uZWVkc0NvbnRleHQgPyAtMSA8IFMoaSwgdGhpcykuaW5kZXgobCkgOiBTLmZpbmQoaSwgdGhpcywgbnVsbCwgW2xdKS5sZW5ndGgpLCBhW2ldICYmIG8ucHVzaChyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5sZW5ndGggJiYgcy5wdXNoKHsgZWxlbTogbCwgaGFuZGxlcnM6IG8gfSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBsID0gdGhpcywgdSA8IHQubGVuZ3RoICYmIHMucHVzaCh7IGVsZW06IGwsIGhhbmRsZXJzOiB0LnNsaWNlKHUpIH0pLCBzXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRQcm9wOiBmdW5jdGlvbih0LCBlKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTLkV2ZW50LnByb3RvdHlwZSwgdCwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgZ2V0OiBtKGUpID8gZnVuY3Rpb24oKSB7IGlmICh0aGlzLm9yaWdpbmFsRXZlbnQpIHJldHVybiBlKHRoaXMub3JpZ2luYWxFdmVudCkgfSA6IGZ1bmN0aW9uKCkgeyBpZiAodGhpcy5vcmlnaW5hbEV2ZW50KSByZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50W3RdIH0sIHNldDogZnVuY3Rpb24oZSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgdCwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogZSB9KSB9IH0pIH0sXHJcbiAgICAgICAgZml4OiBmdW5jdGlvbihlKSB7IHJldHVybiBlW1MuZXhwYW5kb10gPyBlIDogbmV3IFMuRXZlbnQoZSkgfSxcclxuICAgICAgICBzcGVjaWFsOiB7IGxvYWQ6IHsgbm9CdWJibGU6ICEwIH0sIGNsaWNrOiB7IHNldHVwOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gdGhpcyB8fCBlOyByZXR1cm4gcGUudGVzdCh0LnR5cGUpICYmIHQuY2xpY2sgJiYgQSh0LCBcImlucHV0XCIpICYmIFNlKHQsIFwiY2xpY2tcIiwgd2UpLCAhMSB9LCB0cmlnZ2VyOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gdGhpcyB8fCBlOyByZXR1cm4gcGUudGVzdCh0LnR5cGUpICYmIHQuY2xpY2sgJiYgQSh0LCBcImlucHV0XCIpICYmIFNlKHQsIFwiY2xpY2tcIiksICEwIH0sIF9kZWZhdWx0OiBmdW5jdGlvbihlKSB7IHZhciB0ID0gZS50YXJnZXQ7IHJldHVybiBwZS50ZXN0KHQudHlwZSkgJiYgdC5jbGljayAmJiBBKHQsIFwiaW5wdXRcIikgJiYgWS5nZXQodCwgXCJjbGlja1wiKSB8fCBBKHQsIFwiYVwiKSB9IH0sIGJlZm9yZXVubG9hZDogeyBwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKGUpIHsgdm9pZCAwICE9PSBlLnJlc3VsdCAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgKGUub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGUucmVzdWx0KSB9IH0gfVxyXG4gICAgfSwgUy5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKGUsIHQsIG4pIHsgZS5yZW1vdmVFdmVudExpc3RlbmVyICYmIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBuKSB9LCBTLkV2ZW50ID0gZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTLkV2ZW50KSkgcmV0dXJuIG5ldyBTLkV2ZW50KGUsIHQpO1xyXG4gICAgICAgIGUgJiYgZS50eXBlID8gKHRoaXMub3JpZ2luYWxFdmVudCA9IGUsIHRoaXMudHlwZSA9IGUudHlwZSwgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlLmRlZmF1bHRQcmV2ZW50ZWQgfHwgdm9pZCAwID09PSBlLmRlZmF1bHRQcmV2ZW50ZWQgJiYgITEgPT09IGUucmV0dXJuVmFsdWUgPyB3ZSA6IFRlLCB0aGlzLnRhcmdldCA9IGUudGFyZ2V0ICYmIDMgPT09IGUudGFyZ2V0Lm5vZGVUeXBlID8gZS50YXJnZXQucGFyZW50Tm9kZSA6IGUudGFyZ2V0LCB0aGlzLmN1cnJlbnRUYXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQsIHRoaXMucmVsYXRlZFRhcmdldCA9IGUucmVsYXRlZFRhcmdldCkgOiB0aGlzLnR5cGUgPSBlLCB0ICYmIFMuZXh0ZW5kKHRoaXMsIHQpLCB0aGlzLnRpbWVTdGFtcCA9IGUgJiYgZS50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKSwgdGhpc1tTLmV4cGFuZG9dID0gITBcclxuICAgIH0sIFMuRXZlbnQucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBTLkV2ZW50LFxyXG4gICAgICAgIGlzRGVmYXVsdFByZXZlbnRlZDogVGUsXHJcbiAgICAgICAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IFRlLFxyXG4gICAgICAgIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiBUZSxcclxuICAgICAgICBpc1NpbXVsYXRlZDogITEsXHJcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcclxuICAgICAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSB3ZSwgZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCAmJiBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xyXG4gICAgICAgICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gd2UsIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgJiYgZS5zdG9wUHJvcGFnYXRpb24oKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB3ZSwgZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCB0aGlzLnN0b3BQcm9wYWdhdGlvbigpXHJcbiAgICAgICAgfVxyXG4gICAgfSwgUy5lYWNoKHsgYWx0S2V5OiAhMCwgYnViYmxlczogITAsIGNhbmNlbGFibGU6ICEwLCBjaGFuZ2VkVG91Y2hlczogITAsIGN0cmxLZXk6ICEwLCBkZXRhaWw6ICEwLCBldmVudFBoYXNlOiAhMCwgbWV0YUtleTogITAsIHBhZ2VYOiAhMCwgcGFnZVk6ICEwLCBzaGlmdEtleTogITAsIHZpZXc6ICEwLCBcImNoYXJcIjogITAsIGNvZGU6ICEwLCBjaGFyQ29kZTogITAsIGtleTogITAsIGtleUNvZGU6ICEwLCBidXR0b246ICEwLCBidXR0b25zOiAhMCwgY2xpZW50WDogITAsIGNsaWVudFk6ICEwLCBvZmZzZXRYOiAhMCwgb2Zmc2V0WTogITAsIHBvaW50ZXJJZDogITAsIHBvaW50ZXJUeXBlOiAhMCwgc2NyZWVuWDogITAsIHNjcmVlblk6ICEwLCB0YXJnZXRUb3VjaGVzOiAhMCwgdG9FbGVtZW50OiAhMCwgdG91Y2hlczogITAsIHdoaWNoOiAhMCB9LCBTLmV2ZW50LmFkZFByb3ApLCBTLmVhY2goeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbihlLCB0KSB7IFMuZXZlbnQuc3BlY2lhbFtlXSA9IHsgc2V0dXA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gU2UodGhpcywgZSwgQ2UpLCAhMSB9LCB0cmlnZ2VyOiBmdW5jdGlvbigpIHsgcmV0dXJuIFNlKHRoaXMsIGUpLCAhMCB9LCBfZGVmYXVsdDogZnVuY3Rpb24oKSB7IHJldHVybiAhMCB9LCBkZWxlZ2F0ZVR5cGU6IHQgfSB9KSwgUy5lYWNoKHsgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIiwgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLCBwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIiwgcG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIiB9LCBmdW5jdGlvbihlLCBpKSB7XHJcbiAgICAgICAgUy5ldmVudC5zcGVjaWFsW2VdID0ge1xyXG4gICAgICAgICAgICBkZWxlZ2F0ZVR5cGU6IGksXHJcbiAgICAgICAgICAgIGJpbmRUeXBlOiBpLFxyXG4gICAgICAgICAgICBoYW5kbGU6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0LCBuID0gZS5yZWxhdGVkVGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBlLmhhbmRsZU9iajtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuICYmIChuID09PSB0aGlzIHx8IFMuY29udGFpbnModGhpcywgbikpIHx8IChlLnR5cGUgPSByLm9yaWdUeXBlLCB0ID0gci5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGUudHlwZSA9IGkpLCB0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KSwgUy5mbi5leHRlbmQoeyBvbjogZnVuY3Rpb24oZSwgdCwgbiwgcikgeyByZXR1cm4gRWUodGhpcywgZSwgdCwgbiwgcikgfSwgb25lOiBmdW5jdGlvbihlLCB0LCBuLCByKSB7IHJldHVybiBFZSh0aGlzLCBlLCB0LCBuLCByLCAxKSB9LCBvZmY6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgdmFyIHIsIGk7IGlmIChlICYmIGUucHJldmVudERlZmF1bHQgJiYgZS5oYW5kbGVPYmopIHJldHVybiByID0gZS5oYW5kbGVPYmosIFMoZS5kZWxlZ2F0ZVRhcmdldCkub2ZmKHIubmFtZXNwYWNlID8gci5vcmlnVHlwZSArIFwiLlwiICsgci5uYW1lc3BhY2UgOiByLm9yaWdUeXBlLCByLnNlbGVjdG9yLCByLmhhbmRsZXIpLCB0aGlzOyBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSkgeyBmb3IgKGkgaW4gZSkgdGhpcy5vZmYoaSwgdCwgZVtpXSk7IHJldHVybiB0aGlzIH0gcmV0dXJuICExICE9PSB0ICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCB8fCAobiA9IHQsIHQgPSB2b2lkIDApLCAhMSA9PT0gbiAmJiAobiA9IFRlKSwgdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyBTLmV2ZW50LnJlbW92ZSh0aGlzLCBlLCBuLCB0KSB9KSB9IH0pO1xyXG4gICAgdmFyIGtlID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXHJcbiAgICAgICAgQWUgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxyXG4gICAgICAgIE5lID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xyXG5cclxuICAgIGZ1bmN0aW9uIGplKGUsIHQpIHsgcmV0dXJuIEEoZSwgXCJ0YWJsZVwiKSAmJiBBKDExICE9PSB0Lm5vZGVUeXBlID8gdCA6IHQuZmlyc3RDaGlsZCwgXCJ0clwiKSAmJiBTKGUpLmNoaWxkcmVuKFwidGJvZHlcIilbMF0gfHwgZSB9XHJcblxyXG4gICAgZnVuY3Rpb24gRGUoZSkgeyByZXR1cm4gZS50eXBlID0gKG51bGwgIT09IGUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgKyBcIi9cIiArIGUudHlwZSwgZSB9XHJcblxyXG4gICAgZnVuY3Rpb24gcWUoZSkgeyByZXR1cm4gXCJ0cnVlL1wiID09PSAoZS50eXBlIHx8IFwiXCIpLnNsaWNlKDAsIDUpID8gZS50eXBlID0gZS50eXBlLnNsaWNlKDUpIDogZS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpLCBlIH1cclxuXHJcbiAgICBmdW5jdGlvbiBMZShlLCB0KSB7XHJcbiAgICAgICAgdmFyIG4sIHIsIGksIG8sIGEsIHM7XHJcbiAgICAgICAgaWYgKDEgPT09IHQubm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKFkuaGFzRGF0YShlKSAmJiAocyA9IFkuZ2V0KGUpLmV2ZW50cykpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gWS5yZW1vdmUodCwgXCJoYW5kbGUgZXZlbnRzXCIpLCBzKVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobiA9IDAsIHIgPSBzW2ldLmxlbmd0aDsgbiA8IHI7IG4rKykgUy5ldmVudC5hZGQodCwgaSwgc1tpXVtuXSk7XHJcbiAgICAgICAgICAgIFEuaGFzRGF0YShlKSAmJiAobyA9IFEuYWNjZXNzKGUpLCBhID0gUy5leHRlbmQoe30sIG8pLCBRLnNldCh0LCBhKSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gSGUobiwgciwgaSwgbykge1xyXG4gICAgICAgIHIgPSBnKHIpO1xyXG4gICAgICAgIHZhciBlLCB0LCBhLCBzLCB1LCBsLCBjID0gMCxcclxuICAgICAgICAgICAgZiA9IG4ubGVuZ3RoLFxyXG4gICAgICAgICAgICBwID0gZiAtIDEsXHJcbiAgICAgICAgICAgIGQgPSByWzBdLFxyXG4gICAgICAgICAgICBoID0gbShkKTtcclxuICAgICAgICBpZiAoaCB8fCAxIDwgZiAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBkICYmICF5LmNoZWNrQ2xvbmUgJiYgQWUudGVzdChkKSkgcmV0dXJuIG4uZWFjaChmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gbi5lcShlKTtcclxuICAgICAgICAgICAgaCAmJiAoclswXSA9IGQuY2FsbCh0aGlzLCBlLCB0Lmh0bWwoKSkpLCBIZSh0LCByLCBpLCBvKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChmICYmICh0ID0gKGUgPSB4ZShyLCBuWzBdLm93bmVyRG9jdW1lbnQsICExLCBuLCBvKSkuZmlyc3RDaGlsZCwgMSA9PT0gZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiAoZSA9IHQpLCB0IHx8IG8pKSB7XHJcbiAgICAgICAgICAgIGZvciAocyA9IChhID0gUy5tYXAodmUoZSwgXCJzY3JpcHRcIiksIERlKSkubGVuZ3RoOyBjIDwgZjsgYysrKSB1ID0gZSwgYyAhPT0gcCAmJiAodSA9IFMuY2xvbmUodSwgITAsICEwKSwgcyAmJiBTLm1lcmdlKGEsIHZlKHUsIFwic2NyaXB0XCIpKSksIGkuY2FsbChuW2NdLCB1LCBjKTtcclxuICAgICAgICAgICAgaWYgKHMpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGwgPSBhW2EubGVuZ3RoIC0gMV0ub3duZXJEb2N1bWVudCwgUy5tYXAoYSwgcWUpLCBjID0gMDsgYyA8IHM7IGMrKykgdSA9IGFbY10sIGhlLnRlc3QodS50eXBlIHx8IFwiXCIpICYmICFZLmFjY2Vzcyh1LCBcImdsb2JhbEV2YWxcIikgJiYgUy5jb250YWlucyhsLCB1KSAmJiAodS5zcmMgJiYgXCJtb2R1bGVcIiAhPT0gKHUudHlwZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpID8gUy5fZXZhbFVybCAmJiAhdS5ub01vZHVsZSAmJiBTLl9ldmFsVXJsKHUuc3JjLCB7IG5vbmNlOiB1Lm5vbmNlIHx8IHUuZ2V0QXR0cmlidXRlKFwibm9uY2VcIikgfSwgbCkgOiBiKHUudGV4dENvbnRlbnQucmVwbGFjZShOZSwgXCJcIiksIHUsIGwpKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIE9lKGUsIHQsIG4pIHsgZm9yICh2YXIgciwgaSA9IHQgPyBTLmZpbHRlcih0LCBlKSA6IGUsIG8gPSAwOyBudWxsICE9IChyID0gaVtvXSk7IG8rKykgbiB8fCAxICE9PSByLm5vZGVUeXBlIHx8IFMuY2xlYW5EYXRhKHZlKHIpKSwgci5wYXJlbnROb2RlICYmIChuICYmIGllKHIpICYmIHllKHZlKHIsIFwic2NyaXB0XCIpKSwgci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHIpKTsgcmV0dXJuIGUgfVxyXG4gICAgUy5leHRlbmQoe1xyXG4gICAgICAgIGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUgfSxcclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24oZSwgdCwgbikge1xyXG4gICAgICAgICAgICB2YXIgciwgaSwgbywgYSwgcywgdSwgbCwgYyA9IGUuY2xvbmVOb2RlKCEwKSxcclxuICAgICAgICAgICAgICAgIGYgPSBpZShlKTtcclxuICAgICAgICAgICAgaWYgKCEoeS5ub0Nsb25lQ2hlY2tlZCB8fCAxICE9PSBlLm5vZGVUeXBlICYmIDExICE9PSBlLm5vZGVUeXBlIHx8IFMuaXNYTUxEb2MoZSkpKVxyXG4gICAgICAgICAgICAgICAgZm9yIChhID0gdmUoYyksIHIgPSAwLCBpID0gKG8gPSB2ZShlKSkubGVuZ3RoOyByIDwgaTsgcisrKSBzID0gb1tyXSwgdSA9IGFbcl0sIHZvaWQgMCwgXCJpbnB1dFwiID09PSAobCA9IHUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgJiYgcGUudGVzdChzLnR5cGUpID8gdS5jaGVja2VkID0gcy5jaGVja2VkIDogXCJpbnB1dFwiICE9PSBsICYmIFwidGV4dGFyZWFcIiAhPT0gbCB8fCAodS5kZWZhdWx0VmFsdWUgPSBzLmRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICh0KVxyXG4gICAgICAgICAgICAgICAgaWYgKG4pXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChvID0gbyB8fCB2ZShlKSwgYSA9IGEgfHwgdmUoYyksIHIgPSAwLCBpID0gby5sZW5ndGg7IHIgPCBpOyByKyspIExlKG9bcl0sIGFbcl0pO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBMZShlLCBjKTtcclxuICAgICAgICAgICAgcmV0dXJuIDAgPCAoYSA9IHZlKGMsIFwic2NyaXB0XCIpKS5sZW5ndGggJiYgeWUoYSwgIWYgJiYgdmUoZSwgXCJzY3JpcHRcIikpLCBjXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhbkRhdGE6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgdCwgbiwgciwgaSA9IFMuZXZlbnQuc3BlY2lhbCwgbyA9IDA7IHZvaWQgMCAhPT0gKG4gPSBlW29dKTsgbysrKVxyXG4gICAgICAgICAgICAgICAgaWYgKFYobikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodCA9IG5bWS5leHBhbmRvXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5ldmVudHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHIgaW4gdC5ldmVudHMpIGlbcl0gPyBTLmV2ZW50LnJlbW92ZShuLCByKSA6IFMucmVtb3ZlRXZlbnQobiwgciwgdC5oYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuW1kuZXhwYW5kb10gPSB2b2lkIDBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbltRLmV4cGFuZG9dICYmIChuW1EuZXhwYW5kb10gPSB2b2lkIDApXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSksIFMuZm4uZXh0ZW5kKHtcclxuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIE9lKHRoaXMsIGUsICEwKSB9LFxyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gT2UodGhpcywgZSkgfSxcclxuICAgICAgICB0ZXh0OiBmdW5jdGlvbihlKSB7IHJldHVybiAkKHRoaXMsIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHZvaWQgMCA9PT0gZSA/IFMudGV4dCh0aGlzKSA6IHRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uKCkgeyAxICE9PSB0aGlzLm5vZGVUeXBlICYmIDExICE9PSB0aGlzLm5vZGVUeXBlICYmIDkgIT09IHRoaXMubm9kZVR5cGUgfHwgKHRoaXMudGV4dENvbnRlbnQgPSBlKSB9KSB9LCBudWxsLCBlLCBhcmd1bWVudHMubGVuZ3RoKSB9LFxyXG4gICAgICAgIGFwcGVuZDogZnVuY3Rpb24oKSB7IHJldHVybiBIZSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKGUpIHsgMSAhPT0gdGhpcy5ub2RlVHlwZSAmJiAxMSAhPT0gdGhpcy5ub2RlVHlwZSAmJiA5ICE9PSB0aGlzLm5vZGVUeXBlIHx8IGplKHRoaXMsIGUpLmFwcGVuZENoaWxkKGUpIH0pIH0sXHJcbiAgICAgICAgcHJlcGVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBIZSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgxID09PSB0aGlzLm5vZGVUeXBlIHx8IDExID09PSB0aGlzLm5vZGVUeXBlIHx8IDkgPT09IHRoaXMubm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGplKHRoaXMsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHQuaW5zZXJ0QmVmb3JlKGUsIHQuZmlyc3RDaGlsZClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJlZm9yZTogZnVuY3Rpb24oKSB7IHJldHVybiBIZSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKGUpIHsgdGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSwgdGhpcykgfSkgfSxcclxuICAgICAgICBhZnRlcjogZnVuY3Rpb24oKSB7IHJldHVybiBIZSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKGUpIHsgdGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSwgdGhpcy5uZXh0U2libGluZykgfSkgfSxcclxuICAgICAgICBlbXB0eTogZnVuY3Rpb24oKSB7IGZvciAodmFyIGUsIHQgPSAwOyBudWxsICE9IChlID0gdGhpc1t0XSk7IHQrKykgMSA9PT0gZS5ub2RlVHlwZSAmJiAoUy5jbGVhbkRhdGEodmUoZSwgITEpKSwgZS50ZXh0Q29udGVudCA9IFwiXCIpOyByZXR1cm4gdGhpcyB9LFxyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbihlLCB0KSB7IHJldHVybiBlID0gbnVsbCAhPSBlICYmIGUsIHQgPSBudWxsID09IHQgPyBlIDogdCwgdGhpcy5tYXAoZnVuY3Rpb24oKSB7IHJldHVybiBTLmNsb25lKHRoaXMsIGUsIHQpIH0pIH0sXHJcbiAgICAgICAgaHRtbDogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXNbMF0gfHwge30sXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgciA9IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSAmJiAxID09PSB0Lm5vZGVUeXBlKSByZXR1cm4gdC5pbm5lckhUTUw7XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiAha2UudGVzdChlKSAmJiAhZ2VbKGRlLmV4ZWMoZSkgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBTLmh0bWxQcmVmaWx0ZXIoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IG4gPCByOyBuKyspIDEgPT09ICh0ID0gdGhpc1tuXSB8fCB7fSkubm9kZVR5cGUgJiYgKFMuY2xlYW5EYXRhKHZlKHQsICExKSksIHQuaW5uZXJIVE1MID0gZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAwXHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHQgJiYgdGhpcy5lbXB0eSgpLmFwcGVuZChlKVxyXG4gICAgICAgICAgICB9LCBudWxsLCBlLCBhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IFtdO1xyXG4gICAgICAgICAgICByZXR1cm4gSGUodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgIFMuaW5BcnJheSh0aGlzLCBuKSA8IDAgJiYgKFMuY2xlYW5EYXRhKHZlKHRoaXMpKSwgdCAmJiB0LnJlcGxhY2VDaGlsZChlLCB0aGlzKSlcclxuICAgICAgICAgICAgfSwgbilcclxuICAgICAgICB9XHJcbiAgICB9KSwgUy5lYWNoKHsgYXBwZW5kVG86IFwiYXBwZW5kXCIsIHByZXBlbmRUbzogXCJwcmVwZW5kXCIsIGluc2VydEJlZm9yZTogXCJiZWZvcmVcIiwgaW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIiwgcmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiIH0sIGZ1bmN0aW9uKGUsIGEpIHsgUy5mbltlXSA9IGZ1bmN0aW9uKGUpIHsgZm9yICh2YXIgdCwgbiA9IFtdLCByID0gUyhlKSwgaSA9IHIubGVuZ3RoIC0gMSwgbyA9IDA7IG8gPD0gaTsgbysrKSB0ID0gbyA9PT0gaSA/IHRoaXMgOiB0aGlzLmNsb25lKCEwKSwgUyhyW29dKVthXSh0KSwgdS5hcHBseShuLCB0LmdldCgpKTsgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG4pIH0gfSk7XHJcbiAgICB2YXIgUGUgPSBuZXcgUmVnRXhwKFwiXihcIiArIGVlICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIpLFxyXG4gICAgICAgIFJlID0gZnVuY3Rpb24oZSkgeyB2YXIgdCA9IGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldzsgcmV0dXJuIHQgJiYgdC5vcGVuZXIgfHwgKHQgPSBDKSwgdC5nZXRDb21wdXRlZFN0eWxlKGUpIH0sXHJcbiAgICAgICAgTWUgPSBmdW5jdGlvbihlLCB0LCBuKSB7IHZhciByLCBpLCBvID0ge307IGZvciAoaSBpbiB0KSBvW2ldID0gZS5zdHlsZVtpXSwgZS5zdHlsZVtpXSA9IHRbaV07IGZvciAoaSBpbiByID0gbi5jYWxsKGUpLCB0KSBlLnN0eWxlW2ldID0gb1tpXTsgcmV0dXJuIHIgfSxcclxuICAgICAgICBJZSA9IG5ldyBSZWdFeHAobmUuam9pbihcInxcIiksIFwiaVwiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBXZShlLCB0LCBuKSB7IHZhciByLCBpLCBvLCBhLCBzID0gZS5zdHlsZTsgcmV0dXJuIChuID0gbiB8fCBSZShlKSkgJiYgKFwiXCIgIT09IChhID0gbi5nZXRQcm9wZXJ0eVZhbHVlKHQpIHx8IG5bdF0pIHx8IGllKGUpIHx8IChhID0gUy5zdHlsZShlLCB0KSksICF5LnBpeGVsQm94U3R5bGVzKCkgJiYgUGUudGVzdChhKSAmJiBJZS50ZXN0KHQpICYmIChyID0gcy53aWR0aCwgaSA9IHMubWluV2lkdGgsIG8gPSBzLm1heFdpZHRoLCBzLm1pbldpZHRoID0gcy5tYXhXaWR0aCA9IHMud2lkdGggPSBhLCBhID0gbi53aWR0aCwgcy53aWR0aCA9IHIsIHMubWluV2lkdGggPSBpLCBzLm1heFdpZHRoID0gbykpLCB2b2lkIDAgIT09IGEgPyBhICsgXCJcIiA6IGEgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEZlKGUsIHQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlKCkpIHJldHVybiAodGhpcy5nZXQgPSB0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ2V0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9ISBmdW5jdGlvbigpIHtcclxuICAgICAgICBmdW5jdGlvbiBlKCkge1xyXG4gICAgICAgICAgICBpZiAobCkge1xyXG4gICAgICAgICAgICAgICAgdS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7bWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCIsIGwuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO21hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7d2lkdGg6NjAlO3RvcDoxJVwiLCByZS5hcHBlbmRDaGlsZCh1KS5hcHBlbmRDaGlsZChsKTtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gQy5nZXRDb21wdXRlZFN0eWxlKGwpO1xyXG4gICAgICAgICAgICAgICAgbiA9IFwiMSVcIiAhPT0gZS50b3AsIHMgPSAxMiA9PT0gdChlLm1hcmdpbkxlZnQpLCBsLnN0eWxlLnJpZ2h0ID0gXCI2MCVcIiwgbyA9IDM2ID09PSB0KGUucmlnaHQpLCByID0gMzYgPT09IHQoZS53aWR0aCksIGwuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIGkgPSAxMiA9PT0gdChsLm9mZnNldFdpZHRoIC8gMyksIHJlLnJlbW92ZUNoaWxkKHUpLCBsID0gbnVsbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB0KGUpIHsgcmV0dXJuIE1hdGgucm91bmQocGFyc2VGbG9hdChlKSkgfVxyXG4gICAgICAgIHZhciBuLCByLCBpLCBvLCBhLCBzLCB1ID0gRS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxyXG4gICAgICAgICAgICBsID0gRS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIGwuc3R5bGUgJiYgKGwuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCIsIGwuY2xvbmVOb2RlKCEwKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCIsIHkuY2xlYXJDbG9uZVN0eWxlID0gXCJjb250ZW50LWJveFwiID09PSBsLnN0eWxlLmJhY2tncm91bmRDbGlwLCBTLmV4dGVuZCh5LCB7IGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHsgcmV0dXJuIGUoKSwgciB9LCBwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7IHJldHVybiBlKCksIG8gfSwgcGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7IHJldHVybiBlKCksIG4gfSwgcmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGUoKSwgcyB9LCBzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHsgcmV0dXJuIGUoKSwgaSB9LCByZWxpYWJsZVRyRGltZW5zaW9uczogZnVuY3Rpb24oKSB7IHZhciBlLCB0LCBuLCByOyByZXR1cm4gbnVsbCA9PSBhICYmIChlID0gRS5jcmVhdGVFbGVtZW50KFwidGFibGVcIiksIHQgPSBFLmNyZWF0ZUVsZW1lbnQoXCJ0clwiKSwgbiA9IEUuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZVwiLCB0LnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjoxcHggc29saWRcIiwgdC5zdHlsZS5oZWlnaHQgPSBcIjFweFwiLCBuLnN0eWxlLmhlaWdodCA9IFwiOXB4XCIsIG4uc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIiwgcmUuYXBwZW5kQ2hpbGQoZSkuYXBwZW5kQ2hpbGQodCkuYXBwZW5kQ2hpbGQobiksIHIgPSBDLmdldENvbXB1dGVkU3R5bGUodCksIGEgPSBwYXJzZUludChyLmhlaWdodCwgMTApICsgcGFyc2VJbnQoci5ib3JkZXJUb3BXaWR0aCwgMTApICsgcGFyc2VJbnQoci5ib3JkZXJCb3R0b21XaWR0aCwgMTApID09PSB0Lm9mZnNldEhlaWdodCwgcmUucmVtb3ZlQ2hpbGQoZSkpLCBhIH0gfSkpXHJcbiAgICB9KCk7XHJcbiAgICB2YXIgQmUgPSBbXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiXSxcclxuICAgICAgICAkZSA9IEUuY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZSxcclxuICAgICAgICBfZSA9IHt9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHplKGUpIHtcclxuICAgICAgICB2YXIgdCA9IFMuY3NzUHJvcHNbZV0gfHwgX2VbZV07XHJcbiAgICAgICAgcmV0dXJuIHQgfHwgKGUgaW4gJGUgPyBlIDogX2VbZV0gPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gZVswXS50b1VwcGVyQ2FzZSgpICsgZS5zbGljZSgxKSxcclxuICAgICAgICAgICAgICAgIG4gPSBCZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChuLS0pXHJcbiAgICAgICAgICAgICAgICBpZiAoKGUgPSBCZVtuXSArIHQpIGluICRlKSByZXR1cm4gZVxyXG4gICAgICAgIH0oZSkgfHwgZSlcclxuICAgIH1cclxuICAgIHZhciBVZSA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcclxuICAgICAgICBYZSA9IC9eLS0vLFxyXG4gICAgICAgIFZlID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcclxuICAgICAgICBHZSA9IHsgbGV0dGVyU3BhY2luZzogXCIwXCIsIGZvbnRXZWlnaHQ6IFwiNDAwXCIgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBZZShlLCB0LCBuKSB7IHZhciByID0gdGUuZXhlYyh0KTsgcmV0dXJuIHIgPyBNYXRoLm1heCgwLCByWzJdIC0gKG4gfHwgMCkpICsgKHJbM10gfHwgXCJweFwiKSA6IHQgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFFlKGUsIHQsIG4sIHIsIGksIG8pIHtcclxuICAgICAgICB2YXIgYSA9IFwid2lkdGhcIiA9PT0gdCA/IDEgOiAwLFxyXG4gICAgICAgICAgICBzID0gMCxcclxuICAgICAgICAgICAgdSA9IDA7XHJcbiAgICAgICAgaWYgKG4gPT09IChyID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSkgcmV0dXJuIDA7XHJcbiAgICAgICAgZm9yICg7IGEgPCA0OyBhICs9IDIpIFwibWFyZ2luXCIgPT09IG4gJiYgKHUgKz0gUy5jc3MoZSwgbiArIG5lW2FdLCAhMCwgaSkpLCByID8gKFwiY29udGVudFwiID09PSBuICYmICh1IC09IFMuY3NzKGUsIFwicGFkZGluZ1wiICsgbmVbYV0sICEwLCBpKSksIFwibWFyZ2luXCIgIT09IG4gJiYgKHUgLT0gUy5jc3MoZSwgXCJib3JkZXJcIiArIG5lW2FdICsgXCJXaWR0aFwiLCAhMCwgaSkpKSA6ICh1ICs9IFMuY3NzKGUsIFwicGFkZGluZ1wiICsgbmVbYV0sICEwLCBpKSwgXCJwYWRkaW5nXCIgIT09IG4gPyB1ICs9IFMuY3NzKGUsIFwiYm9yZGVyXCIgKyBuZVthXSArIFwiV2lkdGhcIiwgITAsIGkpIDogcyArPSBTLmNzcyhlLCBcImJvcmRlclwiICsgbmVbYV0gKyBcIldpZHRoXCIsICEwLCBpKSk7XHJcbiAgICAgICAgcmV0dXJuICFyICYmIDAgPD0gbyAmJiAodSArPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoZVtcIm9mZnNldFwiICsgdFswXS50b1VwcGVyQ2FzZSgpICsgdC5zbGljZSgxKV0gLSBvIC0gdSAtIHMgLSAuNSkpIHx8IDApLCB1XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gSmUoZSwgdCwgbikge1xyXG4gICAgICAgIHZhciByID0gUmUoZSksXHJcbiAgICAgICAgICAgIGkgPSAoIXkuYm94U2l6aW5nUmVsaWFibGUoKSB8fCBuKSAmJiBcImJvcmRlci1ib3hcIiA9PT0gUy5jc3MoZSwgXCJib3hTaXppbmdcIiwgITEsIHIpLFxyXG4gICAgICAgICAgICBvID0gaSxcclxuICAgICAgICAgICAgYSA9IFdlKGUsIHQsIHIpLFxyXG4gICAgICAgICAgICBzID0gXCJvZmZzZXRcIiArIHRbMF0udG9VcHBlckNhc2UoKSArIHQuc2xpY2UoMSk7XHJcbiAgICAgICAgaWYgKFBlLnRlc3QoYSkpIHtcclxuICAgICAgICAgICAgaWYgKCFuKSByZXR1cm4gYTtcclxuICAgICAgICAgICAgYSA9IFwiYXV0b1wiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoIXkuYm94U2l6aW5nUmVsaWFibGUoKSAmJiBpIHx8ICF5LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgQShlLCBcInRyXCIpIHx8IFwiYXV0b1wiID09PSBhIHx8ICFwYXJzZUZsb2F0KGEpICYmIFwiaW5saW5lXCIgPT09IFMuY3NzKGUsIFwiZGlzcGxheVwiLCAhMSwgcikpICYmIGUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggJiYgKGkgPSBcImJvcmRlci1ib3hcIiA9PT0gUy5jc3MoZSwgXCJib3hTaXppbmdcIiwgITEsIHIpLCAobyA9IHMgaW4gZSkgJiYgKGEgPSBlW3NdKSksIChhID0gcGFyc2VGbG9hdChhKSB8fCAwKSArIFFlKGUsIHQsIG4gfHwgKGkgPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIpLCBvLCByLCBhKSArIFwicHhcIlxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEtlKGUsIHQsIG4sIHIsIGkpIHsgcmV0dXJuIG5ldyBLZS5wcm90b3R5cGUuaW5pdChlLCB0LCBuLCByLCBpKSB9XHJcbiAgICBTLmV4dGVuZCh7XHJcbiAgICAgICAgY3NzSG9va3M6IHsgb3BhY2l0eTogeyBnZXQ6IGZ1bmN0aW9uKGUsIHQpIHsgaWYgKHQpIHsgdmFyIG4gPSBXZShlLCBcIm9wYWNpdHlcIik7IHJldHVybiBcIlwiID09PSBuID8gXCIxXCIgOiBuIH0gfSB9IH0sXHJcbiAgICAgICAgY3NzTnVtYmVyOiB7IGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiAhMCwgY29sdW1uQ291bnQ6ICEwLCBmaWxsT3BhY2l0eTogITAsIGZsZXhHcm93OiAhMCwgZmxleFNocmluazogITAsIGZvbnRXZWlnaHQ6ICEwLCBncmlkQXJlYTogITAsIGdyaWRDb2x1bW46ICEwLCBncmlkQ29sdW1uRW5kOiAhMCwgZ3JpZENvbHVtblN0YXJ0OiAhMCwgZ3JpZFJvdzogITAsIGdyaWRSb3dFbmQ6ICEwLCBncmlkUm93U3RhcnQ6ICEwLCBsaW5lSGVpZ2h0OiAhMCwgb3BhY2l0eTogITAsIG9yZGVyOiAhMCwgb3JwaGFuczogITAsIHdpZG93czogITAsIHpJbmRleDogITAsIHpvb206ICEwIH0sXHJcbiAgICAgICAgY3NzUHJvcHM6IHt9LFxyXG4gICAgICAgIHN0eWxlOiBmdW5jdGlvbihlLCB0LCBuLCByKSB7XHJcbiAgICAgICAgICAgIGlmIChlICYmIDMgIT09IGUubm9kZVR5cGUgJiYgOCAhPT0gZS5ub2RlVHlwZSAmJiBlLnN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSwgbywgYSwgcyA9IFgodCksXHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IFhlLnRlc3QodCksXHJcbiAgICAgICAgICAgICAgICAgICAgbCA9IGUuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICBpZiAodSB8fCAodCA9IHplKHMpKSwgYSA9IFMuY3NzSG9va3NbdF0gfHwgUy5jc3NIb29rc1tzXSwgdm9pZCAwID09PSBuKSByZXR1cm4gYSAmJiBcImdldFwiIGluIGEgJiYgdm9pZCAwICE9PSAoaSA9IGEuZ2V0KGUsICExLCByKSkgPyBpIDogbFt0XTtcclxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IChvID0gdHlwZW9mIG4pICYmIChpID0gdGUuZXhlYyhuKSkgJiYgaVsxXSAmJiAobiA9IHNlKGUsIHQsIGkpLCBvID0gXCJudW1iZXJcIiksIG51bGwgIT0gbiAmJiBuID09IG4gJiYgKFwibnVtYmVyXCIgIT09IG8gfHwgdSB8fCAobiArPSBpICYmIGlbM10gfHwgKFMuY3NzTnVtYmVyW3NdID8gXCJcIiA6IFwicHhcIikpLCB5LmNsZWFyQ2xvbmVTdHlsZSB8fCBcIlwiICE9PSBuIHx8IDAgIT09IHQuaW5kZXhPZihcImJhY2tncm91bmRcIikgfHwgKGxbdF0gPSBcImluaGVyaXRcIiksIGEgJiYgXCJzZXRcIiBpbiBhICYmIHZvaWQgMCA9PT0gKG4gPSBhLnNldChlLCBuLCByKSkgfHwgKHUgPyBsLnNldFByb3BlcnR5KHQsIG4pIDogbFt0XSA9IG4pKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjc3M6IGZ1bmN0aW9uKGUsIHQsIG4sIHIpIHsgdmFyIGksIG8sIGEsIHMgPSBYKHQpOyByZXR1cm4gWGUudGVzdCh0KSB8fCAodCA9IHplKHMpKSwgKGEgPSBTLmNzc0hvb2tzW3RdIHx8IFMuY3NzSG9va3Nbc10pICYmIFwiZ2V0XCIgaW4gYSAmJiAoaSA9IGEuZ2V0KGUsICEwLCBuKSksIHZvaWQgMCA9PT0gaSAmJiAoaSA9IFdlKGUsIHQsIHIpKSwgXCJub3JtYWxcIiA9PT0gaSAmJiB0IGluIEdlICYmIChpID0gR2VbdF0pLCBcIlwiID09PSBuIHx8IG4gPyAobyA9IHBhcnNlRmxvYXQoaSksICEwID09PSBuIHx8IGlzRmluaXRlKG8pID8gbyB8fCAwIDogaSkgOiBpIH1cclxuICAgIH0pLCBTLmVhY2goW1wiaGVpZ2h0XCIsIFwid2lkdGhcIl0sIGZ1bmN0aW9uKGUsIHUpIHtcclxuICAgICAgICBTLmNzc0hvb2tzW3VdID0ge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgaWYgKHQpIHJldHVybiAhVWUudGVzdChTLmNzcyhlLCBcImRpc3BsYXlcIikpIHx8IGUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggJiYgZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA/IEplKGUsIHUsIG4pIDogTWUoZSwgVmUsIGZ1bmN0aW9uKCkgeyByZXR1cm4gSmUoZSwgdSwgbikgfSkgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihlLCB0LCBuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgciwgaSA9IFJlKGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIG8gPSAheS5zY3JvbGxib3hTaXplKCkgJiYgXCJhYnNvbHV0ZVwiID09PSBpLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSAobyB8fCBuKSAmJiBcImJvcmRlci1ib3hcIiA9PT0gUy5jc3MoZSwgXCJib3hTaXppbmdcIiwgITEsIGkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBuID8gUWUoZSwgdSwgbiwgYSwgaSkgOiAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgJiYgbyAmJiAocyAtPSBNYXRoLmNlaWwoZVtcIm9mZnNldFwiICsgdVswXS50b1VwcGVyQ2FzZSgpICsgdS5zbGljZSgxKV0gLSBwYXJzZUZsb2F0KGlbdV0pIC0gUWUoZSwgdSwgXCJib3JkZXJcIiwgITEsIGkpIC0gLjUpKSwgcyAmJiAociA9IHRlLmV4ZWModCkpICYmIFwicHhcIiAhPT0gKHJbM10gfHwgXCJweFwiKSAmJiAoZS5zdHlsZVt1XSA9IHQsIHQgPSBTLmNzcyhlLCB1KSksIFllKDAsIHQsIHMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KSwgUy5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gRmUoeS5yZWxpYWJsZU1hcmdpbkxlZnQsIGZ1bmN0aW9uKGUsIHQpIHsgaWYgKHQpIHJldHVybiAocGFyc2VGbG9hdChXZShlLCBcIm1hcmdpbkxlZnRcIikpIHx8IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIE1lKGUsIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCB9KSkgKyBcInB4XCIgfSksIFMuZWFjaCh7IG1hcmdpbjogXCJcIiwgcGFkZGluZzogXCJcIiwgYm9yZGVyOiBcIldpZHRoXCIgfSwgZnVuY3Rpb24oaSwgbykgeyBTLmNzc0hvb2tzW2kgKyBvXSA9IHsgZXhwYW5kOiBmdW5jdGlvbihlKSB7IGZvciAodmFyIHQgPSAwLCBuID0ge30sIHIgPSBcInN0cmluZ1wiID09IHR5cGVvZiBlID8gZS5zcGxpdChcIiBcIikgOiBbZV07IHQgPCA0OyB0KyspIG5baSArIG5lW3RdICsgb10gPSByW3RdIHx8IHJbdCAtIDJdIHx8IHJbMF07IHJldHVybiBuIH0gfSwgXCJtYXJnaW5cIiAhPT0gaSAmJiAoUy5jc3NIb29rc1tpICsgb10uc2V0ID0gWWUpIH0pLCBTLmZuLmV4dGVuZCh7XHJcbiAgICAgICAgY3NzOiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMsIGZ1bmN0aW9uKGUsIHQsIG4pIHtcclxuICAgICAgICAgICAgICAgIHZhciByLCBpLCBvID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkgeyBmb3IgKHIgPSBSZShlKSwgaSA9IHQubGVuZ3RoOyBhIDwgaTsgYSsrKSBvW3RbYV1dID0gUy5jc3MoZSwgdFthXSwgITEsIHIpOyByZXR1cm4gbyB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBuID8gUy5zdHlsZShlLCB0LCBuKSA6IFMuY3NzKGUsIHQpXHJcbiAgICAgICAgICAgIH0sIGUsIHQsIDEgPCBhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgIH1cclxuICAgIH0pLCAoKFMuVHdlZW4gPSBLZSkucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogS2UsIGluaXQ6IGZ1bmN0aW9uKGUsIHQsIG4sIHIsIGksIG8pIHsgdGhpcy5lbGVtID0gZSwgdGhpcy5wcm9wID0gbiwgdGhpcy5lYXNpbmcgPSBpIHx8IFMuZWFzaW5nLl9kZWZhdWx0LCB0aGlzLm9wdGlvbnMgPSB0LCB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpLCB0aGlzLmVuZCA9IHIsIHRoaXMudW5pdCA9IG8gfHwgKFMuY3NzTnVtYmVyW25dID8gXCJcIiA6IFwicHhcIikgfSwgY3VyOiBmdW5jdGlvbigpIHsgdmFyIGUgPSBLZS5wcm9wSG9va3NbdGhpcy5wcm9wXTsgcmV0dXJuIGUgJiYgZS5nZXQgPyBlLmdldCh0aGlzKSA6IEtlLnByb3BIb29rcy5fZGVmYXVsdC5nZXQodGhpcykgfSwgcnVuOiBmdW5jdGlvbihlKSB7IHZhciB0LCBuID0gS2UucHJvcEhvb2tzW3RoaXMucHJvcF07IHJldHVybiB0aGlzLm9wdGlvbnMuZHVyYXRpb24gPyB0aGlzLnBvcyA9IHQgPSBTLmVhc2luZ1t0aGlzLmVhc2luZ10oZSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogZSwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uKSA6IHRoaXMucG9zID0gdCA9IGUsIHRoaXMubm93ID0gKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgKiB0ICsgdGhpcy5zdGFydCwgdGhpcy5vcHRpb25zLnN0ZXAgJiYgdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzKSwgbiAmJiBuLnNldCA/IG4uc2V0KHRoaXMpIDogS2UucHJvcEhvb2tzLl9kZWZhdWx0LnNldCh0aGlzKSwgdGhpcyB9IH0pLmluaXQucHJvdG90eXBlID0gS2UucHJvdG90eXBlLCAoS2UucHJvcEhvb2tzID0geyBfZGVmYXVsdDogeyBnZXQ6IGZ1bmN0aW9uKGUpIHsgdmFyIHQ7IHJldHVybiAxICE9PSBlLmVsZW0ubm9kZVR5cGUgfHwgbnVsbCAhPSBlLmVsZW1bZS5wcm9wXSAmJiBudWxsID09IGUuZWxlbS5zdHlsZVtlLnByb3BdID8gZS5lbGVtW2UucHJvcF0gOiAodCA9IFMuY3NzKGUuZWxlbSwgZS5wcm9wLCBcIlwiKSkgJiYgXCJhdXRvXCIgIT09IHQgPyB0IDogMCB9LCBzZXQ6IGZ1bmN0aW9uKGUpIHsgUy5meC5zdGVwW2UucHJvcF0gPyBTLmZ4LnN0ZXBbZS5wcm9wXShlKSA6IDEgIT09IGUuZWxlbS5ub2RlVHlwZSB8fCAhUy5jc3NIb29rc1tlLnByb3BdICYmIG51bGwgPT0gZS5lbGVtLnN0eWxlW3plKGUucHJvcCldID8gZS5lbGVtW2UucHJvcF0gPSBlLm5vdyA6IFMuc3R5bGUoZS5lbGVtLCBlLnByb3AsIGUubm93ICsgZS51bml0KSB9IH0gfSkuc2Nyb2xsVG9wID0gS2UucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7IHNldDogZnVuY3Rpb24oZSkgeyBlLmVsZW0ubm9kZVR5cGUgJiYgZS5lbGVtLnBhcmVudE5vZGUgJiYgKGUuZWxlbVtlLnByb3BdID0gZS5ub3cpIH0gfSwgUy5lYXNpbmcgPSB7IGxpbmVhcjogZnVuY3Rpb24oZSkgeyByZXR1cm4gZSB9LCBzd2luZzogZnVuY3Rpb24oZSkgeyByZXR1cm4gLjUgLSBNYXRoLmNvcyhlICogTWF0aC5QSSkgLyAyIH0sIF9kZWZhdWx0OiBcInN3aW5nXCIgfSwgUy5meCA9IEtlLnByb3RvdHlwZS5pbml0LCBTLmZ4LnN0ZXAgPSB7fTtcclxuICAgIHZhciBaZSwgZXQsIHR0LCBudCwgcnQgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXHJcbiAgICAgICAgaXQgPSAvcXVldWVIb29rcyQvO1xyXG5cclxuICAgIGZ1bmN0aW9uIG90KCkgeyBldCAmJiAoITEgPT09IEUuaGlkZGVuICYmIEMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gQy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUob3QpIDogQy5zZXRUaW1lb3V0KG90LCBTLmZ4LmludGVydmFsKSwgUy5meC50aWNrKCkpIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhdCgpIHsgcmV0dXJuIEMuc2V0VGltZW91dChmdW5jdGlvbigpIHsgWmUgPSB2b2lkIDAgfSksIFplID0gRGF0ZS5ub3coKSB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3QoZSwgdCkge1xyXG4gICAgICAgIHZhciBuLCByID0gMCxcclxuICAgICAgICAgICAgaSA9IHsgaGVpZ2h0OiBlIH07XHJcbiAgICAgICAgZm9yICh0ID0gdCA/IDEgOiAwOyByIDwgNDsgciArPSAyIC0gdCkgaVtcIm1hcmdpblwiICsgKG4gPSBuZVtyXSldID0gaVtcInBhZGRpbmdcIiArIG5dID0gZTtcclxuICAgICAgICByZXR1cm4gdCAmJiAoaS5vcGFjaXR5ID0gaS53aWR0aCA9IGUpLCBpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXQoZSwgdCwgbikge1xyXG4gICAgICAgIGZvciAodmFyIHIsIGkgPSAobHQudHdlZW5lcnNbdF0gfHwgW10pLmNvbmNhdChsdC50d2VlbmVyc1tcIipcIl0pLCBvID0gMCwgYSA9IGkubGVuZ3RoOyBvIDwgYTsgbysrKVxyXG4gICAgICAgICAgICBpZiAociA9IGlbb10uY2FsbChuLCB0LCBlKSkgcmV0dXJuIHJcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsdChvLCBlLCB0KSB7XHJcbiAgICAgICAgdmFyIG4sIGEsIHIgPSAwLFxyXG4gICAgICAgICAgICBpID0gbHQucHJlZmlsdGVycy5sZW5ndGgsXHJcbiAgICAgICAgICAgIHMgPSBTLkRlZmVycmVkKCkuYWx3YXlzKGZ1bmN0aW9uKCkgeyBkZWxldGUgdS5lbGVtIH0pLFxyXG4gICAgICAgICAgICB1ID0gZnVuY3Rpb24oKSB7IGlmIChhKSByZXR1cm4gITE7IGZvciAodmFyIGUgPSBaZSB8fCBhdCgpLCB0ID0gTWF0aC5tYXgoMCwgbC5zdGFydFRpbWUgKyBsLmR1cmF0aW9uIC0gZSksIG4gPSAxIC0gKHQgLyBsLmR1cmF0aW9uIHx8IDApLCByID0gMCwgaSA9IGwudHdlZW5zLmxlbmd0aDsgciA8IGk7IHIrKykgbC50d2VlbnNbcl0ucnVuKG4pOyByZXR1cm4gcy5ub3RpZnlXaXRoKG8sIFtsLCBuLCB0XSksIG4gPCAxICYmIGkgPyB0IDogKGkgfHwgcy5ub3RpZnlXaXRoKG8sIFtsLCAxLCAwXSksIHMucmVzb2x2ZVdpdGgobywgW2xdKSwgITEpIH0sXHJcbiAgICAgICAgICAgIGwgPSBzLnByb21pc2Uoe1xyXG4gICAgICAgICAgICAgICAgZWxlbTogbyxcclxuICAgICAgICAgICAgICAgIHByb3BzOiBTLmV4dGVuZCh7fSwgZSksXHJcbiAgICAgICAgICAgICAgICBvcHRzOiBTLmV4dGVuZCghMCwgeyBzcGVjaWFsRWFzaW5nOiB7fSwgZWFzaW5nOiBTLmVhc2luZy5fZGVmYXVsdCB9LCB0KSxcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUHJvcGVydGllczogZSxcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsT3B0aW9uczogdCxcclxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogWmUgfHwgYXQoKSxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0LmR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgdHdlZW5zOiBbXSxcclxuICAgICAgICAgICAgICAgIGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbihlLCB0KSB7IHZhciBuID0gUy5Ud2VlbihvLCBsLm9wdHMsIGUsIHQsIGwub3B0cy5zcGVjaWFsRWFzaW5nW2VdIHx8IGwub3B0cy5lYXNpbmcpOyByZXR1cm4gbC50d2VlbnMucHVzaChuKSwgbiB9LFxyXG4gICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGUgPyBsLnR3ZWVucy5sZW5ndGggOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhKSByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGEgPSAhMDsgdCA8IG47IHQrKykgbC50d2VlbnNbdF0ucnVuKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlID8gKHMubm90aWZ5V2l0aChvLCBbbCwgMSwgMF0pLCBzLnJlc29sdmVXaXRoKG8sIFtsLCBlXSkpIDogcy5yZWplY3RXaXRoKG8sIFtsLCBlXSksIHRoaXNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIGMgPSBsLnByb3BzO1xyXG4gICAgICAgIGZvciAoISBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiwgciwgaSwgbywgYTtcclxuICAgICAgICAgICAgICAgIGZvciAobiBpbiBlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID0gdFtyID0gWChuKV0sIG8gPSBlW25dLCBBcnJheS5pc0FycmF5KG8pICYmIChpID0gb1sxXSwgbyA9IGVbbl0gPSBvWzBdKSwgbiAhPT0gciAmJiAoZVtyXSA9IG8sIGRlbGV0ZSBlW25dKSwgKGEgPSBTLmNzc0hvb2tzW3JdKSAmJiBcImV4cGFuZFwiIGluIGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobiBpbiBvID0gYS5leHBhbmQobyksIGRlbGV0ZSBlW3JdLCBvKSBuIGluIGUgfHwgKGVbbl0gPSBvW25dLCB0W25dID0gaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB0W3JdID0gaVxyXG4gICAgICAgICAgICB9KGMsIGwub3B0cy5zcGVjaWFsRWFzaW5nKTsgciA8IGk7IHIrKylcclxuICAgICAgICAgICAgaWYgKG4gPSBsdC5wcmVmaWx0ZXJzW3JdLmNhbGwobCwgbywgYywgbC5vcHRzKSkgcmV0dXJuIG0obi5zdG9wKSAmJiAoUy5fcXVldWVIb29rcyhsLmVsZW0sIGwub3B0cy5xdWV1ZSkuc3RvcCA9IG4uc3RvcC5iaW5kKG4pKSwgbjtcclxuICAgICAgICByZXR1cm4gUy5tYXAoYywgdXQsIGwpLCBtKGwub3B0cy5zdGFydCkgJiYgbC5vcHRzLnN0YXJ0LmNhbGwobywgbCksIGwucHJvZ3Jlc3MobC5vcHRzLnByb2dyZXNzKS5kb25lKGwub3B0cy5kb25lLCBsLm9wdHMuY29tcGxldGUpLmZhaWwobC5vcHRzLmZhaWwpLmFsd2F5cyhsLm9wdHMuYWx3YXlzKSwgUy5meC50aW1lcihTLmV4dGVuZCh1LCB7IGVsZW06IG8sIGFuaW06IGwsIHF1ZXVlOiBsLm9wdHMucXVldWUgfSkpLCBsXHJcbiAgICB9XHJcbiAgICBTLkFuaW1hdGlvbiA9IFMuZXh0ZW5kKGx0LCB7XHJcbiAgICAgICAgdHdlZW5lcnM6IHsgXCIqXCI6IFtmdW5jdGlvbihlLCB0KSB7IHZhciBuID0gdGhpcy5jcmVhdGVUd2VlbihlLCB0KTsgcmV0dXJuIHNlKG4uZWxlbSwgZSwgdGUuZXhlYyh0KSwgbiksIG4gfV0gfSxcclxuICAgICAgICB0d2VlbmVyOiBmdW5jdGlvbihlLCB0KSB7IG0oZSkgPyAodCA9IGUsIGUgPSBbXCIqXCJdKSA6IGUgPSBlLm1hdGNoKFApOyBmb3IgKHZhciBuLCByID0gMCwgaSA9IGUubGVuZ3RoOyByIDwgaTsgcisrKSBuID0gZVtyXSwgbHQudHdlZW5lcnNbbl0gPSBsdC50d2VlbmVyc1tuXSB8fCBbXSwgbHQudHdlZW5lcnNbbl0udW5zaGlmdCh0KSB9LFxyXG4gICAgICAgIHByZWZpbHRlcnM6IFtmdW5jdGlvbihlLCB0LCBuKSB7XHJcbiAgICAgICAgICAgIHZhciByLCBpLCBvLCBhLCBzLCB1LCBsLCBjLCBmID0gXCJ3aWR0aFwiIGluIHQgfHwgXCJoZWlnaHRcIiBpbiB0LFxyXG4gICAgICAgICAgICAgICAgcCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBkID0ge30sXHJcbiAgICAgICAgICAgICAgICBoID0gZS5zdHlsZSxcclxuICAgICAgICAgICAgICAgIGcgPSBlLm5vZGVUeXBlICYmIGFlKGUpLFxyXG4gICAgICAgICAgICAgICAgdiA9IFkuZ2V0KGUsIFwiZnhzaG93XCIpO1xyXG4gICAgICAgICAgICBmb3IgKHIgaW4gbi5xdWV1ZSB8fCAobnVsbCA9PSAoYSA9IFMuX3F1ZXVlSG9va3MoZSwgXCJmeFwiKSkudW5xdWV1ZWQgJiYgKGEudW5xdWV1ZWQgPSAwLCBzID0gYS5lbXB0eS5maXJlLCBhLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHsgYS51bnF1ZXVlZCB8fCBzKCkgfSksIGEudW5xdWV1ZWQrKywgcC5hbHdheXMoZnVuY3Rpb24oKSB7IHAuYWx3YXlzKGZ1bmN0aW9uKCkgeyBhLnVucXVldWVkLS0sIFMucXVldWUoZSwgXCJmeFwiKS5sZW5ndGggfHwgYS5lbXB0eS5maXJlKCkgfSkgfSkpLCB0KVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPSB0W3JdLCBydC50ZXN0KGkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZSB0W3JdLCBvID0gbyB8fCBcInRvZ2dsZVwiID09PSBpLCBpID09PSAoZyA/IFwiaGlkZVwiIDogXCJzaG93XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInNob3dcIiAhPT0gaSB8fCAhdiB8fCB2b2lkIDAgPT09IHZbcl0pIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gITBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZFtyXSA9IHYgJiYgdltyXSB8fCBTLnN0eWxlKGUsIHIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgodSA9ICFTLmlzRW1wdHlPYmplY3QodCkpIHx8ICFTLmlzRW1wdHlPYmplY3QoZCkpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHIgaW4gZiAmJiAxID09PSBlLm5vZGVUeXBlICYmIChuLm92ZXJmbG93ID0gW2gub3ZlcmZsb3csIGgub3ZlcmZsb3dYLCBoLm92ZXJmbG93WV0sIG51bGwgPT0gKGwgPSB2ICYmIHYuZGlzcGxheSkgJiYgKGwgPSBZLmdldChlLCBcImRpc3BsYXlcIikpLCBcIm5vbmVcIiA9PT0gKGMgPSBTLmNzcyhlLCBcImRpc3BsYXlcIikpICYmIChsID8gYyA9IGwgOiAobGUoW2VdLCAhMCksIGwgPSBlLnN0eWxlLmRpc3BsYXkgfHwgbCwgYyA9IFMuY3NzKGUsIFwiZGlzcGxheVwiKSwgbGUoW2VdKSkpLCAoXCJpbmxpbmVcIiA9PT0gYyB8fCBcImlubGluZS1ibG9ja1wiID09PSBjICYmIG51bGwgIT0gbCkgJiYgXCJub25lXCIgPT09IFMuY3NzKGUsIFwiZmxvYXRcIikgJiYgKHUgfHwgKHAuZG9uZShmdW5jdGlvbigpIHsgaC5kaXNwbGF5ID0gbCB9KSwgbnVsbCA9PSBsICYmIChjID0gaC5kaXNwbGF5LCBsID0gXCJub25lXCIgPT09IGMgPyBcIlwiIDogYykpLCBoLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiKSksIG4ub3ZlcmZsb3cgJiYgKGgub3ZlcmZsb3cgPSBcImhpZGRlblwiLCBwLmFsd2F5cyhmdW5jdGlvbigpIHsgaC5vdmVyZmxvdyA9IG4ub3ZlcmZsb3dbMF0sIGgub3ZlcmZsb3dYID0gbi5vdmVyZmxvd1sxXSwgaC5vdmVyZmxvd1kgPSBuLm92ZXJmbG93WzJdIH0pKSwgdSA9ICExLCBkKSB1IHx8ICh2ID8gXCJoaWRkZW5cIiBpbiB2ICYmIChnID0gdi5oaWRkZW4pIDogdiA9IFkuYWNjZXNzKGUsIFwiZnhzaG93XCIsIHsgZGlzcGxheTogbCB9KSwgbyAmJiAodi5oaWRkZW4gPSAhZyksIGcgJiYgbGUoW2VdLCAhMCksIHAuZG9uZShmdW5jdGlvbigpIHsgZm9yIChyIGluIGcgfHwgbGUoW2VdKSwgWS5yZW1vdmUoZSwgXCJmeHNob3dcIiksIGQpIFMuc3R5bGUoZSwgciwgZFtyXSkgfSkpLCB1ID0gdXQoZyA/IHZbcl0gOiAwLCByLCBwKSwgciBpbiB2IHx8ICh2W3JdID0gdS5zdGFydCwgZyAmJiAodS5lbmQgPSB1LnN0YXJ0LCB1LnN0YXJ0ID0gMCkpXHJcbiAgICAgICAgfV0sXHJcbiAgICAgICAgcHJlZmlsdGVyOiBmdW5jdGlvbihlLCB0KSB7IHQgPyBsdC5wcmVmaWx0ZXJzLnVuc2hpZnQoZSkgOiBsdC5wcmVmaWx0ZXJzLnB1c2goZSkgfVxyXG4gICAgfSksIFMuc3BlZWQgPSBmdW5jdGlvbihlLCB0LCBuKSB7IHZhciByID0gZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBlID8gUy5leHRlbmQoe30sIGUpIDogeyBjb21wbGV0ZTogbiB8fCAhbiAmJiB0IHx8IG0oZSkgJiYgZSwgZHVyYXRpb246IGUsIGVhc2luZzogbiAmJiB0IHx8IHQgJiYgIW0odCkgJiYgdCB9OyByZXR1cm4gUy5meC5vZmYgPyByLmR1cmF0aW9uID0gMCA6IFwibnVtYmVyXCIgIT0gdHlwZW9mIHIuZHVyYXRpb24gJiYgKHIuZHVyYXRpb24gaW4gUy5meC5zcGVlZHMgPyByLmR1cmF0aW9uID0gUy5meC5zcGVlZHNbci5kdXJhdGlvbl0gOiByLmR1cmF0aW9uID0gUy5meC5zcGVlZHMuX2RlZmF1bHQpLCBudWxsICE9IHIucXVldWUgJiYgITAgIT09IHIucXVldWUgfHwgKHIucXVldWUgPSBcImZ4XCIpLCByLm9sZCA9IHIuY29tcGxldGUsIHIuY29tcGxldGUgPSBmdW5jdGlvbigpIHsgbShyLm9sZCkgJiYgci5vbGQuY2FsbCh0aGlzKSwgci5xdWV1ZSAmJiBTLmRlcXVldWUodGhpcywgci5xdWV1ZSkgfSwgciB9LCBTLmZuLmV4dGVuZCh7XHJcbiAgICAgICAgZmFkZVRvOiBmdW5jdGlvbihlLCB0LCBuLCByKSB7IHJldHVybiB0aGlzLmZpbHRlcihhZSkuY3NzKFwib3BhY2l0eVwiLCAwKS5zaG93KCkuZW5kKCkuYW5pbWF0ZSh7IG9wYWNpdHk6IHQgfSwgZSwgbiwgcikgfSxcclxuICAgICAgICBhbmltYXRlOiBmdW5jdGlvbih0LCBlLCBuLCByKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gUy5pc0VtcHR5T2JqZWN0KHQpLFxyXG4gICAgICAgICAgICAgICAgbyA9IFMuc3BlZWQoZSwgbiwgciksXHJcbiAgICAgICAgICAgICAgICBhID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBsdCh0aGlzLCBTLmV4dGVuZCh7fSwgdCksIG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIChpIHx8IFkuZ2V0KHRoaXMsIFwiZmluaXNoXCIpKSAmJiBlLnN0b3AoITApXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gYS5maW5pc2ggPSBhLCBpIHx8ICExID09PSBvLnF1ZXVlID8gdGhpcy5lYWNoKGEpIDogdGhpcy5xdWV1ZShvLnF1ZXVlLCBhKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcDogZnVuY3Rpb24oaSwgZSwgbykge1xyXG4gICAgICAgICAgICB2YXIgYSA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gZS5zdG9wO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGUuc3RvcCwgdChvKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiAhPSB0eXBlb2YgaSAmJiAobyA9IGUsIGUgPSBpLCBpID0gdm9pZCAwKSwgZSAmJiB0aGlzLnF1ZXVlKGkgfHwgXCJmeFwiLCBbXSksIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gITAsXHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IG51bGwgIT0gaSAmJiBpICsgXCJxdWV1ZUhvb2tzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IFMudGltZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBZLmdldCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICh0KSByW3RdICYmIHJbdF0uc3RvcCAmJiBhKHJbdF0pO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodCBpbiByKSByW3RdICYmIHJbdF0uc3RvcCAmJiBpdC50ZXN0KHQpICYmIGEoclt0XSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHQgPSBuLmxlbmd0aDsgdC0tOykgblt0XS5lbGVtICE9PSB0aGlzIHx8IG51bGwgIT0gaSAmJiBuW3RdLnF1ZXVlICE9PSBpIHx8IChuW3RdLmFuaW0uc3RvcChvKSwgZSA9ICExLCBuLnNwbGljZSh0LCAxKSk7XHJcbiAgICAgICAgICAgICAgICAhZSAmJiBvIHx8IFMuZGVxdWV1ZSh0aGlzLCBpKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmluaXNoOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhMSAhPT0gYSAmJiAoYSA9IGEgfHwgXCJmeFwiKSwgdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUsIHQgPSBZLmdldCh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICBuID0gdFthICsgXCJxdWV1ZVwiXSxcclxuICAgICAgICAgICAgICAgICAgICByID0gdFthICsgXCJxdWV1ZUhvb2tzXCJdLFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBTLnRpbWVycyxcclxuICAgICAgICAgICAgICAgICAgICBvID0gbiA/IG4ubGVuZ3RoIDogMDtcclxuICAgICAgICAgICAgICAgIGZvciAodC5maW5pc2ggPSAhMCwgUy5xdWV1ZSh0aGlzLCBhLCBbXSksIHIgJiYgci5zdG9wICYmIHIuc3RvcC5jYWxsKHRoaXMsICEwKSwgZSA9IGkubGVuZ3RoOyBlLS07KSBpW2VdLmVsZW0gPT09IHRoaXMgJiYgaVtlXS5xdWV1ZSA9PT0gYSAmJiAoaVtlXS5hbmltLnN0b3AoITApLCBpLnNwbGljZShlLCAxKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGUgPSAwOyBlIDwgbzsgZSsrKSBuW2VdICYmIG5bZV0uZmluaXNoICYmIG5bZV0uZmluaXNoLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdC5maW5pc2hcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9KSwgUy5lYWNoKFtcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCJdLCBmdW5jdGlvbihlLCByKSB7XHJcbiAgICAgICAgdmFyIGkgPSBTLmZuW3JdO1xyXG4gICAgICAgIFMuZm5bcl0gPSBmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiBudWxsID09IGUgfHwgXCJib29sZWFuXCIgPT0gdHlwZW9mIGUgPyBpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzLmFuaW1hdGUoc3QociwgITApLCBlLCB0LCBuKSB9XHJcbiAgICB9KSwgUy5lYWNoKHsgc2xpZGVEb3duOiBzdChcInNob3dcIiksIHNsaWRlVXA6IHN0KFwiaGlkZVwiKSwgc2xpZGVUb2dnbGU6IHN0KFwidG9nZ2xlXCIpLCBmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSwgZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LCBmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfSB9LCBmdW5jdGlvbihlLCByKSB7IFMuZm5bZV0gPSBmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiB0aGlzLmFuaW1hdGUociwgZSwgdCwgbikgfSB9KSwgUy50aW1lcnMgPSBbXSwgUy5meC50aWNrID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGUsIHQgPSAwLFxyXG4gICAgICAgICAgICBuID0gUy50aW1lcnM7XHJcbiAgICAgICAgZm9yIChaZSA9IERhdGUubm93KCk7IHQgPCBuLmxlbmd0aDsgdCsrKShlID0gblt0XSkoKSB8fCBuW3RdICE9PSBlIHx8IG4uc3BsaWNlKHQtLSwgMSk7XHJcbiAgICAgICAgbi5sZW5ndGggfHwgUy5meC5zdG9wKCksIFplID0gdm9pZCAwXHJcbiAgICB9LCBTLmZ4LnRpbWVyID0gZnVuY3Rpb24oZSkgeyBTLnRpbWVycy5wdXNoKGUpLCBTLmZ4LnN0YXJ0KCkgfSwgUy5meC5pbnRlcnZhbCA9IDEzLCBTLmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7IGV0IHx8IChldCA9ICEwLCBvdCgpKSB9LCBTLmZ4LnN0b3AgPSBmdW5jdGlvbigpIHsgZXQgPSBudWxsIH0sIFMuZnguc3BlZWRzID0geyBzbG93OiA2MDAsIGZhc3Q6IDIwMCwgX2RlZmF1bHQ6IDQwMCB9LCBTLmZuLmRlbGF5ID0gZnVuY3Rpb24ociwgZSkge1xyXG4gICAgICAgIHJldHVybiByID0gUy5meCAmJiBTLmZ4LnNwZWVkc1tyXSB8fCByLCBlID0gZSB8fCBcImZ4XCIsIHRoaXMucXVldWUoZSwgZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IEMuc2V0VGltZW91dChlLCByKTtcclxuICAgICAgICAgICAgdC5zdG9wID0gZnVuY3Rpb24oKSB7IEMuY2xlYXJUaW1lb3V0KG4pIH1cclxuICAgICAgICB9KVxyXG4gICAgfSwgdHQgPSBFLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSwgbnQgPSBFLmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIikuYXBwZW5kQ2hpbGQoRS5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpKSwgdHQudHlwZSA9IFwiY2hlY2tib3hcIiwgeS5jaGVja09uID0gXCJcIiAhPT0gdHQudmFsdWUsIHkub3B0U2VsZWN0ZWQgPSBudC5zZWxlY3RlZCwgKHR0ID0gRS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikpLnZhbHVlID0gXCJ0XCIsIHR0LnR5cGUgPSBcInJhZGlvXCIsIHkucmFkaW9WYWx1ZSA9IFwidFwiID09PSB0dC52YWx1ZTtcclxuICAgIHZhciBjdCwgZnQgPSBTLmV4cHIuYXR0ckhhbmRsZTtcclxuICAgIFMuZm4uZXh0ZW5kKHsgYXR0cjogZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gJCh0aGlzLCBTLmF0dHIsIGUsIHQsIDEgPCBhcmd1bWVudHMubGVuZ3RoKSB9LCByZW1vdmVBdHRyOiBmdW5jdGlvbihlKSB7IHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IFMucmVtb3ZlQXR0cih0aGlzLCBlKSB9KSB9IH0pLCBTLmV4dGVuZCh7XHJcbiAgICAgICAgYXR0cjogZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgciwgaSwgbyA9IGUubm9kZVR5cGU7IGlmICgzICE9PSBvICYmIDggIT09IG8gJiYgMiAhPT0gbykgcmV0dXJuIFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIGUuZ2V0QXR0cmlidXRlID8gUy5wcm9wKGUsIHQsIG4pIDogKDEgPT09IG8gJiYgUy5pc1hNTERvYyhlKSB8fCAoaSA9IFMuYXR0ckhvb2tzW3QudG9Mb3dlckNhc2UoKV0gfHwgKFMuZXhwci5tYXRjaC5ib29sLnRlc3QodCkgPyBjdCA6IHZvaWQgMCkpLCB2b2lkIDAgIT09IG4gPyBudWxsID09PSBuID8gdm9pZCBTLnJlbW92ZUF0dHIoZSwgdCkgOiBpICYmIFwic2V0XCIgaW4gaSAmJiB2b2lkIDAgIT09IChyID0gaS5zZXQoZSwgbiwgdCkpID8gciA6IChlLnNldEF0dHJpYnV0ZSh0LCBuICsgXCJcIiksIG4pIDogaSAmJiBcImdldFwiIGluIGkgJiYgbnVsbCAhPT0gKHIgPSBpLmdldChlLCB0KSkgPyByIDogbnVsbCA9PSAociA9IFMuZmluZC5hdHRyKGUsIHQpKSA/IHZvaWQgMCA6IHIpIH0sXHJcbiAgICAgICAgYXR0ckhvb2tzOiB7IHR5cGU6IHsgc2V0OiBmdW5jdGlvbihlLCB0KSB7IGlmICgheS5yYWRpb1ZhbHVlICYmIFwicmFkaW9cIiA9PT0gdCAmJiBBKGUsIFwiaW5wdXRcIikpIHsgdmFyIG4gPSBlLnZhbHVlOyByZXR1cm4gZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIHQpLCBuICYmIChlLnZhbHVlID0gbiksIHQgfSB9IH0gfSxcclxuICAgICAgICByZW1vdmVBdHRyOiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgIHZhciBuLCByID0gMCxcclxuICAgICAgICAgICAgICAgIGkgPSB0ICYmIHQubWF0Y2goUCk7XHJcbiAgICAgICAgICAgIGlmIChpICYmIDEgPT09IGUubm9kZVR5cGUpXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA9IGlbcisrXSkgZS5yZW1vdmVBdHRyaWJ1dGUobilcclxuICAgICAgICB9XHJcbiAgICB9KSwgY3QgPSB7IHNldDogZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gITEgPT09IHQgPyBTLnJlbW92ZUF0dHIoZSwgbikgOiBlLnNldEF0dHJpYnV0ZShuLCBuKSwgbiB9IH0sIFMuZWFjaChTLmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goL1xcdysvZyksIGZ1bmN0aW9uKGUsIHQpIHtcclxuICAgICAgICB2YXIgYSA9IGZ0W3RdIHx8IFMuZmluZC5hdHRyO1xyXG4gICAgICAgIGZ0W3RdID0gZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgciwgaSwgbyA9IHQudG9Mb3dlckNhc2UoKTsgcmV0dXJuIG4gfHwgKGkgPSBmdFtvXSwgZnRbb10gPSByLCByID0gbnVsbCAhPSBhKGUsIHQsIG4pID8gbyA6IG51bGwsIGZ0W29dID0gaSksIHIgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgcHQgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxyXG4gICAgICAgIGR0ID0gL14oPzphfGFyZWEpJC9pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGh0KGUpIHsgcmV0dXJuIChlLm1hdGNoKFApIHx8IFtdKS5qb2luKFwiIFwiKSB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ3QoZSkgeyByZXR1cm4gZS5nZXRBdHRyaWJ1dGUgJiYgZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiIH1cclxuXHJcbiAgICBmdW5jdGlvbiB2dChlKSB7IHJldHVybiBBcnJheS5pc0FycmF5KGUpID8gZSA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgZS5tYXRjaChQKSB8fCBbXSB9XHJcbiAgICBTLmZuLmV4dGVuZCh7IHByb3A6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuICQodGhpcywgUy5wcm9wLCBlLCB0LCAxIDwgYXJndW1lbnRzLmxlbmd0aCkgfSwgcmVtb3ZlUHJvcDogZnVuY3Rpb24oZSkgeyByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyBkZWxldGUgdGhpc1tTLnByb3BGaXhbZV0gfHwgZV0gfSkgfSB9KSwgUy5leHRlbmQoeyBwcm9wOiBmdW5jdGlvbihlLCB0LCBuKSB7IHZhciByLCBpLCBvID0gZS5ub2RlVHlwZTsgaWYgKDMgIT09IG8gJiYgOCAhPT0gbyAmJiAyICE9PSBvKSByZXR1cm4gMSA9PT0gbyAmJiBTLmlzWE1MRG9jKGUpIHx8ICh0ID0gUy5wcm9wRml4W3RdIHx8IHQsIGkgPSBTLnByb3BIb29rc1t0XSksIHZvaWQgMCAhPT0gbiA/IGkgJiYgXCJzZXRcIiBpbiBpICYmIHZvaWQgMCAhPT0gKHIgPSBpLnNldChlLCBuLCB0KSkgPyByIDogZVt0XSA9IG4gOiBpICYmIFwiZ2V0XCIgaW4gaSAmJiBudWxsICE9PSAociA9IGkuZ2V0KGUsIHQpKSA/IHIgOiBlW3RdIH0sIHByb3BIb29rczogeyB0YWJJbmRleDogeyBnZXQ6IGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBTLmZpbmQuYXR0cihlLCBcInRhYmluZGV4XCIpOyByZXR1cm4gdCA/IHBhcnNlSW50KHQsIDEwKSA6IHB0LnRlc3QoZS5ub2RlTmFtZSkgfHwgZHQudGVzdChlLm5vZGVOYW1lKSAmJiBlLmhyZWYgPyAwIDogLTEgfSB9IH0sIHByb3BGaXg6IHsgXCJmb3JcIjogXCJodG1sRm9yXCIsIFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIiB9IH0pLCB5Lm9wdFNlbGVjdGVkIHx8IChTLnByb3BIb29rcy5zZWxlY3RlZCA9IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBlLnBhcmVudE5vZGU7IHJldHVybiB0ICYmIHQucGFyZW50Tm9kZSAmJiB0LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCwgbnVsbCB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IGUucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgdCAmJiAodC5zZWxlY3RlZEluZGV4LCB0LnBhcmVudE5vZGUgJiYgdC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgpXHJcbiAgICAgICAgfVxyXG4gICAgfSksIFMuZWFjaChbXCJ0YWJJbmRleFwiLCBcInJlYWRPbmx5XCIsIFwibWF4TGVuZ3RoXCIsIFwiY2VsbFNwYWNpbmdcIiwgXCJjZWxsUGFkZGluZ1wiLCBcInJvd1NwYW5cIiwgXCJjb2xTcGFuXCIsIFwidXNlTWFwXCIsIFwiZnJhbWVCb3JkZXJcIiwgXCJjb250ZW50RWRpdGFibGVcIl0sIGZ1bmN0aW9uKCkgeyBTLnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXSA9IHRoaXMgfSksIFMuZm4uZXh0ZW5kKHtcclxuICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24odCkge1xyXG4gICAgICAgICAgICB2YXIgZSwgbiwgciwgaSwgbywgYSwgcywgdSA9IDA7XHJcbiAgICAgICAgICAgIGlmIChtKHQpKSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGUpIHsgUyh0aGlzKS5hZGRDbGFzcyh0LmNhbGwodGhpcywgZSwgZ3QodGhpcykpKSB9KTtcclxuICAgICAgICAgICAgaWYgKChlID0gdnQodCkpLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuID0gdGhpc1t1KytdKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID0gZ3QobiksIHIgPSAxID09PSBuLm5vZGVUeXBlICYmIFwiIFwiICsgaHQoaSkgKyBcIiBcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG8gPSBlW2ErK10pIHIuaW5kZXhPZihcIiBcIiArIG8gKyBcIiBcIikgPCAwICYmIChyICs9IG8gKyBcIiBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgIT09IChzID0gaHQocikpICYmIG4uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgcylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24odCkge1xyXG4gICAgICAgICAgICB2YXIgZSwgbiwgciwgaSwgbywgYSwgcywgdSA9IDA7XHJcbiAgICAgICAgICAgIGlmIChtKHQpKSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGUpIHsgUyh0aGlzKS5yZW1vdmVDbGFzcyh0LmNhbGwodGhpcywgZSwgZ3QodGhpcykpKSB9KTtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5hdHRyKFwiY2xhc3NcIiwgXCJcIik7XHJcbiAgICAgICAgICAgIGlmICgoZSA9IHZ0KHQpKS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA9IHRoaXNbdSsrXSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9IGd0KG4pLCByID0gMSA9PT0gbi5ub2RlVHlwZSAmJiBcIiBcIiArIGh0KGkpICsgXCIgXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChvID0gZVthKytdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKC0xIDwgci5pbmRleE9mKFwiIFwiICsgbyArIFwiIFwiKSkgciA9IHIucmVwbGFjZShcIiBcIiArIG8gKyBcIiBcIiwgXCIgXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpICE9PSAocyA9IGh0KHIpKSAmJiBuLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHMpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKGksIHQpIHtcclxuICAgICAgICAgICAgdmFyIG8gPSB0eXBlb2YgaSxcclxuICAgICAgICAgICAgICAgIGEgPSBcInN0cmluZ1wiID09PSBvIHx8IEFycmF5LmlzQXJyYXkoaSk7XHJcbiAgICAgICAgICAgIHJldHVybiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgdCAmJiBhID8gdCA/IHRoaXMuYWRkQ2xhc3MoaSkgOiB0aGlzLnJlbW92ZUNsYXNzKGkpIDogbShpKSA/IHRoaXMuZWFjaChmdW5jdGlvbihlKSB7IFModGhpcykudG9nZ2xlQ2xhc3MoaS5jYWxsKHRoaXMsIGUsIGd0KHRoaXMpLCB0KSwgdCkgfSkgOiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IHZhciBlLCB0LCBuLCByOyBpZiAoYSkgeyB0ID0gMCwgbiA9IFModGhpcyksIHIgPSB2dChpKTsgd2hpbGUgKGUgPSByW3QrK10pIG4uaGFzQ2xhc3MoZSkgPyBuLnJlbW92ZUNsYXNzKGUpIDogbi5hZGRDbGFzcyhlKSB9IGVsc2Ugdm9pZCAwICE9PSBpICYmIFwiYm9vbGVhblwiICE9PSBvIHx8ICgoZSA9IGd0KHRoaXMpKSAmJiBZLnNldCh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgZSksIHRoaXMuc2V0QXR0cmlidXRlICYmIHRoaXMuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZSB8fCAhMSA9PT0gaSA/IFwiXCIgOiBZLmdldCh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIikgfHwgXCJcIikpIH0pXHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgdCwgbiwgciA9IDA7XHJcbiAgICAgICAgICAgIHQgPSBcIiBcIiArIGUgKyBcIiBcIjtcclxuICAgICAgICAgICAgd2hpbGUgKG4gPSB0aGlzW3IrK10pXHJcbiAgICAgICAgICAgICAgICBpZiAoMSA9PT0gbi5ub2RlVHlwZSAmJiAtMSA8IChcIiBcIiArIGh0KGd0KG4pKSArIFwiIFwiKS5pbmRleE9mKHQpKSByZXR1cm4gITA7XHJcbiAgICAgICAgICAgIHJldHVybiAhMVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIHl0ID0gL1xcci9nO1xyXG4gICAgUy5mbi5leHRlbmQoe1xyXG4gICAgICAgIHZhbDogZnVuY3Rpb24obikge1xyXG4gICAgICAgICAgICB2YXIgciwgZSwgaSwgdCA9IHRoaXNbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGkgPSBtKG4pLCB0aGlzLmVhY2goZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQ7XHJcbiAgICAgICAgICAgICAgICAxID09PSB0aGlzLm5vZGVUeXBlICYmIChudWxsID09ICh0ID0gaSA/IG4uY2FsbCh0aGlzLCBlLCBTKHRoaXMpLnZhbCgpKSA6IG4pID8gdCA9IFwiXCIgOiBcIm51bWJlclwiID09IHR5cGVvZiB0ID8gdCArPSBcIlwiIDogQXJyYXkuaXNBcnJheSh0KSAmJiAodCA9IFMubWFwKHQsIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIG51bGwgPT0gZSA/IFwiXCIgOiBlICsgXCJcIiB9KSksIChyID0gUy52YWxIb29rc1t0aGlzLnR5cGVdIHx8IFMudmFsSG9va3NbdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkgJiYgXCJzZXRcIiBpbiByICYmIHZvaWQgMCAhPT0gci5zZXQodGhpcywgdCwgXCJ2YWx1ZVwiKSB8fCAodGhpcy52YWx1ZSA9IHQpKVxyXG4gICAgICAgICAgICB9KSkgOiB0ID8gKHIgPSBTLnZhbEhvb2tzW3QudHlwZV0gfHwgUy52YWxIb29rc1t0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSAmJiBcImdldFwiIGluIHIgJiYgdm9pZCAwICE9PSAoZSA9IHIuZ2V0KHQsIFwidmFsdWVcIikpID8gZSA6IFwic3RyaW5nXCIgPT0gdHlwZW9mKGUgPSB0LnZhbHVlKSA/IGUucmVwbGFjZSh5dCwgXCJcIikgOiBudWxsID09IGUgPyBcIlwiIDogZSA6IHZvaWQgMFxyXG4gICAgICAgIH1cclxuICAgIH0pLCBTLmV4dGVuZCh7XHJcbiAgICAgICAgdmFsSG9va3M6IHtcclxuICAgICAgICAgICAgb3B0aW9uOiB7IGdldDogZnVuY3Rpb24oZSkgeyB2YXIgdCA9IFMuZmluZC5hdHRyKGUsIFwidmFsdWVcIik7IHJldHVybiBudWxsICE9IHQgPyB0IDogaHQoUy50ZXh0KGUpKSB9IH0sXHJcbiAgICAgICAgICAgIHNlbGVjdDoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQsIG4sIHIsIGkgPSBlLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBlLnNlbGVjdGVkSW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBcInNlbGVjdC1vbmVcIiA9PT0gZS50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gYSA/IG51bGwgOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdSA9IGEgPyBvICsgMSA6IGkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAociA9IG8gPCAwID8gdSA6IGEgPyBvIDogMDsgciA8IHU7IHIrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgobiA9IGlbcl0pLnNlbGVjdGVkIHx8IHIgPT09IG8pICYmICFuLmRpc2FibGVkICYmICghbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFBKG4ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID0gUyhuKS52YWwoKSwgYSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnB1c2godClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4sIHIsIGkgPSBlLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBTLm1ha2VBcnJheSh0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhLS0pKChyID0gaVthXSkuc2VsZWN0ZWQgPSAtMSA8IFMuaW5BcnJheShTLnZhbEhvb2tzLm9wdGlvbi5nZXQociksIG8pKSAmJiAobiA9ICEwKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiB8fCAoZS5zZWxlY3RlZEluZGV4ID0gLTEpLCBvXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KSwgUy5lYWNoKFtcInJhZGlvXCIsIFwiY2hlY2tib3hcIl0sIGZ1bmN0aW9uKCkgeyBTLnZhbEhvb2tzW3RoaXNdID0geyBzZXQ6IGZ1bmN0aW9uKGUsIHQpIHsgaWYgKEFycmF5LmlzQXJyYXkodCkpIHJldHVybiBlLmNoZWNrZWQgPSAtMSA8IFMuaW5BcnJheShTKGUpLnZhbCgpLCB0KSB9IH0sIHkuY2hlY2tPbiB8fCAoUy52YWxIb29rc1t0aGlzXS5nZXQgPSBmdW5jdGlvbihlKSB7IHJldHVybiBudWxsID09PSBlLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID8gXCJvblwiIDogZS52YWx1ZSB9KSB9KSwgeS5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiBDO1xyXG4gICAgdmFyIG10ID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxyXG4gICAgICAgIHh0ID0gZnVuY3Rpb24oZSkgeyBlLnN0b3BQcm9wYWdhdGlvbigpIH07XHJcbiAgICBTLmV4dGVuZChTLmV2ZW50LCB7XHJcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oZSwgdCwgbiwgcikge1xyXG4gICAgICAgICAgICB2YXIgaSwgbywgYSwgcywgdSwgbCwgYywgZiwgcCA9IFtuIHx8IEVdLFxyXG4gICAgICAgICAgICAgICAgZCA9IHYuY2FsbChlLCBcInR5cGVcIikgPyBlLnR5cGUgOiBlLFxyXG4gICAgICAgICAgICAgICAgaCA9IHYuY2FsbChlLCBcIm5hbWVzcGFjZVwiKSA/IGUubmFtZXNwYWNlLnNwbGl0KFwiLlwiKSA6IFtdO1xyXG4gICAgICAgICAgICBpZiAobyA9IGYgPSBhID0gbiA9IG4gfHwgRSwgMyAhPT0gbi5ub2RlVHlwZSAmJiA4ICE9PSBuLm5vZGVUeXBlICYmICFtdC50ZXN0KGQgKyBTLmV2ZW50LnRyaWdnZXJlZCkgJiYgKC0xIDwgZC5pbmRleE9mKFwiLlwiKSAmJiAoZCA9IChoID0gZC5zcGxpdChcIi5cIikpLnNoaWZ0KCksIGguc29ydCgpKSwgdSA9IGQuaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIGQsIChlID0gZVtTLmV4cGFuZG9dID8gZSA6IG5ldyBTLkV2ZW50KGQsIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgZSkpLmlzVHJpZ2dlciA9IHIgPyAyIDogMywgZS5uYW1lc3BhY2UgPSBoLmpvaW4oXCIuXCIpLCBlLnJuYW1lc3BhY2UgPSBlLm5hbWVzcGFjZSA/IG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIGguam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIikgOiBudWxsLCBlLnJlc3VsdCA9IHZvaWQgMCwgZS50YXJnZXQgfHwgKGUudGFyZ2V0ID0gbiksIHQgPSBudWxsID09IHQgPyBbZV0gOiBTLm1ha2VBcnJheSh0LCBbZV0pLCBjID0gUy5ldmVudC5zcGVjaWFsW2RdIHx8IHt9LCByIHx8ICFjLnRyaWdnZXIgfHwgITEgIT09IGMudHJpZ2dlci5hcHBseShuLCB0KSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghciAmJiAhYy5ub0J1YmJsZSAmJiAheChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAocyA9IGMuZGVsZWdhdGVUeXBlIHx8IGQsIG10LnRlc3QocyArIGQpIHx8IChvID0gby5wYXJlbnROb2RlKTsgbzsgbyA9IG8ucGFyZW50Tm9kZSkgcC5wdXNoKG8pLCBhID0gbztcclxuICAgICAgICAgICAgICAgICAgICBhID09PSAobi5vd25lckRvY3VtZW50IHx8IEUpICYmIHAucHVzaChhLmRlZmF1bHRWaWV3IHx8IGEucGFyZW50V2luZG93IHx8IEMpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgobyA9IHBbaSsrXSkgJiYgIWUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkgZiA9IG8sIGUudHlwZSA9IDEgPCBpID8gcyA6IGMuYmluZFR5cGUgfHwgZCwgKGwgPSAoWS5nZXQobywgXCJldmVudHNcIikgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSlbZS50eXBlXSAmJiBZLmdldChvLCBcImhhbmRsZVwiKSkgJiYgbC5hcHBseShvLCB0KSwgKGwgPSB1ICYmIG9bdV0pICYmIGwuYXBwbHkgJiYgVihvKSAmJiAoZS5yZXN1bHQgPSBsLmFwcGx5KG8sIHQpLCAhMSA9PT0gZS5yZXN1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlLnR5cGUgPSBkLCByIHx8IGUuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgYy5fZGVmYXVsdCAmJiAhMSAhPT0gYy5fZGVmYXVsdC5hcHBseShwLnBvcCgpLCB0KSB8fCAhVihuKSB8fCB1ICYmIG0obltkXSkgJiYgIXgobikgJiYgKChhID0gblt1XSkgJiYgKG5bdV0gPSBudWxsKSwgUy5ldmVudC50cmlnZ2VyZWQgPSBkLCBlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgJiYgZi5hZGRFdmVudExpc3RlbmVyKGQsIHh0KSwgbltkXSgpLCBlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgJiYgZi5yZW1vdmVFdmVudExpc3RlbmVyKGQsIHh0KSwgUy5ldmVudC50cmlnZ2VyZWQgPSB2b2lkIDAsIGEgJiYgKG5bdV0gPSBhKSksIGUucmVzdWx0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNpbXVsYXRlOiBmdW5jdGlvbihlLCB0LCBuKSB7XHJcbiAgICAgICAgICAgIHZhciByID0gUy5leHRlbmQobmV3IFMuRXZlbnQsIG4sIHsgdHlwZTogZSwgaXNTaW11bGF0ZWQ6ICEwIH0pO1xyXG4gICAgICAgICAgICBTLmV2ZW50LnRyaWdnZXIociwgbnVsbCwgdClcclxuICAgICAgICB9XHJcbiAgICB9KSwgUy5mbi5leHRlbmQoeyB0cmlnZ2VyOiBmdW5jdGlvbihlLCB0KSB7IHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IFMuZXZlbnQudHJpZ2dlcihlLCB0LCB0aGlzKSB9KSB9LCB0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiA9IHRoaXNbMF07IGlmIChuKSByZXR1cm4gUy5ldmVudC50cmlnZ2VyKGUsIHQsIG4sICEwKSB9IH0pLCB5LmZvY3VzaW4gfHwgUy5lYWNoKHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24obiwgcikge1xyXG4gICAgICAgIHZhciBpID0gZnVuY3Rpb24oZSkgeyBTLmV2ZW50LnNpbXVsYXRlKHIsIGUudGFyZ2V0LCBTLmV2ZW50LmZpeChlKSkgfTtcclxuICAgICAgICBTLmV2ZW50LnNwZWNpYWxbcl0gPSB7XHJcbiAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICB0ID0gWS5hY2Nlc3MoZSwgcik7XHJcbiAgICAgICAgICAgICAgICB0IHx8IGUuYWRkRXZlbnRMaXN0ZW5lcihuLCBpLCAhMCksIFkuYWNjZXNzKGUsIHIsICh0IHx8IDApICsgMSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSBZLmFjY2VzcyhlLCByKSAtIDE7XHJcbiAgICAgICAgICAgICAgICB0ID8gWS5hY2Nlc3MoZSwgciwgdCkgOiAoZS5yZW1vdmVFdmVudExpc3RlbmVyKG4sIGksICEwKSwgWS5yZW1vdmUoZSwgcikpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZhciBidCA9IEMubG9jYXRpb24sXHJcbiAgICAgICAgd3QgPSB7IGd1aWQ6IERhdGUubm93KCkgfSxcclxuICAgICAgICBUdCA9IC9cXD8vO1xyXG4gICAgUy5wYXJzZVhNTCA9IGZ1bmN0aW9uKGUpIHsgdmFyIHQsIG47IGlmICghZSB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiBlKSByZXR1cm4gbnVsbDsgdHJ5IHsgdCA9IChuZXcgQy5ET01QYXJzZXIpLnBhcnNlRnJvbVN0cmluZyhlLCBcInRleHQveG1sXCIpIH0gY2F0Y2ggKGUpIHt9IHJldHVybiBuID0gdCAmJiB0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIilbMF0sIHQgJiYgIW4gfHwgUy5lcnJvcihcIkludmFsaWQgWE1MOiBcIiArIChuID8gUy5tYXAobi5jaGlsZE5vZGVzLCBmdW5jdGlvbihlKSB7IHJldHVybiBlLnRleHRDb250ZW50IH0pLmpvaW4oXCJcXG5cIikgOiBlKSksIHQgfTtcclxuICAgIHZhciBDdCA9IC9cXFtcXF0kLyxcclxuICAgICAgICBFdCA9IC9cXHI/XFxuL2csXHJcbiAgICAgICAgU3QgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXHJcbiAgICAgICAga3QgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XHJcblxyXG4gICAgZnVuY3Rpb24gQXQobiwgZSwgciwgaSkge1xyXG4gICAgICAgIHZhciB0O1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSBTLmVhY2goZSwgZnVuY3Rpb24oZSwgdCkgeyByIHx8IEN0LnRlc3QobikgPyBpKG4sIHQpIDogQXQobiArIFwiW1wiICsgKFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgJiYgbnVsbCAhPSB0ID8gZSA6IFwiXCIpICsgXCJdXCIsIHQsIHIsIGkpIH0pO1xyXG4gICAgICAgIGVsc2UgaWYgKHIgfHwgXCJvYmplY3RcIiAhPT0gdyhlKSkgaShuLCBlKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGZvciAodCBpbiBlKSBBdChuICsgXCJbXCIgKyB0ICsgXCJdXCIsIGVbdF0sIHIsIGkpXHJcbiAgICB9XHJcbiAgICBTLnBhcmFtID0gZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgICAgIHZhciBuLCByID0gW10sXHJcbiAgICAgICAgICAgIGkgPSBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IG0odCkgPyB0KCkgOiB0O1xyXG4gICAgICAgICAgICAgICAgcltyLmxlbmd0aF0gPSBlbmNvZGVVUklDb21wb25lbnQoZSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChudWxsID09IG4gPyBcIlwiIDogbilcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBpZiAobnVsbCA9PSBlKSByZXR1cm4gXCJcIjtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSB8fCBlLmpxdWVyeSAmJiAhUy5pc1BsYWluT2JqZWN0KGUpKSBTLmVhY2goZSwgZnVuY3Rpb24oKSB7IGkodGhpcy5uYW1lLCB0aGlzLnZhbHVlKSB9KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGZvciAobiBpbiBlKSBBdChuLCBlW25dLCB0LCBpKTtcclxuICAgICAgICByZXR1cm4gci5qb2luKFwiJlwiKVxyXG4gICAgfSwgUy5mbi5leHRlbmQoeyBzZXJpYWxpemU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gUy5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpIH0sIHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkgeyB2YXIgZSA9IFMucHJvcCh0aGlzLCBcImVsZW1lbnRzXCIpOyByZXR1cm4gZSA/IFMubWFrZUFycmF5KGUpIDogdGhpcyB9KS5maWx0ZXIoZnVuY3Rpb24oKSB7IHZhciBlID0gdGhpcy50eXBlOyByZXR1cm4gdGhpcy5uYW1lICYmICFTKHRoaXMpLmlzKFwiOmRpc2FibGVkXCIpICYmIGt0LnRlc3QodGhpcy5ub2RlTmFtZSkgJiYgIVN0LnRlc3QoZSkgJiYgKHRoaXMuY2hlY2tlZCB8fCAhcGUudGVzdChlKSkgfSkubWFwKGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4gPSBTKHRoaXMpLnZhbCgpOyByZXR1cm4gbnVsbCA9PSBuID8gbnVsbCA6IEFycmF5LmlzQXJyYXkobikgPyBTLm1hcChuLCBmdW5jdGlvbihlKSB7IHJldHVybiB7IG5hbWU6IHQubmFtZSwgdmFsdWU6IGUucmVwbGFjZShFdCwgXCJcXHJcXG5cIikgfSB9KSA6IHsgbmFtZTogdC5uYW1lLCB2YWx1ZTogbi5yZXBsYWNlKEV0LCBcIlxcclxcblwiKSB9IH0pLmdldCgpIH0gfSk7XHJcbiAgICB2YXIgTnQgPSAvJTIwL2csXHJcbiAgICAgICAganQgPSAvIy4qJC8sXHJcbiAgICAgICAgRHQgPSAvKFs/Jl0pXz1bXiZdKi8sXHJcbiAgICAgICAgcXQgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL2dtLFxyXG4gICAgICAgIEx0ID0gL14oPzpHRVR8SEVBRCkkLyxcclxuICAgICAgICBIdCA9IC9eXFwvXFwvLyxcclxuICAgICAgICBPdCA9IHt9LFxyXG4gICAgICAgIFB0ID0ge30sXHJcbiAgICAgICAgUnQgPSBcIiovXCIuY29uY2F0KFwiKlwiKSxcclxuICAgICAgICBNdCA9IEUuY3JlYXRlRWxlbWVudChcImFcIik7XHJcblxyXG4gICAgZnVuY3Rpb24gSXQobykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgJiYgKHQgPSBlLCBlID0gXCIqXCIpO1xyXG4gICAgICAgICAgICB2YXIgbiwgciA9IDAsXHJcbiAgICAgICAgICAgICAgICBpID0gZS50b0xvd2VyQ2FzZSgpLm1hdGNoKFApIHx8IFtdO1xyXG4gICAgICAgICAgICBpZiAobSh0KSlcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuID0gaVtyKytdKSBcIitcIiA9PT0gblswXSA/IChuID0gbi5zbGljZSgxKSB8fCBcIipcIiwgKG9bbl0gPSBvW25dIHx8IFtdKS51bnNoaWZ0KHQpKSA6IChvW25dID0gb1tuXSB8fCBbXSkucHVzaCh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBXdCh0LCBpLCBvLCBhKSB7XHJcbiAgICAgICAgdmFyIHMgPSB7fSxcclxuICAgICAgICAgICAgdSA9IHQgPT09IFB0O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBsKGUpIHsgdmFyIHI7IHJldHVybiBzW2VdID0gITAsIFMuZWFjaCh0W2VdIHx8IFtdLCBmdW5jdGlvbihlLCB0KSB7IHZhciBuID0gdChpLCBvLCBhKTsgcmV0dXJuIFwic3RyaW5nXCIgIT0gdHlwZW9mIG4gfHwgdSB8fCBzW25dID8gdSA/ICEociA9IG4pIDogdm9pZCAwIDogKGkuZGF0YVR5cGVzLnVuc2hpZnQobiksIGwobiksICExKSB9KSwgciB9XHJcbiAgICAgICAgcmV0dXJuIGwoaS5kYXRhVHlwZXNbMF0pIHx8ICFzW1wiKlwiXSAmJiBsKFwiKlwiKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEZ0KGUsIHQpIHsgdmFyIG4sIHIsIGkgPSBTLmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTsgZm9yIChuIGluIHQpIHZvaWQgMCAhPT0gdFtuXSAmJiAoKGlbbl0gPyBlIDogciB8fCAociA9IHt9KSlbbl0gPSB0W25dKTsgcmV0dXJuIHIgJiYgUy5leHRlbmQoITAsIGUsIHIpLCBlIH1cclxuICAgIE10LmhyZWYgPSBidC5ocmVmLCBTLmV4dGVuZCh7XHJcbiAgICAgICAgYWN0aXZlOiAwLFxyXG4gICAgICAgIGxhc3RNb2RpZmllZDoge30sXHJcbiAgICAgICAgZXRhZzoge30sXHJcbiAgICAgICAgYWpheFNldHRpbmdzOiB7IHVybDogYnQuaHJlZiwgdHlwZTogXCJHRVRcIiwgaXNMb2NhbDogL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8udGVzdChidC5wcm90b2NvbCksIGdsb2JhbDogITAsIHByb2Nlc3NEYXRhOiAhMCwgYXN5bmM6ICEwLCBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIiwgYWNjZXB0czogeyBcIipcIjogUnQsIHRleHQ6IFwidGV4dC9wbGFpblwiLCBodG1sOiBcInRleHQvaHRtbFwiLCB4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLCBqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiIH0sIGNvbnRlbnRzOiB7IHhtbDogL1xcYnhtbFxcYi8sIGh0bWw6IC9cXGJodG1sLywganNvbjogL1xcYmpzb25cXGIvIH0sIHJlc3BvbnNlRmllbGRzOiB7IHhtbDogXCJyZXNwb25zZVhNTFwiLCB0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLCBqc29uOiBcInJlc3BvbnNlSlNPTlwiIH0sIGNvbnZlcnRlcnM6IHsgXCIqIHRleHRcIjogU3RyaW5nLCBcInRleHQgaHRtbFwiOiAhMCwgXCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSwgXCJ0ZXh0IHhtbFwiOiBTLnBhcnNlWE1MIH0sIGZsYXRPcHRpb25zOiB7IHVybDogITAsIGNvbnRleHQ6ICEwIH0gfSxcclxuICAgICAgICBhamF4U2V0dXA6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHQgPyBGdChGdChlLCBTLmFqYXhTZXR0aW5ncyksIHQpIDogRnQoUy5hamF4U2V0dGluZ3MsIGUpIH0sXHJcbiAgICAgICAgYWpheFByZWZpbHRlcjogSXQoT3QpLFxyXG4gICAgICAgIGFqYXhUcmFuc3BvcnQ6IEl0KFB0KSxcclxuICAgICAgICBhamF4OiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgKHQgPSBlLCBlID0gdm9pZCAwKSwgdCA9IHQgfHwge307XHJcbiAgICAgICAgICAgIHZhciBjLCBmLCBwLCBuLCBkLCByLCBoLCBnLCBpLCBvLCB2ID0gUy5hamF4U2V0dXAoe30sIHQpLFxyXG4gICAgICAgICAgICAgICAgeSA9IHYuY29udGV4dCB8fCB2LFxyXG4gICAgICAgICAgICAgICAgbSA9IHYuY29udGV4dCAmJiAoeS5ub2RlVHlwZSB8fCB5LmpxdWVyeSkgPyBTKHkpIDogUy5ldmVudCxcclxuICAgICAgICAgICAgICAgIHggPSBTLkRlZmVycmVkKCksXHJcbiAgICAgICAgICAgICAgICBiID0gUy5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcclxuICAgICAgICAgICAgICAgIHcgPSB2LnN0YXR1c0NvZGUgfHwge30sXHJcbiAgICAgICAgICAgICAgICBhID0ge30sXHJcbiAgICAgICAgICAgICAgICBzID0ge30sXHJcbiAgICAgICAgICAgICAgICB1ID0gXCJjYW5jZWxlZFwiLFxyXG4gICAgICAgICAgICAgICAgVCA9IHtcclxuICAgICAgICAgICAgICAgICAgICByZWFkeVN0YXRlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuKSB7IG4gPSB7fTsgd2hpbGUgKHQgPSBxdC5leGVjKHApKSBuW3RbMV0udG9Mb3dlckNhc2UoKSArIFwiIFwiXSA9IChuW3RbMV0udG9Mb3dlckNhc2UoKSArIFwiIFwiXSB8fCBbXSkuY29uY2F0KHRbMl0pIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBuW2UudG9Mb3dlckNhc2UoKSArIFwiIFwiXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsID09IHQgPyBudWxsIDogdC5qb2luKFwiLCBcIilcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7IHJldHVybiBoID8gcCA6IG51bGwgfSxcclxuICAgICAgICAgICAgICAgICAgICBzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbihlLCB0KSB7IHJldHVybiBudWxsID09IGggJiYgKGUgPSBzW2UudG9Mb3dlckNhc2UoKV0gPSBzW2UudG9Mb3dlckNhc2UoKV0gfHwgZSwgYVtlXSA9IHQpLCB0aGlzIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gbnVsbCA9PSBoICYmICh2Lm1pbWVUeXBlID0gZSksIHRoaXMgfSxcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoKSBULmFsd2F5cyhlW1Quc3RhdHVzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh0IGluIGUpIHdbdF0gPSBbd1t0XSwgZVt0XV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24oZSkgeyB2YXIgdCA9IGUgfHwgdTsgcmV0dXJuIGMgJiYgYy5hYm9ydCh0KSwgbCgwLCB0KSwgdGhpcyB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoeC5wcm9taXNlKFQpLCB2LnVybCA9ICgoZSB8fCB2LnVybCB8fCBidC5ocmVmKSArIFwiXCIpLnJlcGxhY2UoSHQsIGJ0LnByb3RvY29sICsgXCIvL1wiKSwgdi50eXBlID0gdC5tZXRob2QgfHwgdC50eXBlIHx8IHYubWV0aG9kIHx8IHYudHlwZSwgdi5kYXRhVHlwZXMgPSAodi5kYXRhVHlwZSB8fCBcIipcIikudG9Mb3dlckNhc2UoKS5tYXRjaChQKSB8fCBbXCJcIl0sIG51bGwgPT0gdi5jcm9zc0RvbWFpbikgeyByID0gRS5jcmVhdGVFbGVtZW50KFwiYVwiKTsgdHJ5IHsgci5ocmVmID0gdi51cmwsIHIuaHJlZiA9IHIuaHJlZiwgdi5jcm9zc0RvbWFpbiA9IE10LnByb3RvY29sICsgXCIvL1wiICsgTXQuaG9zdCAhPSByLnByb3RvY29sICsgXCIvL1wiICsgci5ob3N0IH0gY2F0Y2ggKGUpIHsgdi5jcm9zc0RvbWFpbiA9ICEwIH0gfVxyXG4gICAgICAgICAgICBpZiAodi5kYXRhICYmIHYucHJvY2Vzc0RhdGEgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2Ygdi5kYXRhICYmICh2LmRhdGEgPSBTLnBhcmFtKHYuZGF0YSwgdi50cmFkaXRpb25hbCkpLCBXdChPdCwgdiwgdCwgVCksIGgpIHJldHVybiBUO1xyXG4gICAgICAgICAgICBmb3IgKGkgaW4gKGcgPSBTLmV2ZW50ICYmIHYuZ2xvYmFsKSAmJiAwID09IFMuYWN0aXZlKysgJiYgUy5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpLCB2LnR5cGUgPSB2LnR5cGUudG9VcHBlckNhc2UoKSwgdi5oYXNDb250ZW50ID0gIUx0LnRlc3Qodi50eXBlKSwgZiA9IHYudXJsLnJlcGxhY2UoanQsIFwiXCIpLCB2Lmhhc0NvbnRlbnQgPyB2LmRhdGEgJiYgdi5wcm9jZXNzRGF0YSAmJiAwID09PSAodi5jb250ZW50VHlwZSB8fCBcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmICh2LmRhdGEgPSB2LmRhdGEucmVwbGFjZShOdCwgXCIrXCIpKSA6IChvID0gdi51cmwuc2xpY2UoZi5sZW5ndGgpLCB2LmRhdGEgJiYgKHYucHJvY2Vzc0RhdGEgfHwgXCJzdHJpbmdcIiA9PSB0eXBlb2Ygdi5kYXRhKSAmJiAoZiArPSAoVHQudGVzdChmKSA/IFwiJlwiIDogXCI/XCIpICsgdi5kYXRhLCBkZWxldGUgdi5kYXRhKSwgITEgPT09IHYuY2FjaGUgJiYgKGYgPSBmLnJlcGxhY2UoRHQsIFwiJDFcIiksIG8gPSAoVHQudGVzdChmKSA/IFwiJlwiIDogXCI/XCIpICsgXCJfPVwiICsgd3QuZ3VpZCsrICsgbyksIHYudXJsID0gZiArIG8pLCB2LmlmTW9kaWZpZWQgJiYgKFMubGFzdE1vZGlmaWVkW2ZdICYmIFQuc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIsIFMubGFzdE1vZGlmaWVkW2ZdKSwgUy5ldGFnW2ZdICYmIFQuc2V0UmVxdWVzdEhlYWRlcihcIklmLU5vbmUtTWF0Y2hcIiwgUy5ldGFnW2ZdKSksICh2LmRhdGEgJiYgdi5oYXNDb250ZW50ICYmICExICE9PSB2LmNvbnRlbnRUeXBlIHx8IHQuY29udGVudFR5cGUpICYmIFQuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCB2LmNvbnRlbnRUeXBlKSwgVC5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIHYuZGF0YVR5cGVzWzBdICYmIHYuYWNjZXB0c1t2LmRhdGFUeXBlc1swXV0gPyB2LmFjY2VwdHNbdi5kYXRhVHlwZXNbMF1dICsgKFwiKlwiICE9PSB2LmRhdGFUeXBlc1swXSA/IFwiLCBcIiArIFJ0ICsgXCI7IHE9MC4wMVwiIDogXCJcIikgOiB2LmFjY2VwdHNbXCIqXCJdKSwgdi5oZWFkZXJzKSBULnNldFJlcXVlc3RIZWFkZXIoaSwgdi5oZWFkZXJzW2ldKTtcclxuICAgICAgICAgICAgaWYgKHYuYmVmb3JlU2VuZCAmJiAoITEgPT09IHYuYmVmb3JlU2VuZC5jYWxsKHksIFQsIHYpIHx8IGgpKSByZXR1cm4gVC5hYm9ydCgpO1xyXG4gICAgICAgICAgICBpZiAodSA9IFwiYWJvcnRcIiwgYi5hZGQodi5jb21wbGV0ZSksIFQuZG9uZSh2LnN1Y2Nlc3MpLCBULmZhaWwodi5lcnJvciksIGMgPSBXdChQdCwgdiwgdCwgVCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChULnJlYWR5U3RhdGUgPSAxLCBnICYmIG0udHJpZ2dlcihcImFqYXhTZW5kXCIsIFtULCB2XSksIGgpIHJldHVybiBUO1xyXG4gICAgICAgICAgICAgICAgdi5hc3luYyAmJiAwIDwgdi50aW1lb3V0ICYmIChkID0gQy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBULmFib3J0KFwidGltZW91dFwiKSB9LCB2LnRpbWVvdXQpKTtcclxuICAgICAgICAgICAgICAgIHRyeSB7IGggPSAhMSwgYy5zZW5kKGEsIGwpIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaCkgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICBsKC0xLCBlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgbCgtMSwgXCJObyBUcmFuc3BvcnRcIik7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBsKGUsIHQsIG4sIHIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpLCBvLCBhLCBzLCB1LCBsID0gdDtcclxuICAgICAgICAgICAgICAgIGggfHwgKGggPSAhMCwgZCAmJiBDLmNsZWFyVGltZW91dChkKSwgYyA9IHZvaWQgMCwgcCA9IHIgfHwgXCJcIiwgVC5yZWFkeVN0YXRlID0gMCA8IGUgPyA0IDogMCwgaSA9IDIwMCA8PSBlICYmIGUgPCAzMDAgfHwgMzA0ID09PSBlLCBuICYmIChzID0gZnVuY3Rpb24oZSwgdCwgbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByLCBpLCBvLCBhLCBzID0gZS5jb250ZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdSA9IGUuZGF0YVR5cGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChcIipcIiA9PT0gdVswXSkgdS5zaGlmdCgpLCB2b2lkIDAgPT09IHIgJiYgKHIgPSBlLm1pbWVUeXBlIHx8IHQuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzW2ldICYmIHNbaV0udGVzdChyKSkgeyB1LnVuc2hpZnQoaSk7IGJyZWFrIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodVswXSBpbiBuKSBvID0gdVswXTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIG4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdVswXSB8fCBlLmNvbnZlcnRlcnNbaSArIFwiIFwiICsgdVswXV0pIHsgbyA9IGk7IGJyZWFrIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgfHwgKGEgPSBpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBvIHx8IGFcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8pIHJldHVybiBvICE9PSB1WzBdICYmIHUudW5zaGlmdChvKSwgbltvXVxyXG4gICAgICAgICAgICAgICAgfSh2LCBULCBuKSksICFpICYmIC0xIDwgUy5pbkFycmF5KFwic2NyaXB0XCIsIHYuZGF0YVR5cGVzKSAmJiBTLmluQXJyYXkoXCJqc29uXCIsIHYuZGF0YVR5cGVzKSA8IDAgJiYgKHYuY29udmVydGVyc1tcInRleHQgc2NyaXB0XCJdID0gZnVuY3Rpb24oKSB7fSksIHMgPSBmdW5jdGlvbihlLCB0LCBuLCByKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIG8sIGEsIHMsIHUsIGwgPSB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGUuZGF0YVR5cGVzLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNbMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYSBpbiBlLmNvbnZlcnRlcnMpIGxbYS50b0xvd2VyQ2FzZSgpXSA9IGUuY29udmVydGVyc1thXTtcclxuICAgICAgICAgICAgICAgICAgICBvID0gYy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5yZXNwb25zZUZpZWxkc1tvXSAmJiAobltlLnJlc3BvbnNlRmllbGRzW29dXSA9IHQpLCAhdSAmJiByICYmIGUuZGF0YUZpbHRlciAmJiAodCA9IGUuZGF0YUZpbHRlcih0LCBlLmRhdGFUeXBlKSksIHUgPSBvLCBvID0gYy5zaGlmdCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiKlwiID09PSBvKSBvID0gdTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiKlwiICE9PSB1ICYmIHUgIT09IG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYSA9IGxbdSArIFwiIFwiICsgb10gfHwgbFtcIiogXCIgKyBvXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHMgPSBpLnNwbGl0KFwiIFwiKSlbMV0gPT09IG8gJiYgKGEgPSBsW3UgKyBcIiBcIiArIHNbMF1dIHx8IGxbXCIqIFwiICsgc1swXV0pKSB7ITAgPT09IGEgPyBhID0gbFtpXSA6ICEwICE9PSBsW2ldICYmIChvID0gc1swXSwgYy51bnNoaWZ0KHNbMV0pKTsgYnJlYWsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgIT09IGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSAmJiBlW1widGhyb3dzXCJdKSB0ID0gYSh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgdHJ5IHsgdCA9IGEodCkgfSBjYXRjaCAoZSkgeyByZXR1cm4geyBzdGF0ZTogXCJwYXJzZXJlcnJvclwiLCBlcnJvcjogYSA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHUgKyBcIiB0byBcIiArIG8gfSB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogdCB9XHJcbiAgICAgICAgICAgICAgICB9KHYsIHMsIFQsIGkpLCBpID8gKHYuaWZNb2RpZmllZCAmJiAoKHUgPSBULmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKSkgJiYgKFMubGFzdE1vZGlmaWVkW2ZdID0gdSksICh1ID0gVC5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIikpICYmIChTLmV0YWdbZl0gPSB1KSksIDIwNCA9PT0gZSB8fCBcIkhFQURcIiA9PT0gdi50eXBlID8gbCA9IFwibm9jb250ZW50XCIgOiAzMDQgPT09IGUgPyBsID0gXCJub3Rtb2RpZmllZFwiIDogKGwgPSBzLnN0YXRlLCBvID0gcy5kYXRhLCBpID0gIShhID0gcy5lcnJvcikpKSA6IChhID0gbCwgIWUgJiYgbCB8fCAobCA9IFwiZXJyb3JcIiwgZSA8IDAgJiYgKGUgPSAwKSkpLCBULnN0YXR1cyA9IGUsIFQuc3RhdHVzVGV4dCA9ICh0IHx8IGwpICsgXCJcIiwgaSA/IHgucmVzb2x2ZVdpdGgoeSwgW28sIGwsIFRdKSA6IHgucmVqZWN0V2l0aCh5LCBbVCwgbCwgYV0pLCBULnN0YXR1c0NvZGUodyksIHcgPSB2b2lkIDAsIGcgJiYgbS50cmlnZ2VyKGkgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLCBbVCwgdiwgaSA/IG8gOiBhXSksIGIuZmlyZVdpdGgoeSwgW1QsIGxdKSwgZyAmJiAobS50cmlnZ2VyKFwiYWpheENvbXBsZXRlXCIsIFtULCB2XSksIC0tUy5hY3RpdmUgfHwgUy5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIikpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBUXHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRKU09OOiBmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiBTLmdldChlLCB0LCBuLCBcImpzb25cIikgfSxcclxuICAgICAgICBnZXRTY3JpcHQ6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIFMuZ2V0KGUsIHZvaWQgMCwgdCwgXCJzY3JpcHRcIikgfVxyXG4gICAgfSksIFMuZWFjaChbXCJnZXRcIiwgXCJwb3N0XCJdLCBmdW5jdGlvbihlLCBpKSB7IFNbaV0gPSBmdW5jdGlvbihlLCB0LCBuLCByKSB7IHJldHVybiBtKHQpICYmIChyID0gciB8fCBuLCBuID0gdCwgdCA9IHZvaWQgMCksIFMuYWpheChTLmV4dGVuZCh7IHVybDogZSwgdHlwZTogaSwgZGF0YVR5cGU6IHIsIGRhdGE6IHQsIHN1Y2Nlc3M6IG4gfSwgUy5pc1BsYWluT2JqZWN0KGUpICYmIGUpKSB9IH0pLCBTLmFqYXhQcmVmaWx0ZXIoZnVuY3Rpb24oZSkgeyB2YXIgdDsgZm9yICh0IGluIGUuaGVhZGVycykgXCJjb250ZW50LXR5cGVcIiA9PT0gdC50b0xvd2VyQ2FzZSgpICYmIChlLmNvbnRlbnRUeXBlID0gZS5oZWFkZXJzW3RdIHx8IFwiXCIpIH0pLCBTLl9ldmFsVXJsID0gZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gUy5hamF4KHsgdXJsOiBlLCB0eXBlOiBcIkdFVFwiLCBkYXRhVHlwZTogXCJzY3JpcHRcIiwgY2FjaGU6ICEwLCBhc3luYzogITEsIGdsb2JhbDogITEsIGNvbnZlcnRlcnM6IHsgXCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbigpIHt9IH0sIGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKGUpIHsgUy5nbG9iYWxFdmFsKGUsIHQsIG4pIH0gfSkgfSwgUy5mbi5leHRlbmQoe1xyXG4gICAgICAgIHdyYXBBbGw6IGZ1bmN0aW9uKGUpIHsgdmFyIHQ7IHJldHVybiB0aGlzWzBdICYmIChtKGUpICYmIChlID0gZS5jYWxsKHRoaXNbMF0pKSwgdCA9IFMoZSwgdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSghMCksIHRoaXNbMF0ucGFyZW50Tm9kZSAmJiB0Lmluc2VydEJlZm9yZSh0aGlzWzBdKSwgdC5tYXAoZnVuY3Rpb24oKSB7IHZhciBlID0gdGhpczsgd2hpbGUgKGUuZmlyc3RFbGVtZW50Q2hpbGQpIGUgPSBlLmZpcnN0RWxlbWVudENoaWxkOyByZXR1cm4gZSB9KS5hcHBlbmQodGhpcykpLCB0aGlzIH0sXHJcbiAgICAgICAgd3JhcElubmVyOiBmdW5jdGlvbihuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtKG4pID8gdGhpcy5lYWNoKGZ1bmN0aW9uKGUpIHsgUyh0aGlzKS53cmFwSW5uZXIobi5jYWxsKHRoaXMsIGUpKSB9KSA6IHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gUyh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICB0ID0gZS5jb250ZW50cygpO1xyXG4gICAgICAgICAgICAgICAgdC5sZW5ndGggPyB0LndyYXBBbGwobikgOiBlLmFwcGVuZChuKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd3JhcDogZnVuY3Rpb24odCkgeyB2YXIgbiA9IG0odCk7IHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oZSkgeyBTKHRoaXMpLndyYXBBbGwobiA/IHQuY2FsbCh0aGlzLCBlKSA6IHQpIH0pIH0sXHJcbiAgICAgICAgdW53cmFwOiBmdW5jdGlvbihlKSB7IHJldHVybiB0aGlzLnBhcmVudChlKS5ub3QoXCJib2R5XCIpLmVhY2goZnVuY3Rpb24oKSB7IFModGhpcykucmVwbGFjZVdpdGgodGhpcy5jaGlsZE5vZGVzKSB9KSwgdGhpcyB9XHJcbiAgICB9KSwgUy5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gIVMuZXhwci5wc2V1ZG9zLnZpc2libGUoZSkgfSwgUy5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuICEhKGUub2Zmc2V0V2lkdGggfHwgZS5vZmZzZXRIZWlnaHQgfHwgZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkgfSwgUy5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7IHRyeSB7IHJldHVybiBuZXcgQy5YTUxIdHRwUmVxdWVzdCB9IGNhdGNoIChlKSB7fSB9O1xyXG4gICAgdmFyIEJ0ID0geyAwOiAyMDAsIDEyMjM6IDIwNCB9LFxyXG4gICAgICAgICR0ID0gUy5hamF4U2V0dGluZ3MueGhyKCk7XHJcbiAgICB5LmNvcnMgPSAhISR0ICYmIFwid2l0aENyZWRlbnRpYWxzXCIgaW4gJHQsIHkuYWpheCA9ICR0ID0gISEkdCwgUy5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKGkpIHtcclxuICAgICAgICB2YXIgbywgYTtcclxuICAgICAgICBpZiAoeS5jb3JzIHx8ICR0ICYmICFpLmNyb3NzRG9tYWluKSByZXR1cm4ge1xyXG4gICAgICAgICAgICBzZW5kOiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiwgciA9IGkueGhyKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoci5vcGVuKGkudHlwZSwgaS51cmwsIGkuYXN5bmMsIGkudXNlcm5hbWUsIGkucGFzc3dvcmQpLCBpLnhockZpZWxkcylcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKG4gaW4gaS54aHJGaWVsZHMpIHJbbl0gPSBpLnhockZpZWxkc1tuXTtcclxuICAgICAgICAgICAgICAgIGZvciAobiBpbiBpLm1pbWVUeXBlICYmIHIub3ZlcnJpZGVNaW1lVHlwZSAmJiByLm92ZXJyaWRlTWltZVR5cGUoaS5taW1lVHlwZSksIGkuY3Jvc3NEb21haW4gfHwgZVtcIlgtUmVxdWVzdGVkLVdpdGhcIl0gfHwgKGVbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiKSwgZSkgci5zZXRSZXF1ZXN0SGVhZGVyKG4sIGVbbl0pO1xyXG4gICAgICAgICAgICAgICAgbyA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGZ1bmN0aW9uKCkgeyBvICYmIChvID0gYSA9IHIub25sb2FkID0gci5vbmVycm9yID0gci5vbmFib3J0ID0gci5vbnRpbWVvdXQgPSByLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGwsIFwiYWJvcnRcIiA9PT0gZSA/IHIuYWJvcnQoKSA6IFwiZXJyb3JcIiA9PT0gZSA/IFwibnVtYmVyXCIgIT0gdHlwZW9mIHIuc3RhdHVzID8gdCgwLCBcImVycm9yXCIpIDogdChyLnN0YXR1cywgci5zdGF0dXNUZXh0KSA6IHQoQnRbci5zdGF0dXNdIHx8IHIuc3RhdHVzLCByLnN0YXR1c1RleHQsIFwidGV4dFwiICE9PSAoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIpIHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIHIucmVzcG9uc2VUZXh0ID8geyBiaW5hcnk6IHIucmVzcG9uc2UgfSA6IHsgdGV4dDogci5yZXNwb25zZVRleHQgfSwgci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIH0gfSwgci5vbmxvYWQgPSBvKCksIGEgPSByLm9uZXJyb3IgPSByLm9udGltZW91dCA9IG8oXCJlcnJvclwiKSwgdm9pZCAwICE9PSByLm9uYWJvcnQgPyByLm9uYWJvcnQgPSBhIDogci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHsgNCA9PT0gci5yZWFkeVN0YXRlICYmIEMuc2V0VGltZW91dChmdW5jdGlvbigpIHsgbyAmJiBhKCkgfSkgfSwgbyA9IG8oXCJhYm9ydFwiKTtcclxuICAgICAgICAgICAgICAgIHRyeSB7IHIuc2VuZChpLmhhc0NvbnRlbnQgJiYgaS5kYXRhIHx8IG51bGwpIH0gY2F0Y2ggKGUpIHsgaWYgKG8pIHRocm93IGUgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7IG8gJiYgbygpIH1cclxuICAgICAgICB9XHJcbiAgICB9KSwgUy5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uKGUpIHsgZS5jcm9zc0RvbWFpbiAmJiAoZS5jb250ZW50cy5zY3JpcHQgPSAhMSkgfSksIFMuYWpheFNldHVwKHsgYWNjZXB0czogeyBzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIiB9LCBjb250ZW50czogeyBzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiLyB9LCBjb252ZXJ0ZXJzOiB7IFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oZSkgeyByZXR1cm4gUy5nbG9iYWxFdmFsKGUpLCBlIH0gfSB9KSwgUy5hamF4UHJlZmlsdGVyKFwic2NyaXB0XCIsIGZ1bmN0aW9uKGUpIHsgdm9pZCAwID09PSBlLmNhY2hlICYmIChlLmNhY2hlID0gITEpLCBlLmNyb3NzRG9tYWluICYmIChlLnR5cGUgPSBcIkdFVFwiKSB9KSwgUy5hamF4VHJhbnNwb3J0KFwic2NyaXB0XCIsIGZ1bmN0aW9uKG4pIHsgdmFyIHIsIGk7IGlmIChuLmNyb3NzRG9tYWluIHx8IG4uc2NyaXB0QXR0cnMpIHJldHVybiB7IHNlbmQ6IGZ1bmN0aW9uKGUsIHQpIHsgciA9IFMoXCI8c2NyaXB0PlwiKS5hdHRyKG4uc2NyaXB0QXR0cnMgfHwge30pLnByb3AoeyBjaGFyc2V0OiBuLnNjcmlwdENoYXJzZXQsIHNyYzogbi51cmwgfSkub24oXCJsb2FkIGVycm9yXCIsIGkgPSBmdW5jdGlvbihlKSB7IHIucmVtb3ZlKCksIGkgPSBudWxsLCBlICYmIHQoXCJlcnJvclwiID09PSBlLnR5cGUgPyA0MDQgOiAyMDAsIGUudHlwZSkgfSksIEUuaGVhZC5hcHBlbmRDaGlsZChyWzBdKSB9LCBhYm9ydDogZnVuY3Rpb24oKSB7IGkgJiYgaSgpIH0gfSB9KTtcclxuICAgIHZhciBfdCwgenQgPSBbXSxcclxuICAgICAgICBVdCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XHJcbiAgICBTLmFqYXhTZXR1cCh7IGpzb25wOiBcImNhbGxiYWNrXCIsIGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkgeyB2YXIgZSA9IHp0LnBvcCgpIHx8IFMuZXhwYW5kbyArIFwiX1wiICsgd3QuZ3VpZCsrOyByZXR1cm4gdGhpc1tlXSA9ICEwLCBlIH0gfSksIFMuYWpheFByZWZpbHRlcihcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgciwgaSwgbywgYSA9ICExICE9PSBlLmpzb25wICYmIChVdC50ZXN0KGUudXJsKSA/IFwidXJsXCIgOiBcInN0cmluZ1wiID09IHR5cGVvZiBlLmRhdGEgJiYgMCA9PT0gKGUuY29udGVudFR5cGUgfHwgXCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSAmJiBVdC50ZXN0KGUuZGF0YSkgJiYgXCJkYXRhXCIpOyBpZiAoYSB8fCBcImpzb25wXCIgPT09IGUuZGF0YVR5cGVzWzBdKSByZXR1cm4gciA9IGUuanNvbnBDYWxsYmFjayA9IG0oZS5qc29ucENhbGxiYWNrKSA/IGUuanNvbnBDYWxsYmFjaygpIDogZS5qc29ucENhbGxiYWNrLCBhID8gZVthXSA9IGVbYV0ucmVwbGFjZShVdCwgXCIkMVwiICsgcikgOiAhMSAhPT0gZS5qc29ucCAmJiAoZS51cmwgKz0gKFR0LnRlc3QoZS51cmwpID8gXCImXCIgOiBcIj9cIikgKyBlLmpzb25wICsgXCI9XCIgKyByKSwgZS5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG8gfHwgUy5lcnJvcihyICsgXCIgd2FzIG5vdCBjYWxsZWRcIiksIG9bMF0gfSwgZS5kYXRhVHlwZXNbMF0gPSBcImpzb25cIiwgaSA9IENbcl0sIENbcl0gPSBmdW5jdGlvbigpIHsgbyA9IGFyZ3VtZW50cyB9LCBuLmFsd2F5cyhmdW5jdGlvbigpIHsgdm9pZCAwID09PSBpID8gUyhDKS5yZW1vdmVQcm9wKHIpIDogQ1tyXSA9IGksIGVbcl0gJiYgKGUuanNvbnBDYWxsYmFjayA9IHQuanNvbnBDYWxsYmFjaywgenQucHVzaChyKSksIG8gJiYgbShpKSAmJiBpKG9bMF0pLCBvID0gaSA9IHZvaWQgMCB9KSwgXCJzY3JpcHRcIiB9KSwgeS5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoKF90ID0gRS5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIikuYm9keSkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiLCAyID09PSBfdC5jaGlsZE5vZGVzLmxlbmd0aCksIFMucGFyc2VIVE1MID0gZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSA/IFtdIDogKFwiYm9vbGVhblwiID09IHR5cGVvZiB0ICYmIChuID0gdCwgdCA9ICExKSwgdCB8fCAoeS5jcmVhdGVIVE1MRG9jdW1lbnQgPyAoKHIgPSAodCA9IEUuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpKS5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKSkuaHJlZiA9IEUubG9jYXRpb24uaHJlZiwgdC5oZWFkLmFwcGVuZENoaWxkKHIpKSA6IHQgPSBFKSwgbyA9ICFuICYmIFtdLCAoaSA9IE4uZXhlYyhlKSkgPyBbdC5jcmVhdGVFbGVtZW50KGlbMV0pXSA6IChpID0geGUoW2VdLCB0LCBvKSwgbyAmJiBvLmxlbmd0aCAmJiBTKG8pLnJlbW92ZSgpLCBTLm1lcmdlKFtdLCBpLmNoaWxkTm9kZXMpKSk7IHZhciByLCBpLCBvIH0sIFMuZm4ubG9hZCA9IGZ1bmN0aW9uKGUsIHQsIG4pIHtcclxuICAgICAgICB2YXIgciwgaSwgbywgYSA9IHRoaXMsXHJcbiAgICAgICAgICAgIHMgPSBlLmluZGV4T2YoXCIgXCIpO1xyXG4gICAgICAgIHJldHVybiAtMSA8IHMgJiYgKHIgPSBodChlLnNsaWNlKHMpKSwgZSA9IGUuc2xpY2UoMCwgcykpLCBtKHQpID8gKG4gPSB0LCB0ID0gdm9pZCAwKSA6IHQgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiAoaSA9IFwiUE9TVFwiKSwgMCA8IGEubGVuZ3RoICYmIFMuYWpheCh7IHVybDogZSwgdHlwZTogaSB8fCBcIkdFVFwiLCBkYXRhVHlwZTogXCJodG1sXCIsIGRhdGE6IHQgfSkuZG9uZShmdW5jdGlvbihlKSB7IG8gPSBhcmd1bWVudHMsIGEuaHRtbChyID8gUyhcIjxkaXY+XCIpLmFwcGVuZChTLnBhcnNlSFRNTChlKSkuZmluZChyKSA6IGUpIH0pLmFsd2F5cyhuICYmIGZ1bmN0aW9uKGUsIHQpIHsgYS5lYWNoKGZ1bmN0aW9uKCkgeyBuLmFwcGx5KHRoaXMsIG8gfHwgW2UucmVzcG9uc2VUZXh0LCB0LCBlXSkgfSkgfSksIHRoaXNcclxuICAgIH0sIFMuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24odCkgeyByZXR1cm4gUy5ncmVwKFMudGltZXJzLCBmdW5jdGlvbihlKSB7IHJldHVybiB0ID09PSBlLmVsZW0gfSkubGVuZ3RoIH0sIFMub2Zmc2V0ID0ge1xyXG4gICAgICAgIHNldE9mZnNldDogZnVuY3Rpb24oZSwgdCwgbikge1xyXG4gICAgICAgICAgICB2YXIgciwgaSwgbywgYSwgcywgdSwgbCA9IFMuY3NzKGUsIFwicG9zaXRpb25cIiksXHJcbiAgICAgICAgICAgICAgICBjID0gUyhlKSxcclxuICAgICAgICAgICAgICAgIGYgPSB7fTtcclxuICAgICAgICAgICAgXCJzdGF0aWNcIiA9PT0gbCAmJiAoZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIiksIHMgPSBjLm9mZnNldCgpLCBvID0gUy5jc3MoZSwgXCJ0b3BcIiksIHUgPSBTLmNzcyhlLCBcImxlZnRcIiksIChcImFic29sdXRlXCIgPT09IGwgfHwgXCJmaXhlZFwiID09PSBsKSAmJiAtMSA8IChvICsgdSkuaW5kZXhPZihcImF1dG9cIikgPyAoYSA9IChyID0gYy5wb3NpdGlvbigpKS50b3AsIGkgPSByLmxlZnQpIDogKGEgPSBwYXJzZUZsb2F0KG8pIHx8IDAsIGkgPSBwYXJzZUZsb2F0KHUpIHx8IDApLCBtKHQpICYmICh0ID0gdC5jYWxsKGUsIG4sIFMuZXh0ZW5kKHt9LCBzKSkpLCBudWxsICE9IHQudG9wICYmIChmLnRvcCA9IHQudG9wIC0gcy50b3AgKyBhKSwgbnVsbCAhPSB0LmxlZnQgJiYgKGYubGVmdCA9IHQubGVmdCAtIHMubGVmdCArIGkpLCBcInVzaW5nXCIgaW4gdCA/IHQudXNpbmcuY2FsbChlLCBmKSA6IGMuY3NzKGYpXHJcbiAgICAgICAgfVxyXG4gICAgfSwgUy5mbi5leHRlbmQoe1xyXG4gICAgICAgIG9mZnNldDogZnVuY3Rpb24odCkgeyBpZiAoYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZvaWQgMCA9PT0gdCA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24oZSkgeyBTLm9mZnNldC5zZXRPZmZzZXQodGhpcywgdCwgZSkgfSk7IHZhciBlLCBuLCByID0gdGhpc1swXTsgcmV0dXJuIHIgPyByLmdldENsaWVudFJlY3RzKCkubGVuZ3RoID8gKGUgPSByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBuID0gci5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LCB7IHRvcDogZS50b3AgKyBuLnBhZ2VZT2Zmc2V0LCBsZWZ0OiBlLmxlZnQgKyBuLnBhZ2VYT2Zmc2V0IH0pIDogeyB0b3A6IDAsIGxlZnQ6IDAgfSA6IHZvaWQgMCB9LFxyXG4gICAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXNbMF0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBlLCB0LCBuLCByID0gdGhpc1swXSxcclxuICAgICAgICAgICAgICAgICAgICBpID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChcImZpeGVkXCIgPT09IFMuY3NzKHIsIFwicG9zaXRpb25cIikpIHQgPSByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHRoaXMub2Zmc2V0KCksIG4gPSByLm93bmVyRG9jdW1lbnQsIGUgPSByLm9mZnNldFBhcmVudCB8fCBuLmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZSAmJiAoZSA9PT0gbi5ib2R5IHx8IGUgPT09IG4uZG9jdW1lbnRFbGVtZW50KSAmJiBcInN0YXRpY1wiID09PSBTLmNzcyhlLCBcInBvc2l0aW9uXCIpKSBlID0gZS5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGUgJiYgZSAhPT0gciAmJiAxID09PSBlLm5vZGVUeXBlICYmICgoaSA9IFMoZSkub2Zmc2V0KCkpLnRvcCArPSBTLmNzcyhlLCBcImJvcmRlclRvcFdpZHRoXCIsICEwKSwgaS5sZWZ0ICs9IFMuY3NzKGUsIFwiYm9yZGVyTGVmdFdpZHRoXCIsICEwKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRvcDogdC50b3AgLSBpLnRvcCAtIFMuY3NzKHIsIFwibWFyZ2luVG9wXCIsICEwKSwgbGVmdDogdC5sZWZ0IC0gaS5sZWZ0IC0gUy5jc3MociwgXCJtYXJnaW5MZWZ0XCIsICEwKSB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHsgdmFyIGUgPSB0aGlzLm9mZnNldFBhcmVudDsgd2hpbGUgKGUgJiYgXCJzdGF0aWNcIiA9PT0gUy5jc3MoZSwgXCJwb3NpdGlvblwiKSkgZSA9IGUub2Zmc2V0UGFyZW50OyByZXR1cm4gZSB8fCByZSB9KSB9XHJcbiAgICB9KSwgUy5lYWNoKHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbih0LCBpKSB7XHJcbiAgICAgICAgdmFyIG8gPSBcInBhZ2VZT2Zmc2V0XCIgPT09IGk7XHJcbiAgICAgICAgUy5mblt0XSA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQodGhpcywgZnVuY3Rpb24oZSwgdCwgbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHI7XHJcbiAgICAgICAgICAgICAgICBpZiAoeChlKSA/IHIgPSBlIDogOSA9PT0gZS5ub2RlVHlwZSAmJiAociA9IGUuZGVmYXVsdFZpZXcpLCB2b2lkIDAgPT09IG4pIHJldHVybiByID8gcltpXSA6IGVbdF07XHJcbiAgICAgICAgICAgICAgICByID8gci5zY3JvbGxUbyhvID8gci5wYWdlWE9mZnNldCA6IG4sIG8gPyBuIDogci5wYWdlWU9mZnNldCkgOiBlW3RdID0gblxyXG4gICAgICAgICAgICB9LCB0LCBlLCBhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgIH1cclxuICAgIH0pLCBTLmVhY2goW1widG9wXCIsIFwibGVmdFwiXSwgZnVuY3Rpb24oZSwgbikgeyBTLmNzc0hvb2tzW25dID0gRmUoeS5waXhlbFBvc2l0aW9uLCBmdW5jdGlvbihlLCB0KSB7IGlmICh0KSByZXR1cm4gdCA9IFdlKGUsIG4pLCBQZS50ZXN0KHQpID8gUyhlKS5wb3NpdGlvbigpW25dICsgXCJweFwiIDogdCB9KSB9KSwgUy5lYWNoKHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKGEsIHMpIHtcclxuICAgICAgICBTLmVhY2goeyBwYWRkaW5nOiBcImlubmVyXCIgKyBhLCBjb250ZW50OiBzLCBcIlwiOiBcIm91dGVyXCIgKyBhIH0sIGZ1bmN0aW9uKHIsIG8pIHtcclxuICAgICAgICAgICAgUy5mbltvXSA9IGZ1bmN0aW9uKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCAmJiAociB8fCBcImJvb2xlYW5cIiAhPSB0eXBlb2YgZSksXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IHIgfHwgKCEwID09PSBlIHx8ICEwID09PSB0ID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICQodGhpcywgZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgcjsgcmV0dXJuIHgoZSkgPyAwID09PSBvLmluZGV4T2YoXCJvdXRlclwiKSA/IGVbXCJpbm5lclwiICsgYV0gOiBlLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcImNsaWVudFwiICsgYV0gOiA5ID09PSBlLm5vZGVUeXBlID8gKHIgPSBlLmRvY3VtZW50RWxlbWVudCwgTWF0aC5tYXgoZS5ib2R5W1wic2Nyb2xsXCIgKyBhXSwgcltcInNjcm9sbFwiICsgYV0sIGUuYm9keVtcIm9mZnNldFwiICsgYV0sIHJbXCJvZmZzZXRcIiArIGFdLCByW1wiY2xpZW50XCIgKyBhXSkpIDogdm9pZCAwID09PSBuID8gUy5jc3MoZSwgdCwgaSkgOiBTLnN0eWxlKGUsIHQsIG4sIGkpIH0sIHMsIG4gPyBlIDogdm9pZCAwLCBuKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0pLCBTLmVhY2goW1wiYWpheFN0YXJ0XCIsIFwiYWpheFN0b3BcIiwgXCJhamF4Q29tcGxldGVcIiwgXCJhamF4RXJyb3JcIiwgXCJhamF4U3VjY2Vzc1wiLCBcImFqYXhTZW5kXCJdLCBmdW5jdGlvbihlLCB0KSB7IFMuZm5bdF0gPSBmdW5jdGlvbihlKSB7IHJldHVybiB0aGlzLm9uKHQsIGUpIH0gfSksIFMuZm4uZXh0ZW5kKHsgYmluZDogZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gdGhpcy5vbihlLCBudWxsLCB0LCBuKSB9LCB1bmJpbmQ6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHRoaXMub2ZmKGUsIG51bGwsIHQpIH0sIGRlbGVnYXRlOiBmdW5jdGlvbihlLCB0LCBuLCByKSB7IHJldHVybiB0aGlzLm9uKHQsIGUsIG4sIHIpIH0sIHVuZGVsZWdhdGU6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgcmV0dXJuIDEgPT09IGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLm9mZihlLCBcIioqXCIpIDogdGhpcy5vZmYodCwgZSB8fCBcIioqXCIsIG4pIH0sIGhvdmVyOiBmdW5jdGlvbihlLCB0KSB7IHJldHVybiB0aGlzLm1vdXNlZW50ZXIoZSkubW91c2VsZWF2ZSh0IHx8IGUpIH0gfSksIFMuZWFjaChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIGNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKGUsIG4pIHsgUy5mbltuXSA9IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIDAgPCBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5vbihuLCBudWxsLCBlLCB0KSA6IHRoaXMudHJpZ2dlcihuKSB9IH0pO1xyXG4gICAgdmFyIFh0ID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xyXG4gICAgUy5wcm94eSA9IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4sIHIsIGk7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0ICYmIChuID0gZVt0XSwgdCA9IGUsIGUgPSBuKSwgbShlKSkgcmV0dXJuIHIgPSBzLmNhbGwoYXJndW1lbnRzLCAyKSwgKGkgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGUuYXBwbHkodCB8fCB0aGlzLCByLmNvbmNhdChzLmNhbGwoYXJndW1lbnRzKSkpIH0pLmd1aWQgPSBlLmd1aWQgPSBlLmd1aWQgfHwgUy5ndWlkKyssIGkgfSwgUy5ob2xkUmVhZHkgPSBmdW5jdGlvbihlKSB7IGUgPyBTLnJlYWR5V2FpdCsrIDogUy5yZWFkeSghMCkgfSwgUy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSwgUy5wYXJzZUpTT04gPSBKU09OLnBhcnNlLCBTLm5vZGVOYW1lID0gQSwgUy5pc0Z1bmN0aW9uID0gbSwgUy5pc1dpbmRvdyA9IHgsIFMuY2FtZWxDYXNlID0gWCwgUy50eXBlID0gdywgUy5ub3cgPSBEYXRlLm5vdywgUy5pc051bWVyaWMgPSBmdW5jdGlvbihlKSB7IHZhciB0ID0gUy50eXBlKGUpOyByZXR1cm4gKFwibnVtYmVyXCIgPT09IHQgfHwgXCJzdHJpbmdcIiA9PT0gdCkgJiYgIWlzTmFOKGUgLSBwYXJzZUZsb2F0KGUpKSB9LCBTLnRyaW0gPSBmdW5jdGlvbihlKSB7IHJldHVybiBudWxsID09IGUgPyBcIlwiIDogKGUgKyBcIlwiKS5yZXBsYWNlKFh0LCBcIlwiKSB9LCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kICYmIGRlZmluZShcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBTIH0pO1xyXG4gICAgdmFyIFZ0ID0gQy5qUXVlcnksXHJcbiAgICAgICAgR3QgPSBDLiQ7XHJcbiAgICByZXR1cm4gUy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gQy4kID09PSBTICYmIChDLiQgPSBHdCksIGUgJiYgQy5qUXVlcnkgPT09IFMgJiYgKEMualF1ZXJ5ID0gVnQpLCBTIH0sIFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIGUgJiYgKEMualF1ZXJ5ID0gQy4kID0gUyksIFNcclxufSk7Il0sImZpbGUiOiJqcXVlcnktMy42LjAubWluLmpzIn0=