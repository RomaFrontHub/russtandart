/**
 * Swiper 8.2.4
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2022 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: June 13, 2022
 */

! function(e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Swiper = t() }(this, (function() { "use strict";

            function e(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object }

            function t(s, a) { void 0 === s && (s = {}), void 0 === a && (a = {}), Object.keys(a).forEach((i => { void 0 === s[i] ? s[i] = a[i] : e(a[i]) && e(s[i]) && Object.keys(a[i]).length > 0 && t(s[i], a[i]) })) } const s = { body: {}, addEventListener() {}, removeEventListener() {}, activeElement: { blur() {}, nodeName: "" }, querySelector: () => null, querySelectorAll: () => [], getElementById: () => null, createEvent: () => ({ initEvent() {} }), createElement: () => ({ children: [], childNodes: [], style: {}, setAttribute() {}, getElementsByTagName: () => [] }), createElementNS: () => ({}), importNode: () => null, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } };

            function a() { const e = "undefined" != typeof document ? document : {}; return t(e, s), e } const i = { document: s, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() {}, pushState() {}, go() {}, back() {} }, CustomEvent: function() { return this }, addEventListener() {}, removeEventListener() {}, getComputedStyle: () => ({ getPropertyValue: () => "" }), Image() {}, Date() {}, screen: {}, setTimeout() {}, clearTimeout() {}, matchMedia: () => ({}), requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0), cancelAnimationFrame(e) { "undefined" != typeof setTimeout && clearTimeout(e) } };

            function r() { const e = "undefined" != typeof window ? window : {}; return t(e, i), e }
            class n extends Array { constructor(e) { "number" == typeof e ? super(e) : (super(...e || []), function(e) { const t = e.__proto__;
                        Object.defineProperty(e, "__proto__", { get: () => t, set(e) { t.__proto__ = e } }) }(this)) } }

            function l(e) { void 0 === e && (e = []); const t = []; return e.forEach((e => { Array.isArray(e) ? t.push(...l(e)) : t.push(e) })), t }

            function o(e, t) { return Array.prototype.filter.call(e, t) }

            function d(e, t) { const s = r(),
                    i = a(); let l = []; if (!t && e instanceof n) return e; if (!e) return new n(l); if ("string" == typeof e) { const s = e.trim(); if (s.indexOf("<") >= 0 && s.indexOf(">") >= 0) { let e = "div";
                        0 === s.indexOf("<li") && (e = "ul"), 0 === s.indexOf("<tr") && (e = "tbody"), 0 !== s.indexOf("<td") && 0 !== s.indexOf("<th") || (e = "tr"), 0 === s.indexOf("<tbody") && (e = "table"), 0 === s.indexOf("<option") && (e = "select"); const t = i.createElement(e);
                        t.innerHTML = s; for (let e = 0; e < t.childNodes.length; e += 1) l.push(t.childNodes[e]) } else l = function(e, t) { if ("string" != typeof e) return [e]; const s = [],
                            a = t.querySelectorAll(e); for (let e = 0; e < a.length; e += 1) s.push(a[e]); return s }(e.trim(), t || i) } else if (e.nodeType || e === s || e === i) l.push(e);
                else if (Array.isArray(e)) { if (e instanceof n) return e;
                    l = e } return new n(function(e) { const t = []; for (let s = 0; s < e.length; s += 1) - 1 === t.indexOf(e[s]) && t.push(e[s]); return t }(l)) }
            d.fn = n.prototype; const c = { addClass: function() { for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s]; const a = l(t.map((e => e.split(" ")))); return this.forEach((e => { e.classList.add(...a) })), this }, removeClass: function() { for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s]; const a = l(t.map((e => e.split(" ")))); return this.forEach((e => { e.classList.remove(...a) })), this }, hasClass: function() { for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s]; const a = l(t.map((e => e.split(" ")))); return o(this, (e => a.filter((t => e.classList.contains(t))).length > 0)).length > 0 }, toggleClass: function() { for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s]; const a = l(t.map((e => e.split(" "))));
                    this.forEach((e => { a.forEach((t => { e.classList.toggle(t) })) })) }, attr: function(e, t) { if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0; for (let s = 0; s < this.length; s += 1)
                        if (2 === arguments.length) this[s].setAttribute(e, t);
                        else
                            for (const t in e) this[s][t] = e[t], this[s].setAttribute(t, e[t]);
                    return this }, removeAttr: function(e) { for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e); return this }, transform: function(e) { for (let t = 0; t < this.length; t += 1) this[t].style.transform = e; return this }, transition: function(e) { for (let t = 0; t < this.length; t += 1) this[t].style.transitionDuration = "string" != typeof e ? `${e}ms` : e; return this }, on: function() { for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s]; let [a, i, r, n] = t;

                    function l(e) { const t = e.target; if (!t) return; const s = e.target.dom7EventData || []; if (s.indexOf(e) < 0 && s.unshift(e), d(t).is(i)) r.apply(t, s);
                        else { const e = d(t).parents(); for (let t = 0; t < e.length; t += 1) d(e[t]).is(i) && r.apply(e[t], s) } }

                    function o(e) { const t = e && e.target && e.target.dom7EventData || [];
                        t.indexOf(e) < 0 && t.unshift(e), r.apply(this, t) } "function" == typeof t[1] && ([a, r, n] = t, i = void 0), n || (n = !1); const c = a.split(" "); let p; for (let e = 0; e < this.length; e += 1) { const t = this[e]; if (i)
                            for (p = 0; p < c.length; p += 1) { const e = c[p];
                                t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({ listener: r, proxyListener: l }), t.addEventListener(e, l, n) } else
                                for (p = 0; p < c.length; p += 1) { const e = c[p];
                                    t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({ listener: r, proxyListener: o }), t.addEventListener(e, o, n) } } return this }, off: function() { for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s]; let [a, i, r, n] = t; "function" == typeof t[1] && ([a, r, n] = t, i = void 0), n || (n = !1); const l = a.split(" "); for (let e = 0; e < l.length; e += 1) { const t = l[e]; for (let e = 0; e < this.length; e += 1) { const s = this[e]; let a; if (!i && s.dom7Listeners ? a = s.dom7Listeners[t] : i && s.dom7LiveListeners && (a = s.dom7LiveListeners[t]), a && a.length)
                                for (let e = a.length - 1; e >= 0; e -= 1) { const i = a[e];
                                    r && i.listener === r || r && i.listener && i.listener.dom7proxy && i.listener.dom7proxy === r ? (s.removeEventListener(t, i.proxyListener, n), a.splice(e, 1)) : r || (s.removeEventListener(t, i.proxyListener, n), a.splice(e, 1)) } } } return this }, trigger: function() { const e = r(); for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++) s[a] = arguments[a]; const i = s[0].split(" "),
                        n = s[1]; for (let t = 0; t < i.length; t += 1) { const a = i[t]; for (let t = 0; t < this.length; t += 1) { const i = this[t]; if (e.CustomEvent) { const t = new e.CustomEvent(a, { detail: n, bubbles: !0, cancelable: !0 });
                                i.dom7EventData = s.filter(((e, t) => t > 0)), i.dispatchEvent(t), i.dom7EventData = [], delete i.dom7EventData } } } return this }, transitionEnd: function(e) { const t = this; return e && t.on("transitionend", (function s(a) { a.target === this && (e.call(this, a), t.off("transitionend", s)) })), this }, outerWidth: function(e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left")) } return this[0].offsetWidth } return null }, outerHeight: function(e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom")) } return this[0].offsetHeight } return null }, styles: function() { const e = r(); return this[0] ? e.getComputedStyle(this[0], null) : {} }, offset: function() { if (this.length > 0) { const e = r(),
                            t = a(),
                            s = this[0],
                            i = s.getBoundingClientRect(),
                            n = t.body,
                            l = s.clientTop || n.clientTop || 0,
                            o = s.clientLeft || n.clientLeft || 0,
                            d = s === e ? e.scrollY : s.scrollTop,
                            c = s === e ? e.scrollX : s.scrollLeft; return { top: i.top + d - l, left: i.left + c - o } } return null }, css: function(e, t) { const s = r(); let a; if (1 === arguments.length) { if ("string" != typeof e) { for (a = 0; a < this.length; a += 1)
                                for (const t in e) this[a].style[t] = e[t]; return this } if (this[0]) return s.getComputedStyle(this[0], null).getPropertyValue(e) } if (2 === arguments.length && "string" == typeof e) { for (a = 0; a < this.length; a += 1) this[a].style[e] = t; return this } return this }, each: function(e) { return e ? (this.forEach(((t, s) => { e.apply(t, [t, s]) })), this) : this }, html: function(e) { if (void 0 === e) return this[0] ? this[0].innerHTML : null; for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e; return this }, text: function(e) { if (void 0 === e) return this[0] ? this[0].textContent.trim() : null; for (let t = 0; t < this.length; t += 1) this[t].textContent = e; return this }, is: function(e) { const t = r(),
                        s = a(),
                        i = this[0]; let l, o; if (!i || void 0 === e) return !1; if ("string" == typeof e) { if (i.matches) return i.matches(e); if (i.webkitMatchesSelector) return i.webkitMatchesSelector(e); if (i.msMatchesSelector) return i.msMatchesSelector(e); for (l = d(e), o = 0; o < l.length; o += 1)
                            if (l[o] === i) return !0;
                        return !1 } if (e === s) return i === s; if (e === t) return i === t; if (e.nodeType || e instanceof n) { for (l = e.nodeType ? [e] : e, o = 0; o < l.length; o += 1)
                            if (l[o] === i) return !0;
                        return !1 } return !1 }, index: function() { let e, t = this[0]; if (t) { for (e = 0; null !== (t = t.previousSibling);) 1 === t.nodeType && (e += 1); return e } }, eq: function(e) { if (void 0 === e) return this; const t = this.length; if (e > t - 1) return d([]); if (e < 0) { const s = t + e; return d(s < 0 ? [] : [this[s]]) } return d([this[e]]) }, append: function() { let e; const t = a(); for (let s = 0; s < arguments.length; s += 1) { e = s < 0 || arguments.length <= s ? void 0 : arguments[s]; for (let s = 0; s < this.length; s += 1)
                            if ("string" == typeof e) { const a = t.createElement("div"); for (a.innerHTML = e; a.firstChild;) this[s].appendChild(a.firstChild) } else if (e instanceof n)
                            for (let t = 0; t < e.length; t += 1) this[s].appendChild(e[t]);
                        else this[s].appendChild(e) } return this }, prepend: function(e) { const t = a(); let s, i; for (s = 0; s < this.length; s += 1)
                        if ("string" == typeof e) { const a = t.createElement("div"); for (a.innerHTML = e, i = a.childNodes.length - 1; i >= 0; i -= 1) this[s].insertBefore(a.childNodes[i], this[s].childNodes[0]) } else if (e instanceof n)
                        for (i = 0; i < e.length; i += 1) this[s].insertBefore(e[i], this[s].childNodes[0]);
                    else this[s].insertBefore(e, this[s].childNodes[0]); return this }, next: function(e) { return this.length > 0 ? e ? this[0].nextElementSibling && d(this[0].nextElementSibling).is(e) ? d([this[0].nextElementSibling]) : d([]) : this[0].nextElementSibling ? d([this[0].nextElementSibling]) : d([]) : d([]) }, nextAll: function(e) { const t = []; let s = this[0]; if (!s) return d([]); for (; s.nextElementSibling;) { const a = s.nextElementSibling;
                        e ? d(a).is(e) && t.push(a) : t.push(a), s = a } return d(t) }, prev: function(e) { if (this.length > 0) { const t = this[0]; return e ? t.previousElementSibling && d(t.previousElementSibling).is(e) ? d([t.previousElementSibling]) : d([]) : t.previousElementSibling ? d([t.previousElementSibling]) : d([]) } return d([]) }, prevAll: function(e) { const t = []; let s = this[0]; if (!s) return d([]); for (; s.previousElementSibling;) { const a = s.previousElementSibling;
                        e ? d(a).is(e) && t.push(a) : t.push(a), s = a } return d(t) }, parent: function(e) { const t = []; for (let s = 0; s < this.length; s += 1) null !== this[s].parentNode && (e ? d(this[s].parentNode).is(e) && t.push(this[s].parentNode) : t.push(this[s].parentNode)); return d(t) }, parents: function(e) { const t = []; for (let s = 0; s < this.length; s += 1) { let a = this[s].parentNode; for (; a;) e ? d(a).is(e) && t.push(a) : t.push(a), a = a.parentNode } return d(t) }, closest: function(e) { let t = this; return void 0 === e ? d([]) : (t.is(e) || (t = t.parents(e).eq(0)), t) }, find: function(e) { const t = []; for (let s = 0; s < this.length; s += 1) { const a = this[s].querySelectorAll(e); for (let e = 0; e < a.length; e += 1) t.push(a[e]) } return d(t) }, children: function(e) { const t = []; for (let s = 0; s < this.length; s += 1) { const a = this[s].children; for (let s = 0; s < a.length; s += 1) e && !d(a[s]).is(e) || t.push(a[s]) } return d(t) }, filter: function(e) { return d(o(this, e)) }, remove: function() { for (let e = 0; e < this.length; e += 1) this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this } };

            function p(e, t) { return void 0 === t && (t = 0), setTimeout(e, t) }

            function u() { return Date.now() }

            function h(e, t) { void 0 === t && (t = "x"); const s = r(); let a, i, n; const l = function(e) { const t = r(); let s; return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s }(e); return s.WebKitCSSMatrix ? (i = l.transform || l.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map((e => e.replace(",", "."))).join(", ")), n = new s.WebKitCSSMatrix("none" === i ? "" : i)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), a = n.toString().split(",")), "x" === t && (i = s.WebKitCSSMatrix ? n.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), "y" === t && (i = s.WebKitCSSMatrix ? n.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), i || 0 }

            function m(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) }

            function f(e) { return "undefined" != typeof window && void 0 !== window.HTMLElement ? e instanceof HTMLElement : e && (1 === e.nodeType || 11 === e.nodeType) }

            function g() { const e = Object(arguments.length <= 0 ? void 0 : arguments[0]),
                    t = ["__proto__", "constructor", "prototype"]; for (let s = 1; s < arguments.length; s += 1) { const a = s < 0 || arguments.length <= s ? void 0 : arguments[s]; if (null != a && !f(a)) { const s = Object.keys(Object(a)).filter((e => t.indexOf(e) < 0)); for (let t = 0, i = s.length; t < i; t += 1) { const i = s[t],
                                r = Object.getOwnPropertyDescriptor(a, i);
                            void 0 !== r && r.enumerable && (m(e[i]) && m(a[i]) ? a[i].__swiper__ ? e[i] = a[i] : g(e[i], a[i]) : !m(e[i]) && m(a[i]) ? (e[i] = {}, a[i].__swiper__ ? e[i] = a[i] : g(e[i], a[i])) : e[i] = a[i]) } } } return e }

            function v(e, t, s) { e.style.setProperty(t, s) }

            function w(e) { let { swiper: t, targetPosition: s, side: a } = e; const i = r(),
                    n = -t.translate; let l, o = null; const d = t.params.speed;
                t.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(t.cssModeFrameID); const c = s > n ? "next" : "prev",
                    p = (e, t) => "next" === c && e >= t || "prev" === c && e <= t,
                    u = () => { l = (new Date).getTime(), null === o && (o = l); const e = Math.max(Math.min((l - o) / d, 1), 0),
                            r = .5 - Math.cos(e * Math.PI) / 2; let c = n + r * (s - n); if (p(c, s) && (c = s), t.wrapperEl.scrollTo({
                                [a]: c }), p(c, s)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout((() => { t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({
                                [a]: c }) })), void i.cancelAnimationFrame(t.cssModeFrameID);
                        t.cssModeFrameID = i.requestAnimationFrame(u) };
                u() } let b, x, y;

            function E() { return b || (b = function() { const e = r(),
                        t = a(); return { smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch), passiveListener: function() { let t = !1; try { const s = Object.defineProperty({}, "passive", {get() { t = !0 } });
                                e.addEventListener("testPassiveListener", null, s) } catch (e) {} return t }(), gestures: "ongesturestart" in e } }()), b }

            function C(e) { return void 0 === e && (e = {}), x || (x = function(e) { let { userAgent: t } = void 0 === e ? {} : e; const s = E(),
                        a = r(),
                        i = a.navigator.platform,
                        n = t || a.navigator.userAgent,
                        l = { ios: !1, android: !1 },
                        o = a.screen.width,
                        d = a.screen.height,
                        c = n.match(/(Android);?[\s\/]+([\d.]+)?/); let p = n.match(/(iPad).*OS\s([\d_]+)/); const u = n.match(/(iPod)(.*OS\s([\d_]+))?/),
                        h = !p && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                        m = "Win32" === i; let f = "MacIntel" === i; return !p && f && s.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${d}`) >= 0 && (p = n.match(/(Version)\/([\d.]+)/), p || (p = [0, 1, "13_0_0"]), f = !1), c && !m && (l.os = "android", l.android = !0), (p || h || u) && (l.os = "ios", l.ios = !0), l }(e)), x }

            function T() { return y || (y = function() { const e = r(); return { isSafari: function() { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0 }(), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent) } }()), y }
            Object.keys(c).forEach((e => { Object.defineProperty(d.fn, e, { value: c[e], writable: !0 }) })); var $ = { on(e, t, s) { const a = this; if (!a.eventsListeners || a.destroyed) return a; if ("function" != typeof t) return a; const i = s ? "unshift" : "push"; return e.split(" ").forEach((e => { a.eventsListeners[e] || (a.eventsListeners[e] = []), a.eventsListeners[e][i](t) })), a }, once(e, t, s) { const a = this; if (!a.eventsListeners || a.destroyed) return a; if ("function" != typeof t) return a;

                    function i() { a.off(e, i), i.__emitterProxy && delete i.__emitterProxy; for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++) r[n] = arguments[n];
                        t.apply(a, r) } return i.__emitterProxy = t, a.on(e, i, s) }, onAny(e, t) { const s = this; if (!s.eventsListeners || s.destroyed) return s; if ("function" != typeof e) return s; const a = t ? "unshift" : "push"; return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[a](e), s }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsAnyListeners) return t; const s = t.eventsAnyListeners.indexOf(e); return s >= 0 && t.eventsAnyListeners.splice(s, 1), t }, off(e, t) { const s = this; return !s.eventsListeners || s.destroyed ? s : s.eventsListeners ? (e.split(" ").forEach((e => { void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach(((a, i) => {
                            (a === t || a.__emitterProxy && a.__emitterProxy === t) && s.eventsListeners[e].splice(i, 1) })) })), s) : s }, emit() { const e = this; if (!e.eventsListeners || e.destroyed) return e; if (!e.eventsListeners) return e; let t, s, a; for (var i = arguments.length, r = new Array(i), n = 0; n < i; n++) r[n] = arguments[n]; "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], s = r.slice(1, r.length), a = e) : (t = r[0].events, s = r[0].data, a = r[0].context || e), s.unshift(a); return (Array.isArray(t) ? t : t.split(" ")).forEach((t => { e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => { e.apply(a, [t, ...s]) })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => { e.apply(a, s) })) })), e } }; var S = { updateSize: function() { const e = this; let t, s; const a = e.$el;
                    t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : a[0].clientWidth, s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : a[0].clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(a.css("padding-left") || 0, 10) - parseInt(a.css("padding-right") || 0, 10), s = s - parseInt(a.css("padding-top") || 0, 10) - parseInt(a.css("padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, { width: t, height: s, size: e.isHorizontal() ? t : s })) }, updateSlides: function() { const e = this;

                    function t(t) { return e.isHorizontal() ? t : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[t] }

                    function s(e, s) { return parseFloat(e.getPropertyValue(t(s)) || 0) } const a = e.params,
                        { $wrapperEl: i, size: r, rtlTranslate: n, wrongRTL: l } = e,
                        o = e.virtual && a.virtual.enabled,
                        d = o ? e.virtual.slides.length : e.slides.length,
                        c = i.children(`.${e.params.slideClass}`),
                        p = o ? e.virtual.slides.length : c.length; let u = []; const h = [],
                        m = []; let f = a.slidesOffsetBefore; "function" == typeof f && (f = a.slidesOffsetBefore.call(e)); let g = a.slidesOffsetAfter; "function" == typeof g && (g = a.slidesOffsetAfter.call(e)); const w = e.snapGrid.length,
                        b = e.slidesGrid.length; let x = a.spaceBetween,
                        y = -f,
                        E = 0,
                        C = 0; if (void 0 === r) return; "string" == typeof x && x.indexOf("%") >= 0 && (x = parseFloat(x.replace("%", "")) / 100 * r), e.virtualSize = -x, n ? c.css({ marginLeft: "", marginBottom: "", marginTop: "" }) : c.css({ marginRight: "", marginBottom: "", marginTop: "" }), a.centeredSlides && a.cssMode && (v(e.wrapperEl, "--swiper-centered-offset-before", ""), v(e.wrapperEl, "--swiper-centered-offset-after", "")); const T = a.grid && a.grid.rows > 1 && e.grid; let $;
                    T && e.grid.initSlides(p); const S = "auto" === a.slidesPerView && a.breakpoints && Object.keys(a.breakpoints).filter((e => void 0 !== a.breakpoints[e].slidesPerView)).length > 0; for (let i = 0; i < p; i += 1) { $ = 0; const n = c.eq(i); if (T && e.grid.updateSlide(i, n, p, t), "none" !== n.css("display")) { if ("auto" === a.slidesPerView) { S && (c[i].style[t("width")] = ""); const r = getComputedStyle(n[0]),
                                    l = n[0].style.transform,
                                    o = n[0].style.webkitTransform; if (l && (n[0].style.transform = "none"), o && (n[0].style.webkitTransform = "none"), a.roundLengths) $ = e.isHorizontal() ? n.outerWidth(!0) : n.outerHeight(!0);
                                else { const e = s(r, "width"),
                                        t = s(r, "padding-left"),
                                        a = s(r, "padding-right"),
                                        i = s(r, "margin-left"),
                                        l = s(r, "margin-right"),
                                        o = r.getPropertyValue("box-sizing"); if (o && "border-box" === o) $ = e + i + l;
                                    else { const { clientWidth: s, offsetWidth: r } = n[0];
                                        $ = e + t + a + i + l + (r - s) } }
                                l && (n[0].style.transform = l), o && (n[0].style.webkitTransform = o), a.roundLengths && ($ = Math.floor($)) } else $ = (r - (a.slidesPerView - 1) * x) / a.slidesPerView, a.roundLengths && ($ = Math.floor($)), c[i] && (c[i].style[t("width")] = `${$}px`);
                            c[i] && (c[i].swiperSlideSize = $), m.push($), a.centeredSlides ? (y = y + $ / 2 + E / 2 + x, 0 === E && 0 !== i && (y = y - r / 2 - x), 0 === i && (y = y - r / 2 - x), Math.abs(y) < .001 && (y = 0), a.roundLengths && (y = Math.floor(y)), C % a.slidesPerGroup == 0 && u.push(y), h.push(y)) : (a.roundLengths && (y = Math.floor(y)), (C - Math.min(e.params.slidesPerGroupSkip, C)) % e.params.slidesPerGroup == 0 && u.push(y), h.push(y), y = y + $ + x), e.virtualSize += $ + x, E = $, C += 1 } } if (e.virtualSize = Math.max(e.virtualSize, r) + g, n && l && ("slide" === a.effect || "coverflow" === a.effect) && i.css({ width: `${e.virtualSize+a.spaceBetween}px` }), a.setWrapperSize && i.css({
                            [t("width")]: `${e.virtualSize+a.spaceBetween}px` }), T && e.grid.updateWrapperSize($, u, t), !a.centeredSlides) { const t = []; for (let s = 0; s < u.length; s += 1) { let i = u[s];
                            a.roundLengths && (i = Math.floor(i)), u[s] <= e.virtualSize - r && t.push(i) }
                        u = t, Math.floor(e.virtualSize - r) - Math.floor(u[u.length - 1]) > 1 && u.push(e.virtualSize - r) } if (0 === u.length && (u = [0]), 0 !== a.spaceBetween) { const s = e.isHorizontal() && n ? "marginLeft" : t("marginRight");
                        c.filter(((e, t) => !a.cssMode || t !== c.length - 1)).css({
                            [s]: `${x}px` }) } if (a.centeredSlides && a.centeredSlidesBounds) { let e = 0;
                        m.forEach((t => { e += t + (a.spaceBetween ? a.spaceBetween : 0) })), e -= a.spaceBetween; const t = e - r;
                        u = u.map((e => e < 0 ? -f : e > t ? t + g : e)) } if (a.centerInsufficientSlides) { let e = 0; if (m.forEach((t => { e += t + (a.spaceBetween ? a.spaceBetween : 0) })), e -= a.spaceBetween, e < r) { const t = (r - e) / 2;
                            u.forEach(((e, s) => { u[s] = e - t })), h.forEach(((e, s) => { h[s] = e + t })) } } if (Object.assign(e, { slides: c, snapGrid: u, slidesGrid: h, slidesSizesGrid: m }), a.centeredSlides && a.cssMode && !a.centeredSlidesBounds) { v(e.wrapperEl, "--swiper-centered-offset-before", -u[0] + "px"), v(e.wrapperEl, "--swiper-centered-offset-after", e.size / 2 - m[m.length - 1] / 2 + "px"); const t = -e.snapGrid[0],
                            s = -e.slidesGrid[0];
                        e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + s)) } if (p !== d && e.emit("slidesLengthChange"), u.length !== w && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), h.length !== b && e.emit("slidesGridLengthChange"), a.watchSlidesProgress && e.updateSlidesOffset(), !(o || a.cssMode || "slide" !== a.effect && "fade" !== a.effect)) { const t = `${a.containerModifierClass}backface-hidden`,
                            s = e.$el.hasClass(t);
                        p <= a.maxBackfaceHiddenSlides ? s || e.$el.addClass(t) : s && e.$el.removeClass(t) } }, updateAutoHeight: function(e) { const t = this,
                        s = [],
                        a = t.virtual && t.params.virtual.enabled; let i, r = 0; "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed); const n = e => a ? t.slides.filter((t => parseInt(t.getAttribute("data-swiper-slide-index"), 10) === e))[0] : t.slides.eq(e)[0]; if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
                        if (t.params.centeredSlides)(t.visibleSlides || d([])).each((e => { s.push(e) }));
                        else
                            for (i = 0; i < Math.ceil(t.params.slidesPerView); i += 1) { const e = t.activeIndex + i; if (e > t.slides.length && !a) break;
                                s.push(n(e)) } else s.push(n(t.activeIndex));
                    for (i = 0; i < s.length; i += 1)
                        if (void 0 !== s[i]) { const e = s[i].offsetHeight;
                            r = e > r ? e : r }(r || 0 === r) && t.$wrapperEl.css("height", `${r}px`) }, updateSlidesOffset: function() { const e = this,
                        t = e.slides; for (let s = 0; s < t.length; s += 1) t[s].swiperSlideOffset = e.isHorizontal() ? t[s].offsetLeft : t[s].offsetTop }, updateSlidesProgress: function(e) { void 0 === e && (e = this && this.translate || 0); const t = this,
                        s = t.params,
                        { slides: a, rtlTranslate: i, snapGrid: r } = t; if (0 === a.length) return;
                    void 0 === a[0].swiperSlideOffset && t.updateSlidesOffset(); let n = -e;
                    i && (n = e), a.removeClass(s.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = []; for (let e = 0; e < a.length; e += 1) { const l = a[e]; let o = l.swiperSlideOffset;
                        s.cssMode && s.centeredSlides && (o -= a[0].swiperSlideOffset); const d = (n + (s.centeredSlides ? t.minTranslate() : 0) - o) / (l.swiperSlideSize + s.spaceBetween),
                            c = (n - r[0] + (s.centeredSlides ? t.minTranslate() : 0) - o) / (l.swiperSlideSize + s.spaceBetween),
                            p = -(n - o),
                            u = p + t.slidesSizesGrid[e];
                        (p >= 0 && p < t.size - 1 || u > 1 && u <= t.size || p <= 0 && u >= t.size) && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(e), a.eq(e).addClass(s.slideVisibleClass)), l.progress = i ? -d : d, l.originalProgress = i ? -c : c }
                    t.visibleSlides = d(t.visibleSlides) }, updateProgress: function(e) { const t = this; if (void 0 === e) { const s = t.rtlTranslate ? -1 : 1;
                        e = t && t.translate && t.translate * s || 0 } const s = t.params,
                        a = t.maxTranslate() - t.minTranslate(); let { progress: i, isBeginning: r, isEnd: n } = t; const l = r,
                        o = n;
                    0 === a ? (i = 0, r = !0, n = !0) : (i = (e - t.minTranslate()) / a, r = i <= 0, n = i >= 1), Object.assign(t, { progress: i, isBeginning: r, isEnd: n }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), r && !l && t.emit("reachBeginning toEdge"), n && !o && t.emit("reachEnd toEdge"), (l && !r || o && !n) && t.emit("fromEdge"), t.emit("progress", i) }, updateSlidesClasses: function() { const e = this,
                        { slides: t, params: s, $wrapperEl: a, activeIndex: i, realIndex: r } = e,
                        n = e.virtual && s.virtual.enabled; let l;
                    t.removeClass(`${s.slideActiveClass} ${s.slideNextClass} ${s.slidePrevClass} ${s.slideDuplicateActiveClass} ${s.slideDuplicateNextClass} ${s.slideDuplicatePrevClass}`), l = n ? e.$wrapperEl.find(`.${s.slideClass}[data-swiper-slide-index="${i}"]`) : t.eq(i), l.addClass(s.slideActiveClass), s.loop && (l.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${r}"]`).addClass(s.slideDuplicateActiveClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${r}"]`).addClass(s.slideDuplicateActiveClass)); let o = l.nextAll(`.${s.slideClass}`).eq(0).addClass(s.slideNextClass);
                    s.loop && 0 === o.length && (o = t.eq(0), o.addClass(s.slideNextClass)); let d = l.prevAll(`.${s.slideClass}`).eq(0).addClass(s.slidePrevClass);
                    s.loop && 0 === d.length && (d = t.eq(-1), d.addClass(s.slidePrevClass)), s.loop && (o.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass), d.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass)), e.emitSlidesClasses() }, updateActiveIndex: function(e) { const t = this,
                        s = t.rtlTranslate ? t.translate : -t.translate,
                        { slidesGrid: a, snapGrid: i, params: r, activeIndex: n, realIndex: l, snapIndex: o } = t; let d, c = e; if (void 0 === c) { for (let e = 0; e < a.length; e += 1) void 0 !== a[e + 1] ? s >= a[e] && s < a[e + 1] - (a[e + 1] - a[e]) / 2 ? c = e : s >= a[e] && s < a[e + 1] && (c = e + 1) : s >= a[e] && (c = e);
                        r.normalizeSlideIndex && (c < 0 || void 0 === c) && (c = 0) } if (i.indexOf(s) >= 0) d = i.indexOf(s);
                    else { const e = Math.min(r.slidesPerGroupSkip, c);
                        d = e + Math.floor((c - e) / r.slidesPerGroup) } if (d >= i.length && (d = i.length - 1), c === n) return void(d !== o && (t.snapIndex = d, t.emit("snapIndexChange"))); const p = parseInt(t.slides.eq(c).attr("data-swiper-slide-index") || c, 10);
                    Object.assign(t, { snapIndex: d, realIndex: p, previousIndex: n, activeIndex: c }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), l !== p && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange") }, updateClickedSlide: function(e) { const t = this,
                        s = t.params,
                        a = d(e).closest(`.${s.slideClass}`)[0]; let i, r = !1; if (a)
                        for (let e = 0; e < t.slides.length; e += 1)
                            if (t.slides[e] === a) { r = !0, i = e; break }
                    if (!a || !r) return t.clickedSlide = void 0, void(t.clickedIndex = void 0);
                    t.clickedSlide = a, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(d(a).attr("data-swiper-slide-index"), 10) : t.clickedIndex = i, s.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } }; var M = { getTranslate: function(e) { void 0 === e && (e = this.isHorizontal() ? "x" : "y"); const { params: t, rtlTranslate: s, translate: a, $wrapperEl: i } = this; if (t.virtualTranslate) return s ? -a : a; if (t.cssMode) return a; let r = h(i[0], e); return s && (r = -r), r || 0 }, setTranslate: function(e, t) { const s = this,
                        { rtlTranslate: a, params: i, $wrapperEl: r, wrapperEl: n, progress: l } = s; let o, d = 0,
                        c = 0;
                    s.isHorizontal() ? d = a ? -e : e : c = e, i.roundLengths && (d = Math.floor(d), c = Math.floor(c)), i.cssMode ? n[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -d : -c : i.virtualTranslate || r.transform(`translate3d(${d}px, ${c}px, 0px)`), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? d : c; const p = s.maxTranslate() - s.minTranslate();
                    o = 0 === p ? 0 : (e - s.minTranslate()) / p, o !== l && s.updateProgress(e), s.emit("setTranslate", s.translate, t) }, minTranslate: function() { return -this.snapGrid[0] }, maxTranslate: function() { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function(e, t, s, a, i) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), void 0 === a && (a = !0); const r = this,
                        { params: n, wrapperEl: l } = r; if (r.animating && n.preventInteractionOnTransition) return !1; const o = r.minTranslate(),
                        d = r.maxTranslate(); let c; if (c = a && e > o ? o : a && e < d ? d : e, r.updateProgress(c), n.cssMode) { const e = r.isHorizontal(); if (0 === t) l[e ? "scrollLeft" : "scrollTop"] = -c;
                        else { if (!r.support.smoothScroll) return w({ swiper: r, targetPosition: -c, side: e ? "left" : "top" }), !0;
                            l.scrollTo({
                                [e ? "left" : "top"]: -c, behavior: "smooth" }) } return !0 } return 0 === t ? (r.setTransition(0), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function(e) { r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, s && r.emit("transitionEnd")) }), r.$wrapperEl[0].addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd))), !0 } };

            function P(e) { let { swiper: t, runCallbacks: s, direction: a, step: i } = e; const { activeIndex: r, previousIndex: n } = t; let l = a; if (l || (l = r > n ? "next" : r < n ? "prev" : "reset"), t.emit(`transition${i}`), s && r !== n) { if ("reset" === l) return void t.emit(`slideResetTransition${i}`);
                    t.emit(`slideChangeTransition${i}`), "next" === l ? t.emit(`slideNextTransition${i}`) : t.emit(`slidePrevTransition${i}`) } } var k = { slideTo: function(e, t, s, a, i) { if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "number" != typeof e && "string" != typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`); if ("string" == typeof e) { const t = parseInt(e, 10); if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
                        e = t } const r = this; let n = e;
                    n < 0 && (n = 0); const { params: l, snapGrid: o, slidesGrid: d, previousIndex: c, activeIndex: p, rtlTranslate: u, wrapperEl: h, enabled: m } = r; if (r.animating && l.preventInteractionOnTransition || !m && !a && !i) return !1; const f = Math.min(r.params.slidesPerGroupSkip, n); let g = f + Math.floor((n - f) / r.params.slidesPerGroup);
                    g >= o.length && (g = o.length - 1), (p || l.initialSlide || 0) === (c || 0) && s && r.emit("beforeSlideChangeStart"); const v = -o[g]; if (r.updateProgress(v), l.normalizeSlideIndex)
                        for (let e = 0; e < d.length; e += 1) { const t = -Math.floor(100 * v),
                                s = Math.floor(100 * d[e]),
                                a = Math.floor(100 * d[e + 1]);
                            void 0 !== d[e + 1] ? t >= s && t < a - (a - s) / 2 ? n = e : t >= s && t < a && (n = e + 1) : t >= s && (n = e) }
                    if (r.initialized && n !== p) { if (!r.allowSlideNext && v < r.translate && v < r.minTranslate()) return !1; if (!r.allowSlidePrev && v > r.translate && v > r.maxTranslate() && (p || 0) !== n) return !1 } let b; if (b = n > p ? "next" : n < p ? "prev" : "reset", u && -v === r.translate || !u && v === r.translate) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== l.effect && r.setTranslate(v), "reset" !== b && (r.transitionStart(s, b), r.transitionEnd(s, b)), !1; if (l.cssMode) { const e = r.isHorizontal(),
                            s = u ? v : -v; if (0 === t) { const t = r.virtual && r.params.virtual.enabled;
                            t && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), h[e ? "scrollLeft" : "scrollTop"] = s, t && requestAnimationFrame((() => { r.wrapperEl.style.scrollSnapType = "", r._swiperImmediateVirtual = !1 })) } else { if (!r.support.smoothScroll) return w({ swiper: r, targetPosition: s, side: e ? "left" : "top" }), !0;
                            h.scrollTo({
                                [e ? "left" : "top"]: s, behavior: "smooth" }) } return !0 } return r.setTransition(t), r.setTranslate(v), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, a), r.transitionStart(s, b), 0 === t ? r.transitionEnd(s, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function(e) { r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, b)) }), r.$wrapperEl[0].addEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function(e, t, s, a) { if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "string" == typeof e) { const t = parseInt(e, 10); if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
                        e = t } const i = this; let r = e; return i.params.loop && (r += i.loopedSlides), i.slideTo(r, t, s, a) }, slideNext: function(e, t, s) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const a = this,
                        { animating: i, enabled: r, params: n } = a; if (!r) return a; let l = n.slidesPerGroup; "auto" === n.slidesPerView && 1 === n.slidesPerGroup && n.slidesPerGroupAuto && (l = Math.max(a.slidesPerViewDynamic("current", !0), 1)); const o = a.activeIndex < n.slidesPerGroupSkip ? 1 : l; if (n.loop) { if (i && n.loopPreventsSlide) return !1;
                        a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft } return n.rewind && a.isEnd ? a.slideTo(0, e, t, s) : a.slideTo(a.activeIndex + o, e, t, s) }, slidePrev: function(e, t, s) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const a = this,
                        { params: i, animating: r, snapGrid: n, slidesGrid: l, rtlTranslate: o, enabled: d } = a; if (!d) return a; if (i.loop) { if (r && i.loopPreventsSlide) return !1;
                        a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft }

                    function c(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const p = c(o ? a.translate : -a.translate),
                        u = n.map((e => c(e))); let h = n[u.indexOf(p) - 1]; if (void 0 === h && i.cssMode) { let e;
                        n.forEach(((t, s) => { p >= t && (e = s) })), void 0 !== e && (h = n[e > 0 ? e - 1 : e]) } let m = 0; if (void 0 !== h && (m = l.indexOf(h), m < 0 && (m = a.activeIndex - 1), "auto" === i.slidesPerView && 1 === i.slidesPerGroup && i.slidesPerGroupAuto && (m = m - a.slidesPerViewDynamic("previous", !0) + 1, m = Math.max(m, 0))), i.rewind && a.isBeginning) { const i = a.params.virtual && a.params.virtual.enabled && a.virtual ? a.virtual.slides.length - 1 : a.slides.length - 1; return a.slideTo(i, e, t, s) } return a.slideTo(m, e, t, s) }, slideReset: function(e, t, s) { return void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), this.slideTo(this.activeIndex, e, t, s) }, slideToClosest: function(e, t, s, a) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === a && (a = .5); const i = this; let r = i.activeIndex; const n = Math.min(i.params.slidesPerGroupSkip, r),
                        l = n + Math.floor((r - n) / i.params.slidesPerGroup),
                        o = i.rtlTranslate ? i.translate : -i.translate; if (o >= i.snapGrid[l]) { const e = i.snapGrid[l];
                        o - e > (i.snapGrid[l + 1] - e) * a && (r += i.params.slidesPerGroup) } else { const e = i.snapGrid[l - 1];
                        o - e <= (i.snapGrid[l] - e) * a && (r -= i.params.slidesPerGroup) } return r = Math.max(r, 0), r = Math.min(r, i.slidesGrid.length - 1), i.slideTo(r, e, t, s) }, slideToClickedSlide: function() { const e = this,
                        { params: t, $wrapperEl: s } = e,
                        a = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let i, r = e.clickedIndex; if (t.loop) { if (e.animating) return;
                        i = parseInt(d(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? r < e.loopedSlides - a / 2 || r > e.slides.length - e.loopedSlides + a / 2 ? (e.loopFix(), r = s.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), p((() => { e.slideTo(r) }))) : e.slideTo(r) : r > e.slides.length - a ? (e.loopFix(), r = s.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), p((() => { e.slideTo(r) }))) : e.slideTo(r) } else e.slideTo(r) } }; var z = { loopCreate: function() { const e = this,
                        t = a(),
                        { params: s, $wrapperEl: i } = e,
                        r = i.children().length > 0 ? d(i.children()[0].parentNode) : i;
                    r.children(`.${s.slideClass}.${s.slideDuplicateClass}`).remove(); let n = r.children(`.${s.slideClass}`); if (s.loopFillGroupWithBlank) { const e = s.slidesPerGroup - n.length % s.slidesPerGroup; if (e !== s.slidesPerGroup) { for (let a = 0; a < e; a += 1) { const e = d(t.createElement("div")).addClass(`${s.slideClass} ${s.slideBlankClass}`);
                                r.append(e) }
                            n = r.children(`.${s.slideClass}`) } } "auto" !== s.slidesPerView || s.loopedSlides || (s.loopedSlides = n.length), e.loopedSlides = Math.ceil(parseFloat(s.loopedSlides || s.slidesPerView, 10)), e.loopedSlides += s.loopAdditionalSlides, e.loopedSlides > n.length && (e.loopedSlides = n.length); const l = [],
                        o = [];
                    n.each(((t, s) => { const a = d(t);
                        s < e.loopedSlides && o.push(t), s < n.length && s >= n.length - e.loopedSlides && l.push(t), a.attr("data-swiper-slide-index", s) })); for (let e = 0; e < o.length; e += 1) r.append(d(o[e].cloneNode(!0)).addClass(s.slideDuplicateClass)); for (let e = l.length - 1; e >= 0; e -= 1) r.prepend(d(l[e].cloneNode(!0)).addClass(s.slideDuplicateClass)) }, loopFix: function() { const e = this;
                    e.emit("beforeLoopFix"); const { activeIndex: t, slides: s, loopedSlides: a, allowSlidePrev: i, allowSlideNext: r, snapGrid: n, rtlTranslate: l } = e; let o;
                    e.allowSlidePrev = !0, e.allowSlideNext = !0; const d = -n[t] - e.getTranslate(); if (t < a) { o = s.length - 3 * a + t, o += a;
                        e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d) } else if (t >= s.length - a) { o = -s.length + t + a, o += a;
                        e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d) }
                    e.allowSlidePrev = i, e.allowSlideNext = r, e.emit("loopFix") }, loopDestroy: function() { const { $wrapperEl: e, params: t, slides: s } = this;
                    e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), s.removeAttr("data-swiper-slide-index") } };

            function L(e) { const t = this,
                    s = a(),
                    i = r(),
                    n = t.touchEventsData,
                    { params: l, touches: o, enabled: c } = t; if (!c) return; if (t.animating && l.preventInteractionOnTransition) return;!t.animating && l.cssMode && l.loop && t.loopFix(); let p = e;
                p.originalEvent && (p = p.originalEvent); let h = d(p.target); if ("wrapper" === l.touchEventsTarget && !h.closest(t.wrapperEl).length) return; if (n.isTouchEvent = "touchstart" === p.type, !n.isTouchEvent && "which" in p && 3 === p.which) return; if (!n.isTouchEvent && "button" in p && p.button > 0) return; if (n.isTouched && n.isMoved) return;!!l.noSwipingClass && "" !== l.noSwipingClass && p.target && p.target.shadowRoot && e.path && e.path[0] && (h = d(e.path[0])); const m = l.noSwipingSelector ? l.noSwipingSelector : `.${l.noSwipingClass}`,
                    f = !(!p.target || !p.target.shadowRoot); if (l.noSwiping && (f ? function(e, t) { return void 0 === t && (t = this),
                            function t(s) { if (!s || s === a() || s === r()) return null;
                                s.assignedSlot && (s = s.assignedSlot); const i = s.closest(e); return i || s.getRootNode ? i || t(s.getRootNode().host) : null }(t) }(m, h[0]) : h.closest(m)[0])) return void(t.allowClick = !0); if (l.swipeHandler && !h.closest(l.swipeHandler)[0]) return;
                o.currentX = "touchstart" === p.type ? p.targetTouches[0].pageX : p.pageX, o.currentY = "touchstart" === p.type ? p.targetTouches[0].pageY : p.pageY; const g = o.currentX,
                    v = o.currentY,
                    w = l.edgeSwipeDetection || l.iOSEdgeSwipeDetection,
                    b = l.edgeSwipeThreshold || l.iOSEdgeSwipeThreshold; if (w && (g <= b || g >= i.innerWidth - b)) { if ("prevent" !== w) return;
                    e.preventDefault() } if (Object.assign(n, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), o.startX = g, o.startY = v, n.touchStartTime = u(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, l.threshold > 0 && (n.allowThresholdMove = !1), "touchstart" !== p.type) { let e = !0;
                    h.is(n.focusableElements) && (e = !1, "SELECT" === h[0].nodeName && (n.isTouched = !1)), s.activeElement && d(s.activeElement).is(n.focusableElements) && s.activeElement !== h[0] && s.activeElement.blur(); const a = e && t.allowTouchMove && l.touchStartPreventDefault;!l.touchStartForcePreventDefault && !a || h[0].isContentEditable || p.preventDefault() }
                t.params.freeMode && t.params.freeMode.enabled && t.freeMode && t.animating && !l.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", p) }

            function O(e) { const t = a(),
                    s = this,
                    i = s.touchEventsData,
                    { params: r, touches: n, rtlTranslate: l, enabled: o } = s; if (!o) return; let c = e; if (c.originalEvent && (c = c.originalEvent), !i.isTouched) return void(i.startMoving && i.isScrolling && s.emit("touchMoveOpposite", c)); if (i.isTouchEvent && "touchmove" !== c.type) return; const p = "touchmove" === c.type && c.targetTouches && (c.targetTouches[0] || c.changedTouches[0]),
                    h = "touchmove" === c.type ? p.pageX : c.pageX,
                    m = "touchmove" === c.type ? p.pageY : c.pageY; if (c.preventedByNestedSwiper) return n.startX = h, void(n.startY = m); if (!s.allowTouchMove) return d(c.target).is(i.focusableElements) || (s.allowClick = !1), void(i.isTouched && (Object.assign(n, { startX: h, startY: m, currentX: h, currentY: m }), i.touchStartTime = u())); if (i.isTouchEvent && r.touchReleaseOnEdges && !r.loop)
                    if (s.isVertical()) { if (m < n.startY && s.translate <= s.maxTranslate() || m > n.startY && s.translate >= s.minTranslate()) return i.isTouched = !1, void(i.isMoved = !1) } else if (h < n.startX && s.translate <= s.maxTranslate() || h > n.startX && s.translate >= s.minTranslate()) return; if (i.isTouchEvent && t.activeElement && c.target === t.activeElement && d(c.target).is(i.focusableElements)) return i.isMoved = !0, void(s.allowClick = !1); if (i.allowTouchCallbacks && s.emit("touchMove", c), c.targetTouches && c.targetTouches.length > 1) return;
                n.currentX = h, n.currentY = m; const f = n.currentX - n.startX,
                    g = n.currentY - n.startY; if (s.params.threshold && Math.sqrt(f ** 2 + g ** 2) < s.params.threshold) return; if (void 0 === i.isScrolling) { let e;
                    s.isHorizontal() && n.currentY === n.startY || s.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : f * f + g * g >= 25 && (e = 180 * Math.atan2(Math.abs(g), Math.abs(f)) / Math.PI, i.isScrolling = s.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle) } if (i.isScrolling && s.emit("touchMoveOpposite", c), void 0 === i.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (i.startMoving = !0)), i.isScrolling) return void(i.isTouched = !1); if (!i.startMoving) return;
                s.allowClick = !1, !r.cssMode && c.cancelable && c.preventDefault(), r.touchMoveStopPropagation && !r.nested && c.stopPropagation(), i.isMoved || (r.loop && !r.cssMode && s.loopFix(), i.startTranslate = s.getTranslate(), s.setTransition(0), s.animating && s.$wrapperEl.trigger("webkitTransitionEnd transitionend"), i.allowMomentumBounce = !1, !r.grabCursor || !0 !== s.allowSlideNext && !0 !== s.allowSlidePrev || s.setGrabCursor(!0), s.emit("sliderFirstMove", c)), s.emit("sliderMove", c), i.isMoved = !0; let v = s.isHorizontal() ? f : g;
                n.diff = v, v *= r.touchRatio, l && (v = -v), s.swipeDirection = v > 0 ? "prev" : "next", i.currentTranslate = v + i.startTranslate; let w = !0,
                    b = r.resistanceRatio; if (r.touchReleaseOnEdges && (b = 0), v > 0 && i.currentTranslate > s.minTranslate() ? (w = !1, r.resistance && (i.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + i.startTranslate + v) ** b)) : v < 0 && i.currentTranslate < s.maxTranslate() && (w = !1, r.resistance && (i.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - i.startTranslate - v) ** b)), w && (c.preventedByNestedSwiper = !0), !s.allowSlideNext && "next" === s.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && "prev" === s.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.allowSlidePrev || s.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) { if (!(Math.abs(v) > r.threshold || i.allowThresholdMove)) return void(i.currentTranslate = i.startTranslate); if (!i.allowThresholdMove) return i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, void(n.diff = s.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY) }
                r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && s.freeMode || r.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), s.params.freeMode && r.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(i.currentTranslate), s.setTranslate(i.currentTranslate)) }

            function I(e) { const t = this,
                    s = t.touchEventsData,
                    { params: a, touches: i, rtlTranslate: r, slidesGrid: n, enabled: l } = t; if (!l) return; let o = e; if (o.originalEvent && (o = o.originalEvent), s.allowTouchCallbacks && t.emit("touchEnd", o), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && a.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void(s.startMoving = !1);
                a.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const d = u(),
                    c = d - s.touchStartTime; if (t.allowClick) { const e = o.path || o.composedPath && o.composedPath();
                    t.updateClickedSlide(e && e[0] || o.target), t.emit("tap click", o), c < 300 && d - s.lastClickTime < 300 && t.emit("doubleTap doubleClick", o) } if (s.lastClickTime = u(), p((() => { t.destroyed || (t.allowClick = !0) })), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === i.diff || s.currentTranslate === s.startTranslate) return s.isTouched = !1, s.isMoved = !1, void(s.startMoving = !1); let h; if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, h = a.followFinger ? r ? t.translate : -t.translate : -s.currentTranslate, a.cssMode) return; if (t.params.freeMode && a.freeMode.enabled) return void t.freeMode.onTouchEnd({ currentPos: h }); let m = 0,
                    f = t.slidesSizesGrid[0]; for (let e = 0; e < n.length; e += e < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) { const t = e < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
                    void 0 !== n[e + t] ? h >= n[e] && h < n[e + t] && (m = e, f = n[e + t] - n[e]) : h >= n[e] && (m = e, f = n[n.length - 1] - n[n.length - 2]) } let g = null,
                    v = null;
                a.rewind && (t.isBeginning ? v = t.params.virtual && t.params.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (g = 0)); const w = (h - n[m]) / f,
                    b = m < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; if (c > a.longSwipesMs) { if (!a.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (w >= a.longSwipesRatio ? t.slideTo(a.rewind && t.isEnd ? g : m + b) : t.slideTo(m)), "prev" === t.swipeDirection && (w > 1 - a.longSwipesRatio ? t.slideTo(m + b) : null !== v && w < 0 && Math.abs(w) > a.longSwipesRatio ? t.slideTo(v) : t.slideTo(m)) } else { if (!a.shortSwipes) return void t.slideTo(t.activeIndex);
                    t.navigation && (o.target === t.navigation.nextEl || o.target === t.navigation.prevEl) ? o.target === t.navigation.nextEl ? t.slideTo(m + b) : t.slideTo(m) : ("next" === t.swipeDirection && t.slideTo(null !== g ? g : m + b), "prev" === t.swipeDirection && t.slideTo(null !== v ? v : m)) } }

            function A() { const e = this,
                    { params: t, el: s } = e; if (s && 0 === s.offsetWidth) return;
                t.breakpoints && e.setBreakpoint(); const { allowSlideNext: a, allowSlidePrev: i, snapGrid: r } = e;
                e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = i, e.allowSlideNext = a, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow() }

            function D(e) { const t = this;
                t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) }

            function G() { const e = this,
                    { wrapperEl: t, rtlTranslate: s, enabled: a } = e; if (!a) return; let i;
                e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const r = e.maxTranslate() - e.minTranslate();
                i = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, i !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } let N = !1;

            function B() {} const H = (e, t) => { const s = a(),
                    { params: i, touchEvents: r, el: n, wrapperEl: l, device: o, support: d } = e,
                    c = !!i.nested,
                    p = "on" === t ? "addEventListener" : "removeEventListener",
                    u = t; if (d.touch) { const t = !("touchstart" !== r.start || !d.passiveListener || !i.passiveListeners) && { passive: !0, capture: !1 };
                    n[p](r.start, e.onTouchStart, t), n[p](r.move, e.onTouchMove, d.passiveListener ? { passive: !1, capture: c } : c), n[p](r.end, e.onTouchEnd, t), r.cancel && n[p](r.cancel, e.onTouchEnd, t) } else n[p](r.start, e.onTouchStart, !1), s[p](r.move, e.onTouchMove, c), s[p](r.end, e.onTouchEnd, !1);
                (i.preventClicks || i.preventClicksPropagation) && n[p]("click", e.onClick, !0), i.cssMode && l[p]("scroll", e.onScroll), i.updateOnWindowResize ? e[u](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", A, !0) : e[u]("observerUpdate", A, !0) }; var X = { attachEvents: function() { const e = this,
                        t = a(),
                        { params: s, support: i } = e;
                    e.onTouchStart = L.bind(e), e.onTouchMove = O.bind(e), e.onTouchEnd = I.bind(e), s.cssMode && (e.onScroll = G.bind(e)), e.onClick = D.bind(e), i.touch && !N && (t.addEventListener("touchstart", B), N = !0), H(e, "on") }, detachEvents: function() { H(this, "off") } }; const Y = (e, t) => e.grid && t.grid && t.grid.rows > 1; var R = { addClasses: function() { const e = this,
                        { classNames: t, params: s, rtl: a, $el: i, device: r, support: n } = e,
                        l = function(e, t) { const s = []; return e.forEach((e => { "object" == typeof e ? Object.keys(e).forEach((a => { e[a] && s.push(t + a) })) : "string" == typeof e && s.push(t + e) })), s }(["initialized", s.direction, { "pointer-events": !n.touch }, { "free-mode": e.params.freeMode && s.freeMode.enabled }, { autoheight: s.autoHeight }, { rtl: a }, { grid: s.grid && s.grid.rows > 1 }, { "grid-column": s.grid && s.grid.rows > 1 && "column" === s.grid.fill }, { android: r.android }, { ios: r.ios }, { "css-mode": s.cssMode }, { centered: s.cssMode && s.centeredSlides }, { "watch-progress": s.watchSlidesProgress }], s.containerModifierClass);
                    t.push(...l), i.addClass([...t].join(" ")), e.emitContainerClasses() }, removeClasses: function() { const { $el: e, classNames: t } = this;
                    e.removeClass(t.join(" ")), this.emitContainerClasses() } }; var W = { init: !0, direction: "horizontal", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopFillGroupWithBlank: !1, loopPreventsSlide: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-invisible-blank", slideActiveClass: "swiper-slide-active", slideDuplicateActiveClass: "swiper-slide-duplicate-active", slideVisibleClass: "swiper-slide-visible", slideDuplicateClass: "swiper-slide-duplicate", slideNextClass: "swiper-slide-next", slideDuplicateNextClass: "swiper-slide-duplicate-next", slidePrevClass: "swiper-slide-prev", slideDuplicatePrevClass: "swiper-slide-duplicate-prev", wrapperClass: "swiper-wrapper", runCallbacksOnInit: !0, _emitClasses: !1 };

            function j(e, t) { return function(s) { void 0 === s && (s = {}); const a = Object.keys(s)[0],
                        i = s[a]; "object" == typeof i && null !== i ? (["navigation", "pagination", "scrollbar"].indexOf(a) >= 0 && !0 === e[a] && (e[a] = { auto: !0 }), a in e && "enabled" in i ? (!0 === e[a] && (e[a] = { enabled: !0 }), "object" != typeof e[a] || "enabled" in e[a] || (e[a].enabled = !0), e[a] || (e[a] = { enabled: !1 }), g(t, s)) : g(t, s)) : g(t, s) } } const _ = { eventsEmitter: $, update: S, translate: M, transition: { setTransition: function(e, t) { const s = this;
                            s.params.cssMode || s.$wrapperEl.transition(e), s.emit("setTransition", e, t) }, transitionStart: function(e, t) { void 0 === e && (e = !0); const s = this,
                                { params: a } = s;
                            a.cssMode || (a.autoHeight && s.updateAutoHeight(), P({ swiper: s, runCallbacks: e, direction: t, step: "Start" })) }, transitionEnd: function(e, t) { void 0 === e && (e = !0); const s = this,
                                { params: a } = s;
                            s.animating = !1, a.cssMode || (s.setTransition(0), P({ swiper: s, runCallbacks: e, direction: t, step: "End" })) } }, slide: k, loop: z, grabCursor: { setGrabCursor: function(e) { const t = this; if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const s = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
                            s.style.cursor = "move", s.style.cursor = e ? "grabbing" : "grab" }, unsetGrabCursor: function() { const e = this;
                            e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "") } }, events: X, breakpoints: { setBreakpoint: function() { const e = this,
                                { activeIndex: t, initialized: s, loopedSlides: a = 0, params: i, $el: r } = e,
                                n = i.breakpoints; if (!n || n && 0 === Object.keys(n).length) return; const l = e.getBreakpoint(n, e.params.breakpointsBase, e.el); if (!l || e.currentBreakpoint === l) return; const o = (l in n ? n[l] : void 0) || e.originalParams,
                                d = Y(e, i),
                                c = Y(e, o),
                                p = i.enabled;
                            d && !c ? (r.removeClass(`${i.containerModifierClass}grid ${i.containerModifierClass}grid-column`), e.emitContainerClasses()) : !d && c && (r.addClass(`${i.containerModifierClass}grid`), (o.grid.fill && "column" === o.grid.fill || !o.grid.fill && "column" === i.grid.fill) && r.addClass(`${i.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((t => { const s = i[t] && i[t].enabled,
                                    a = o[t] && o[t].enabled;
                                s && !a && e[t].disable(), !s && a && e[t].enable() })); const u = o.direction && o.direction !== i.direction,
                                h = i.loop && (o.slidesPerView !== i.slidesPerView || u);
                            u && s && e.changeDirection(), g(e.params, o); const m = e.params.enabled;
                            Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), p && !m ? e.disable() : !p && m && e.enable(), e.currentBreakpoint = l, e.emit("_beforeBreakpoint", o), h && s && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - a + e.loopedSlides, 0, !1)), e.emit("breakpoint", o) }, getBreakpoint: function(e, t, s) { if (void 0 === t && (t = "window"), !e || "container" === t && !s) return; let a = !1; const i = r(),
                                n = "window" === t ? i.innerHeight : s.clientHeight,
                                l = Object.keys(e).map((e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: n * t, point: e } } return { value: e, point: e } }));
                            l.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let e = 0; e < l.length; e += 1) { const { point: r, value: n } = l[e]; "window" === t ? i.matchMedia(`(min-width: ${n}px)`).matches && (a = r) : n <= s.clientWidth && (a = r) } return a || "max" } }, checkOverflow: { checkOverflow: function() { const e = this,
                                { isLocked: t, params: s } = e,
                                { slidesOffsetBefore: a } = s; if (a) { const t = e.slides.length - 1,
                                    s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * a;
                                e.isLocked = e.size > s } else e.isLocked = 1 === e.snapGrid.length;!0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } }, classes: R, images: { loadImage: function(e, t, s, a, i, n) { const l = r(); let o;

                            function c() { n && n() }
                            d(e).parent("picture")[0] || e.complete && i ? c() : t ? (o = new l.Image, o.onload = c, o.onerror = c, a && (o.sizes = a), s && (o.srcset = s), t && (o.src = t)) : c() }, preloadImages: function() { const e = this;

                            function t() { null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady"))) }
                            e.imagesToLoad = e.$el.find("img"); for (let s = 0; s < e.imagesToLoad.length; s += 1) { const a = e.imagesToLoad[s];
                                e.loadImage(a, a.currentSrc || a.getAttribute("src"), a.srcset || a.getAttribute("srcset"), a.sizes || a.getAttribute("sizes"), !0, t) } } } },
                q = {};
            class V { constructor() { let e, t; for (var s = arguments.length, a = new Array(s), i = 0; i < s; i++) a[i] = arguments[i]; if (1 === a.length && a[0].constructor && "Object" === Object.prototype.toString.call(a[0]).slice(8, -1) ? t = a[0] : [e, t] = a, t || (t = {}), t = g({}, t), e && !t.el && (t.el = e), t.el && d(t.el).length > 1) { const e = []; return d(t.el).each((s => { const a = g({}, t, { el: s });
                            e.push(new V(a)) })), e } const r = this;
                    r.__swiper__ = !0, r.support = E(), r.device = C({ userAgent: t.userAgent }), r.browser = T(), r.eventsListeners = {}, r.eventsAnyListeners = [], r.modules = [...r.__modules__], t.modules && Array.isArray(t.modules) && r.modules.push(...t.modules); const n = {};
                    r.modules.forEach((e => { e({ swiper: r, extendParams: j(t, n), on: r.on.bind(r), once: r.once.bind(r), off: r.off.bind(r), emit: r.emit.bind(r) }) })); const l = g({}, W, n); return r.params = g({}, l, q, t), r.originalParams = g({}, r.params), r.passedParams = g({}, t), r.params && r.params.on && Object.keys(r.params.on).forEach((e => { r.on(e, r.params.on[e]) })), r.params && r.params.onAny && r.onAny(r.params.onAny), r.$ = d, Object.assign(r, { enabled: r.params.enabled, el: e, classNames: [], slides: d(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === r.params.direction, isVertical: () => "vertical" === r.params.direction, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, allowSlideNext: r.params.allowSlideNext, allowSlidePrev: r.params.allowSlidePrev, touchEvents: function() { const e = ["touchstart", "touchmove", "touchend", "touchcancel"],
                                t = ["pointerdown", "pointermove", "pointerup"]; return r.touchEventsTouch = { start: e[0], move: e[1], end: e[2], cancel: e[3] }, r.touchEventsDesktop = { start: t[0], move: t[1], end: t[2] }, r.support.touch || !r.params.simulateTouch ? r.touchEventsTouch : r.touchEventsDesktop }(), touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: r.params.focusableElements, lastClickTime: u(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0 }, allowClick: !0, allowTouchMove: r.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), r.emit("_swiper"), r.params.init && r.init(), r }
                enable() { const e = this;
                    e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) }
                disable() { const e = this;
                    e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) }
                setProgress(e, t) { const s = this;
                    e = Math.min(Math.max(e, 0), 1); const a = s.minTranslate(),
                        i = (s.maxTranslate() - a) * e + a;
                    s.translateTo(i, void 0 === t ? 0 : t), s.updateActiveIndex(), s.updateSlidesClasses() }
                emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)));
                    e.emit("_containerClasses", t.join(" ")) }
                getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ") }
                emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = [];
                    e.slides.each((s => { const a = e.getSlideClasses(s);
                        t.push({ slideEl: s, classNames: a }), e.emit("_slideClass", s, a) })), e.emit("_slideClasses", t) }
                slidesPerViewDynamic(e, t) { void 0 === e && (e = "current"), void 0 === t && (t = !1); const { params: s, slides: a, slidesGrid: i, slidesSizesGrid: r, size: n, activeIndex: l } = this; let o = 1; if (s.centeredSlides) { let e, t = a[l].swiperSlideSize; for (let s = l + 1; s < a.length; s += 1) a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0)); for (let s = l - 1; s >= 0; s -= 1) a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0)) } else if ("current" === e)
                        for (let e = l + 1; e < a.length; e += 1) {
                            (t ? i[e] + r[e] - i[l] < n : i[e] - i[l] < n) && (o += 1) } else
                            for (let e = l - 1; e >= 0; e -= 1) { i[l] - i[e] < n && (o += 1) }
                    return o }
                update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: s } = e;

                    function a() { const t = e.rtlTranslate ? -1 * e.translate : e.translate,
                            s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
                        e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses() } let i;
                    s.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (a(), e.params.autoHeight && e.updateAutoHeight()) : (i = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), i || a()), s.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") }
                changeDirection(e, t) { void 0 === t && (t = !0); const s = this,
                        a = s.params.direction; return e || (e = "horizontal" === a ? "vertical" : "horizontal"), e === a || "horizontal" !== e && "vertical" !== e || (s.$el.removeClass(`${s.params.containerModifierClass}${a}`).addClass(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.each((t => { "vertical" === e ? t.style.width = "" : t.style.height = "" })), s.emit("changeDirection"), t && s.update()), s }
                mount(e) { const t = this; if (t.mounted) return !0; const s = d(e || t.params.el); if (!(e = s[0])) return !1;
                    e.swiper = t; const i = () => `.${(t.params.wrapperClass||"").trim().split(" ").join(".")}`; let r = (() => { if (e && e.shadowRoot && e.shadowRoot.querySelector) { const t = d(e.shadowRoot.querySelector(i())); return t.children = e => s.children(e), t } return s.children ? s.children(i()) : d(s).children(i()) })(); if (0 === r.length && t.params.createElements) { const e = a().createElement("div");
                        r = d(e), e.className = t.params.wrapperClass, s.append(e), s.children(`.${t.params.slideClass}`).each((e => { r.append(e) })) } return Object.assign(t, { $el: s, el: e, $wrapperEl: r, wrapperEl: r[0], mounted: !0, rtl: "rtl" === e.dir.toLowerCase() || "rtl" === s.css("direction"), rtlTranslate: "horizontal" === t.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === s.css("direction")), wrongRTL: "-webkit-box" === r.css("display") }), !0 }
                init(e) { const t = this; if (t.initialized) return t; return !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit("init"), t.emit("afterInit")), t }
                destroy(e, t) { void 0 === e && (e = !0), void 0 === t && (t = !0); const s = this,
                        { params: a, $el: i, $wrapperEl: r, slides: n } = s; return void 0 === s.params || s.destroyed || (s.emit("beforeDestroy"), s.initialized = !1, s.detachEvents(), a.loop && s.loopDestroy(), t && (s.removeClasses(), i.removeAttr("style"), r.removeAttr("style"), n && n.length && n.removeClass([a.slideVisibleClass, a.slideActiveClass, a.slideNextClass, a.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), s.emit("destroy"), Object.keys(s.eventsListeners).forEach((e => { s.off(e) })), !1 !== e && (s.$el[0].swiper = null, function(e) { const t = e;
                        Object.keys(t).forEach((e => { try { t[e] = null } catch (e) {} try { delete t[e] } catch (e) {} })) }(s)), s.destroyed = !0), null }
                static extendDefaults(e) { g(q, e) }
                static get extendedDefaults() { return q }
                static get defaults() { return W }
                static installModule(e) { V.prototype.__modules__ || (V.prototype.__modules__ = []); const t = V.prototype.__modules__; "function" == typeof e && t.indexOf(e) < 0 && t.push(e) }
                static use(e) { return Array.isArray(e) ? (e.forEach((e => V.installModule(e))), V) : (V.installModule(e), V) } }

            function F(e, t, s, i) { const r = a(); return e.params.createElements && Object.keys(i).forEach((a => { if (!s[a] && !0 === s.auto) { let n = e.$el.children(`.${i[a]}`)[0];
                        n || (n = r.createElement("div"), n.className = i[a], e.$el.append(n)), s[a] = n, t[a] = n } })), s }

            function U(e) { return void 0 === e && (e = ""), `.${e.trim().replace(/([\.:!\/])/g,"\\$1").replace(/ /g,".")}` }

            function K(e) { const t = this,
                    { $wrapperEl: s, params: a } = t; if (a.loop && t.loopDestroy(), "object" == typeof e && "length" in e)
                    for (let t = 0; t < e.length; t += 1) e[t] && s.append(e[t]);
                else s.append(e);
                a.loop && t.loopCreate(), a.observer || t.update() }

            function Z(e) { const t = this,
                    { params: s, $wrapperEl: a, activeIndex: i } = t;
                s.loop && t.loopDestroy(); let r = i + 1; if ("object" == typeof e && "length" in e) { for (let t = 0; t < e.length; t += 1) e[t] && a.prepend(e[t]);
                    r = i + e.length } else a.prepend(e);
                s.loop && t.loopCreate(), s.observer || t.update(), t.slideTo(r, 0, !1) }

            function Q(e, t) { const s = this,
                    { $wrapperEl: a, params: i, activeIndex: r } = s; let n = r;
                i.loop && (n -= s.loopedSlides, s.loopDestroy(), s.slides = a.children(`.${i.slideClass}`)); const l = s.slides.length; if (e <= 0) return void s.prependSlide(t); if (e >= l) return void s.appendSlide(t); let o = n > e ? n + 1 : n; const d = []; for (let t = l - 1; t >= e; t -= 1) { const e = s.slides.eq(t);
                    e.remove(), d.unshift(e) } if ("object" == typeof t && "length" in t) { for (let e = 0; e < t.length; e += 1) t[e] && a.append(t[e]);
                    o = n > e ? n + t.length : n } else a.append(t); for (let e = 0; e < d.length; e += 1) a.append(d[e]);
                i.loop && s.loopCreate(), i.observer || s.update(), i.loop ? s.slideTo(o + s.loopedSlides, 0, !1) : s.slideTo(o, 0, !1) }

            function J(e) { const t = this,
                    { params: s, $wrapperEl: a, activeIndex: i } = t; let r = i;
                s.loop && (r -= t.loopedSlides, t.loopDestroy(), t.slides = a.children(`.${s.slideClass}`)); let n, l = r; if ("object" == typeof e && "length" in e) { for (let s = 0; s < e.length; s += 1) n = e[s], t.slides[n] && t.slides.eq(n).remove(), n < l && (l -= 1);
                    l = Math.max(l, 0) } else n = e, t.slides[n] && t.slides.eq(n).remove(), n < l && (l -= 1), l = Math.max(l, 0);
                s.loop && t.loopCreate(), s.observer || t.update(), s.loop ? t.slideTo(l + t.loopedSlides, 0, !1) : t.slideTo(l, 0, !1) }

            function ee() { const e = this,
                    t = []; for (let s = 0; s < e.slides.length; s += 1) t.push(s);
                e.removeSlide(t) }

            function te(e) { const { effect: t, swiper: s, on: a, setTranslate: i, setTransition: r, overwriteParams: n, perspective: l, recreateShadows: o, getEffectParams: d } = e; let c;
                a("beforeInit", (() => { if (s.params.effect !== t) return;
                    s.classNames.push(`${s.params.containerModifierClass}${t}`), l && l() && s.classNames.push(`${s.params.containerModifierClass}3d`); const e = n ? n() : {};
                    Object.assign(s.params, e), Object.assign(s.originalParams, e) })), a("setTranslate", (() => { s.params.effect === t && i() })), a("setTransition", ((e, a) => { s.params.effect === t && r(a) })), a("transitionEnd", (() => { if (s.params.effect === t && o) { if (!d || !d().slideShadows) return;
                        s.slides.each((e => { s.$(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").remove() })), o() } })), a("virtualUpdate", (() => { s.params.effect === t && (s.slides.length || (c = !0), requestAnimationFrame((() => { c && s.slides && s.slides.length && (i(), c = !1) }))) })) }

            function se(e, t) { return e.transformEl ? t.find(e.transformEl).css({ "backface-visibility": "hidden", "-webkit-backface-visibility": "hidden" }) : t }

            function ae(e) { let { swiper: t, duration: s, transformEl: a, allSlides: i } = e; const { slides: r, activeIndex: n, $wrapperEl: l } = t; if (t.params.virtualTranslate && 0 !== s) { let e, s = !1;
                    e = i ? a ? r.find(a) : r : a ? r.eq(n).find(a) : r.eq(n), e.transitionEnd((() => { if (s) return; if (!t || t.destroyed) return;
                        s = !0, t.animating = !1; const e = ["webkitTransitionEnd", "transitionend"]; for (let t = 0; t < e.length; t += 1) l.trigger(e[t]) })) } }

            function ie(e, t, s) { const a = "swiper-slide-shadow" + (s ? `-${s}` : ""),
                    i = e.transformEl ? t.find(e.transformEl) : t; let r = i.children(`.${a}`); return r.length || (r = d(`<div class="swiper-slide-shadow${s?`-${s}`:""}"></div>`),i.append(r)),r}Object.keys(_).forEach((e=>{Object.keys(_[e]).forEach((t=>{V.prototype[t]=_[e][t]}))})),V.use([function(e){let{swiper:t,on:s,emit:a}=e;const i=r();let n=null,l=null;const o=()=>{t&&!t.destroyed&&t.initialized&&(a("beforeResize"),a("resize"))},d=()=>{t&&!t.destroyed&&t.initialized&&a("orientationchange")};s("init",(()=>{t.params.resizeObserver&&void 0!==i.ResizeObserver?t&&!t.destroyed&&t.initialized&&(n=new ResizeObserver((e=>{l=i.requestAnimationFrame((()=>{const{width:s,height:a}=t;let i=s,r=a;e.forEach((e=>{let{contentBoxSize:s,contentRect:a,target:n}=e;n&&n!==t.el||(i=a?a.width:(s[0]||s).inlineSize,r=a?a.height:(s[0]||s).blockSize)})),i===s&&r===a||o()}))})),n.observe(t.el)):(i.addEventListener("resize",o),i.addEventListener("orientationchange",d))})),s("destroy",(()=>{l&&i.cancelAnimationFrame(l),n&&n.unobserve&&t.el&&(n.unobserve(t.el),n=null),i.removeEventListener("resize",o),i.removeEventListener("orientationchange",d)}))},function(e){let{swiper:t,extendParams:s,on:a,emit:i}=e;const n=[],l=r(),o=function(e,t){void 0===t&&(t={});const s=new(l.MutationObserver||l.WebkitMutationObserver)((e=>{if(1===e.length)return void i("observerUpdate",e[0]);const t=function(){i("observerUpdate",e[0])};l.requestAnimationFrame?l.requestAnimationFrame(t):l.setTimeout(t,0)}));s.observe(e,{attributes:void 0===t.attributes||t.attributes,childList:void 0===t.childList||t.childList,characterData:void 0===t.characterData||t.characterData}),n.push(s)};s({observer:!1,observeParents:!1,observeSlideChildren:!1}),a("init",(()=>{if(t.params.observer){if(t.params.observeParents){const e=t.$el.parents();for(let t=0;t<e.length;t+=1)o(e[t])}o(t.$el[0],{childList:t.params.observeSlideChildren}),o(t.$wrapperEl[0],{attributes:!1})}})),a("destroy",(()=>{n.forEach((e=>{e.disconnect()})),n.splice(0,n.length)}))}]);const re=[function(e){let t,{swiper:s,extendParams:a,on:i,emit:r}=e;function n(e,t){const a=s.params.virtual;if(a.cache&&s.virtual.cache[t])return s.virtual.cache[t];const i=a.renderSlide?d(a.renderSlide.call(s,e,t)):d(`<div class="${s.params.slideClass}" data-swiper-slide-index="${t}">${e}</div>`);return i.attr("data-swiper-slide-index")||i.attr("data-swiper-slide-index",t),a.cache&&(s.virtual.cache[t]=i),i}function l(e){const{slidesPerView:t,slidesPerGroup:a,centeredSlides:i}=s.params,{addSlidesBefore:l,addSlidesAfter:o}=s.params.virtual,{from:d,to:c,slides:p,slidesGrid:u,offset:h}=s.virtual;s.params.cssMode||s.updateActiveIndex();const m=s.activeIndex||0;let f,g,v;f=s.rtlTranslate?"right":s.isHorizontal()?"left":"top",i?(g=Math.floor(t/2)+a+o,v=Math.floor(t/2)+a+l):(g=t+(a-1)+o,v=a+l);const w=Math.max((m||0)-v,0),b=Math.min((m||0)+g,p.length-1),x=(s.slidesGrid[w]||0)-(s.slidesGrid[0]||0);function y(){s.updateSlides(),s.updateProgress(),s.updateSlidesClasses(),s.lazy&&s.params.lazy.enabled&&s.lazy.load(),r("virtualUpdate")}if(Object.assign(s.virtual,{from:w,to:b,offset:x,slidesGrid:s.slidesGrid}),d===w&&c===b&&!e)return s.slidesGrid!==u&&x!==h&&s.slides.css(f,`${x}px`),s.updateProgress(),void r("virtualUpdate");if(s.params.virtual.renderExternal)return s.params.virtual.renderExternal.call(s,{offset:x,from:w,to:b,slides:function(){const e=[];for(let t=w;t<=b;t+=1)e.push(p[t]);return e}()}),void(s.params.virtual.renderExternalUpdate?y():r("virtualUpdate"));const E=[],C=[];if(e)s.$wrapperEl.find(`.${s.params.slideClass}`).remove();else for(let e=d;e<=c;e+=1)(e<w||e>b)&&s.$wrapperEl.find(`.${s.params.slideClass}[data-swiper-slide-index="${e}"]`).remove();for(let t=0;t<p.length;t+=1)t>=w&&t<=b&&(void 0===c||e?C.push(t):(t>c&&C.push(t),t<d&&E.push(t)));C.forEach((e=>{s.$wrapperEl.append(n(p[e],e))})),E.sort(((e,t)=>t-e)).forEach((e=>{s.$wrapperEl.prepend(n(p[e],e))})),s.$wrapperEl.children(".swiper-slide").css(f,`${x}px`),y()}a({virtual:{enabled:!1,slides:[],cache:!0,renderSlide:null,renderExternal:null,renderExternalUpdate:!0,addSlidesBefore:0,addSlidesAfter:0}}),s.virtual={cache:{},from:void 0,to:void 0,slides:[],offset:0,slidesGrid:[]},i("beforeInit",(()=>{s.params.virtual.enabled&&(s.virtual.slides=s.params.virtual.slides,s.classNames.push(`${s.params.containerModifierClass}virtual`),s.params.watchSlidesProgress=!0,s.originalParams.watchSlidesProgress=!0,s.params.initialSlide||l())})),i("setTranslate",(()=>{s.params.virtual.enabled&&(s.params.cssMode&&!s._immediateVirtual?(clearTimeout(t),t=setTimeout((()=>{l()}),100)):l())})),i("init update resize",(()=>{s.params.virtual.enabled&&s.params.cssMode&&v(s.wrapperEl,"--swiper-virtual-size",`${s.virtualSize}px`)})),Object.assign(s.virtual,{appendSlide:function(e){if("object"==typeof e&&"length"in e)for(let t=0;t<e.length;t+=1)e[t]&&s.virtual.slides.push(e[t]);else s.virtual.slides.push(e);l(!0)},prependSlide:function(e){const t=s.activeIndex;let a=t+1,i=1;if(Array.isArray(e)){for(let t=0;t<e.length;t+=1)e[t]&&s.virtual.slides.unshift(e[t]);a=t+e.length,i=e.length}else s.virtual.slides.unshift(e);if(s.params.virtual.cache){const e=s.virtual.cache,t={};Object.keys(e).forEach((s=>{const a=e[s],r=a.attr("data-swiper-slide-index");r&&a.attr("data-swiper-slide-index",parseInt(r,10)+i),t[parseInt(s,10)+i]=a})),s.virtual.cache=t}l(!0),s.slideTo(a,0)},removeSlide:function(e){if(null==e)return;let t=s.activeIndex;if(Array.isArray(e))for(let a=e.length-1;a>=0;a-=1)s.virtual.slides.splice(e[a],1),s.params.virtual.cache&&delete s.virtual.cache[e[a]],e[a]<t&&(t-=1),t=Math.max(t,0);else s.virtual.slides.splice(e,1),s.params.virtual.cache&&delete s.virtual.cache[e],e<t&&(t-=1),t=Math.max(t,0);l(!0),s.slideTo(t,0)},removeAllSlides:function(){s.virtual.slides=[],s.params.virtual.cache&&(s.virtual.cache={}),l(!0),s.slideTo(0,0)},update:l})},function(e){let{swiper:t,extendParams:s,on:i,emit:n}=e;const l=a(),o=r();function c(e){if(!t.enabled)return;const{rtlTranslate:s}=t;let a=e;a.originalEvent&&(a=a.originalEvent);const i=a.keyCode||a.charCode,r=t.params.keyboard.pageUpDown,d=r&&33===i,c=r&&34===i,p=37===i,u=39===i,h=38===i,m=40===i;if(!t.allowSlideNext&&(t.isHorizontal()&&u||t.isVertical()&&m||c))return!1;if(!t.allowSlidePrev&&(t.isHorizontal()&&p||t.isVertical()&&h||d))return!1;if(!(a.shiftKey||a.altKey||a.ctrlKey||a.metaKey||l.activeElement&&l.activeElement.nodeName&&("input"===l.activeElement.nodeName.toLowerCase()||"textarea"===l.activeElement.nodeName.toLowerCase()))){if(t.params.keyboard.onlyInViewport&&(d||c||p||u||h||m)){let e=!1;if(t.$el.parents(`.${t.params.slideClass}`).length>0&&0===t.$el.parents(`.${t.params.slideActiveClass}`).length)return;const a=t.$el,i=a[0].clientWidth,r=a[0].clientHeight,n=o.innerWidth,l=o.innerHeight,d=t.$el.offset();s&&(d.left-=t.$el[0].scrollLeft);const c=[[d.left,d.top],[d.left+i,d.top],[d.left,d.top+r],[d.left+i,d.top+r]];for(let t=0;t<c.length;t+=1){const s=c[t];if(s[0]>=0&&s[0]<=n&&s[1]>=0&&s[1]<=l){if(0===s[0]&&0===s[1])continue;e=!0}}if(!e)return}t.isHorizontal()?((d||c||p||u)&&(a.preventDefault?a.preventDefault():a.returnValue=!1),((c||u)&&!s||(d||p)&&s)&&t.slideNext(),((d||p)&&!s||(c||u)&&s)&&t.slidePrev()):((d||c||h||m)&&(a.preventDefault?a.preventDefault():a.returnValue=!1),(c||m)&&t.slideNext(),(d||h)&&t.slidePrev()),n("keyPress",i)}}function p(){t.keyboard.enabled||(d(l).on("keydown",c),t.keyboard.enabled=!0)}function u(){t.keyboard.enabled&&(d(l).off("keydown",c),t.keyboard.enabled=!1)}t.keyboard={enabled:!1},s({keyboard:{enabled:!1,onlyInViewport:!0,pageUpDown:!0}}),i("init",(()=>{t.params.keyboard.enabled&&p()})),i("destroy",(()=>{t.keyboard.enabled&&u()})),Object.assign(t.keyboard,{enable:p,disable:u})},function(e){let{swiper:t,extendParams:s,on:a,emit:i}=e;const n=r();let l;s({mousewheel:{enabled:!1,releaseOnEdges:!1,invert:!1,forceToAxis:!1,sensitivity:1,eventsTarget:"container",thresholdDelta:null,thresholdTime:null}}),t.mousewheel={enabled:!1};let o,c=u();const h=[];function m(){t.enabled&&(t.mouseEntered=!0)}function f(){t.enabled&&(t.mouseEntered=!1)}function g(e){return!(t.params.mousewheel.thresholdDelta&&e.delta<t.params.mousewheel.thresholdDelta)&&(!(t.params.mousewheel.thresholdTime&&u()-c<t.params.mousewheel.thresholdTime)&&(e.delta>=6&&u()-c<60||(e.direction<0?t.isEnd&&!t.params.loop||t.animating||(t.slideNext(),i("scroll",e.raw)):t.isBeginning&&!t.params.loop||t.animating||(t.slidePrev(),i("scroll",e.raw)),c=(new n.Date).getTime(),!1)))}function v(e){let s=e,a=!0;if(!t.enabled)return;const r=t.params.mousewheel;t.params.cssMode&&s.preventDefault();let n=t.$el;if("container"!==t.params.mousewheel.eventsTarget&&(n=d(t.params.mousewheel.eventsTarget)),!t.mouseEntered&&!n[0].contains(s.target)&&!r.releaseOnEdges)return!0;s.originalEvent&&(s=s.originalEvent);let c=0;const m=t.rtlTranslate?-1:1,f=function(e){let t=0,s=0,a=0,i=0;return"detail"in e&&(s=e.detail),"wheelDelta"in e&&(s=-e.wheelDelta/120),"wheelDeltaY"in e&&(s=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=s,s=0),a=10*t,i=10*s,"deltaY"in e&&(i=e.deltaY),"deltaX"in e&&(a=e.deltaX),e.shiftKey&&!a&&(a=i,i=0),(a||i)&&e.deltaMode&&(1===e.deltaMode?(a*=40,i*=40):(a*=800,i*=800)),a&&!t&&(t=a<1?-1:1),i&&!s&&(s=i<1?-1:1),{spinX:t,spinY:s,pixelX:a,pixelY:i}}(s);if(r.forceToAxis)if(t.isHorizontal()){if(!(Math.abs(f.pixelX)>Math.abs(f.pixelY)))return!0;c=-f.pixelX*m}else{if(!(Math.abs(f.pixelY)>Math.abs(f.pixelX)))return!0;c=-f.pixelY}else c=Math.abs(f.pixelX)>Math.abs(f.pixelY)?-f.pixelX*m:-f.pixelY;if(0===c)return!0;r.invert&&(c=-c);let v=t.getTranslate()+c*r.sensitivity;if(v>=t.minTranslate()&&(v=t.minTranslate()),v<=t.maxTranslate()&&(v=t.maxTranslate()),a=!!t.params.loop||!(v===t.minTranslate()||v===t.maxTranslate()),a&&t.params.nested&&s.stopPropagation(),t.params.freeMode&&t.params.freeMode.enabled){const e={time:u(),delta:Math.abs(c),direction:Math.sign(c)},a=o&&e.time<o.time+500&&e.delta<=o.delta&&e.direction===o.direction;if(!a){o=void 0,t.params.loop&&t.loopFix();let n=t.getTranslate()+c*r.sensitivity;const d=t.isBeginning,u=t.isEnd;if(n>=t.minTranslate()&&(n=t.minTranslate()),n<=t.maxTranslate()&&(n=t.maxTranslate()),t.setTransition(0),t.setTranslate(n),t.updateProgress(),t.updateActiveIndex(),t.updateSlidesClasses(),(!d&&t.isBeginning||!u&&t.isEnd)&&t.updateSlidesClasses(),t.params.freeMode.sticky){clearTimeout(l),l=void 0,h.length>=15&&h.shift();const s=h.length?h[h.length-1]:void 0,a=h[0];if(h.push(e),s&&(e.delta>s.delta||e.direction!==s.direction))h.splice(0);else if(h.length>=15&&e.time-a.time<500&&a.delta-e.delta>=1&&e.delta<=6){const s=c>0?.8:.2;o=e,h.splice(0),l=p((()=>{t.slideToClosest(t.params.speed,!0,void 0,s)}),0)}l||(l=p((()=>{o=e,h.splice(0),t.slideToClosest(t.params.speed,!0,void 0,.5)}),500))}if(a||i("scroll",s),t.params.autoplay&&t.params.autoplayDisableOnInteraction&&t.autoplay.stop(),n===t.minTranslate()||n===t.maxTranslate())return!0}}else{const s={time:u(),delta:Math.abs(c),direction:Math.sign(c),raw:e};h.length>=2&&h.shift();const a=h.length?h[h.length-1]:void 0;if(h.push(s),a?(s.direction!==a.direction||s.delta>a.delta||s.time>a.time+150)&&g(s):g(s),function(e){const s=t.params.mousewheel;if(e.direction<0){if(t.isEnd&&!t.params.loop&&s.releaseOnEdges)return!0}else if(t.isBeginning&&!t.params.loop&&s.releaseOnEdges)return!0;return!1}(s))return!0}return s.preventDefault?s.preventDefault():s.returnValue=!1,!1}function w(e){let s=t.$el;"container"!==t.params.mousewheel.eventsTarget&&(s=d(t.params.mousewheel.eventsTarget)),s[e]("mouseenter",m),s[e]("mouseleave",f),s[e]("wheel",v)}function b(){return t.params.cssMode?(t.wrapperEl.removeEventListener("wheel",v),!0):!t.mousewheel.enabled&&(w("on"),t.mousewheel.enabled=!0,!0)}function x(){return t.params.cssMode?(t.wrapperEl.addEventListener(event,v),!0):!!t.mousewheel.enabled&&(w("off"),t.mousewheel.enabled=!1,!0)}a("init",(()=>{!t.params.mousewheel.enabled&&t.params.cssMode&&x(),t.params.mousewheel.enabled&&b()})),a("destroy",(()=>{t.params.cssMode&&b(),t.mousewheel.enabled&&x()})),Object.assign(t.mousewheel,{enable:b,disable:x})},function(e){let{swiper:t,extendParams:s,on:a,emit:i}=e;function r(e){let s;return e&&(s=d(e),t.params.uniqueNavElements&&"string"==typeof e&&s.length>1&&1===t.$el.find(e).length&&(s=t.$el.find(e))),s}function n(e,s){const a=t.params.navigation;e&&e.length>0&&(e[s?"addClass":"removeClass"](a.disabledClass),e[0]&&"BUTTON"===e[0].tagName&&(e[0].disabled=s),t.params.watchOverflow&&t.enabled&&e[t.isLocked?"addClass":"removeClass"](a.lockClass))}function l(){if(t.params.loop)return;const{$nextEl:e,$prevEl:s}=t.navigation;n(s,t.isBeginning&&!t.params.rewind),n(e,t.isEnd&&!t.params.rewind)}function o(e){e.preventDefault(),(!t.isBeginning||t.params.loop||t.params.rewind)&&t.slidePrev()}function c(e){e.preventDefault(),(!t.isEnd||t.params.loop||t.params.rewind)&&t.slideNext()}function p(){const e=t.params.navigation;if(t.params.navigation=F(t,t.originalParams.navigation,t.params.navigation,{nextEl:"swiper-button-next",prevEl:"swiper-button-prev"}),!e.nextEl&&!e.prevEl)return;const s=r(e.nextEl),a=r(e.prevEl);s&&s.length>0&&s.on("click",c),a&&a.length>0&&a.on("click",o),Object.assign(t.navigation,{$nextEl:s,nextEl:s&&s[0],$prevEl:a,prevEl:a&&a[0]}),t.enabled||(s&&s.addClass(e.lockClass),a&&a.addClass(e.lockClass))}function u(){const{$nextEl:e,$prevEl:s}=t.navigation;e&&e.length&&(e.off("click",c),e.removeClass(t.params.navigation.disabledClass)),s&&s.length&&(s.off("click",o),s.removeClass(t.params.navigation.disabledClass))}s({navigation:{nextEl:null,prevEl:null,hideOnClick:!1,disabledClass:"swiper-button-disabled",hiddenClass:"swiper-button-hidden",lockClass:"swiper-button-lock",navigationDisabledClass:"swiper-navigation-disabled"}}),t.navigation={nextEl:null,$nextEl:null,prevEl:null,$prevEl:null},a("init",(()=>{!1===t.params.navigation.enabled?h():(p(),l())})),a("toEdge fromEdge lock unlock",(()=>{l()})),a("destroy",(()=>{u()})),a("enable disable",(()=>{const{$nextEl:e,$prevEl:s}=t.navigation;e&&e[t.enabled?"removeClass":"addClass"](t.params.navigation.lockClass),s&&s[t.enabled?"removeClass":"addClass"](t.params.navigation.lockClass)})),a("click",((e,s)=>{const{$nextEl:a,$prevEl:r}=t.navigation,n=s.target;if(t.params.navigation.hideOnClick&&!d(n).is(r)&&!d(n).is(a)){if(t.pagination&&t.params.pagination&&t.params.pagination.clickable&&(t.pagination.el===n||t.pagination.el.contains(n)))return;let e;a?e=a.hasClass(t.params.navigation.hiddenClass):r&&(e=r.hasClass(t.params.navigation.hiddenClass)),i(!0===e?"navigationShow":"navigationHide"),a&&a.toggleClass(t.params.navigation.hiddenClass),r&&r.toggleClass(t.params.navigation.hiddenClass)}}));const h=()=>{t.$el.addClass(t.params.navigation.navigationDisabledClass),u()};Object.assign(t.navigation,{enable:()=>{t.$el.removeClass(t.params.navigation.navigationDisabledClass),p(),l()},disable:h,update:l,init:p,destroy:u})},function(e){let{swiper:t,extendParams:s,on:a,emit:i}=e;const r="swiper-pagination";let n;s({pagination:{el:null,bulletElement:"span",clickable:!1,hideOnClick:!1,renderBullet:null,renderProgressbar:null,renderFraction:null,renderCustom:null,progressbarOpposite:!1,type:"bullets",dynamicBullets:!1,dynamicMainBullets:1,formatFractionCurrent:e=>e,formatFractionTotal:e=>e,bulletClass:`${r}-bullet`,bulletActiveClass:`${r}-bullet-active`,modifierClass:`${r}-`,currentClass:`${r}-current`,totalClass:`${r}-total`,hiddenClass:`${r}-hidden`,progressbarFillClass:`${r}-progressbar-fill`,progressbarOppositeClass:`${r}-progressbar-opposite`,clickableClass:`${r}-clickable`,lockClass:`${r}-lock`,horizontalClass:`${r}-horizontal`,verticalClass:`${r}-vertical`,paginationDisabledClass:`${r}-disabled`}}),t.pagination={el:null,$el:null,bullets:[]};let l=0;function o(){return!t.params.pagination.el||!t.pagination.el||!t.pagination.$el||0===t.pagination.$el.length}function c(e,s){const{bulletActiveClass:a}=t.params.pagination;e[s]().addClass(`${a}-${s}`)[s]().addClass(`${a}-${s}-${s}`)}function p(){const e=t.rtl,s=t.params.pagination;if(o())return;const a=t.virtual&&t.params.virtual.enabled?t.virtual.slides.length:t.slides.length,r=t.pagination.$el;let p;const u=t.params.loop?Math.ceil((a-2*t.loopedSlides)/t.params.slidesPerGroup):t.snapGrid.length;if(t.params.loop?(p=Math.ceil((t.activeIndex-t.loopedSlides)/t.params.slidesPerGroup),p>a-1-2*t.loopedSlides&&(p-=a-2*t.loopedSlides),p>u-1&&(p-=u),p<0&&"bullets"!==t.params.paginationType&&(p=u+p)):p=void 0!==t.snapIndex?t.snapIndex:t.activeIndex||0,"bullets"===s.type&&t.pagination.bullets&&t.pagination.bullets.length>0){const a=t.pagination.bullets;let i,o,u;if(s.dynamicBullets&&(n=a.eq(0)[t.isHorizontal()?"outerWidth":"outerHeight"](!0),r.css(t.isHorizontal()?"width":"height",n*(s.dynamicMainBullets+4)+"px"),s.dynamicMainBullets>1&&void 0!==t.previousIndex&&(l+=p-(t.previousIndex-t.loopedSlides||0),l>s.dynamicMainBullets-1?l=s.dynamicMainBullets-1:l<0&&(l=0)),i=Math.max(p-l,0),o=i+(Math.min(a.length,s.dynamicMainBullets)-1),u=(o+i)/2),a.removeClass(["","-next","-next-next","-prev","-prev-prev","-main"].map((e=>`${s.bulletActiveClass}${e}`)).join(" ")),r.length>1)a.each((e=>{const t=d(e),a=t.index();a===p&&t.addClass(s.bulletActiveClass),s.dynamicBullets&&(a>=i&&a<=o&&t.addClass(`${s.bulletActiveClass}-main`),a===i&&c(t,"prev"),a===o&&c(t,"next"))}));else{const e=a.eq(p),r=e.index();if(e.addClass(s.bulletActiveClass),s.dynamicBullets){const e=a.eq(i),n=a.eq(o);for(let e=i;e<=o;e+=1)a.eq(e).addClass(`${s.bulletActiveClass}-main`);if(t.params.loop)if(r>=a.length){for(let e=s.dynamicMainBullets;e>=0;e-=1)a.eq(a.length-e).addClass(`${s.bulletActiveClass}-main`);a.eq(a.length-s.dynamicMainBullets-1).addClass(`${s.bulletActiveClass}-prev`)}else c(e,"prev"),c(n,"next");else c(e,"prev"),c(n,"next")}}if(s.dynamicBullets){const i=Math.min(a.length,s.dynamicMainBullets+4),r=(n*i-n)/2-u*n,l=e?"right":"left";a.css(t.isHorizontal()?l:"top",`${r}px`)}}if("fraction"===s.type&&(r.find(U(s.currentClass)).text(s.formatFractionCurrent(p+1)),r.find(U(s.totalClass)).text(s.formatFractionTotal(u))),"progressbar"===s.type){let e;e=s.progressbarOpposite?t.isHorizontal()?"vertical":"horizontal":t.isHorizontal()?"horizontal":"vertical";const a=(p+1)/u;let i=1,n=1;"horizontal"===e?i=a:n=a,r.find(U(s.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${i}) scaleY(${n})`).transition(t.params.speed)}"custom"===s.type&&s.renderCustom?(r.html(s.renderCustom(t,p+1,u)),i("paginationRender",r[0])):i("paginationUpdate",r[0]),t.params.watchOverflow&&t.enabled&&r[t.isLocked?"addClass":"removeClass"](s.lockClass)}function u(){const e=t.params.pagination;if(o())return;const s=t.virtual&&t.params.virtual.enabled?t.virtual.slides.length:t.slides.length,a=t.pagination.$el;let r="";if("bullets"===e.type){let i=t.params.loop?Math.ceil((s-2*t.loopedSlides)/t.params.slidesPerGroup):t.snapGrid.length;t.params.freeMode&&t.params.freeMode.enabled&&!t.params.loop&&i>s&&(i=s);for(let s=0;s<i;s+=1)e.renderBullet?r+=e.renderBullet.call(t,s,e.bulletClass):r+=`<${e.bulletElement} class="${e.bulletClass}"></${e.bulletElement}>`;a.html(r),t.pagination.bullets=a.find(U(e.bulletClass))}"fraction"===e.type&&(r=e.renderFraction?e.renderFraction.call(t,e.currentClass,e.totalClass):`<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`,a.html(r)),"progressbar"===e.type&&(r=e.renderProgressbar?e.renderProgressbar.call(t,e.progressbarFillClass):`<span class="${e.progressbarFillClass}"></span>`,a.html(r)),"custom"!==e.type&&i("paginationRender",t.pagination.$el[0])}function h(){t.params.pagination=F(t,t.originalParams.pagination,t.params.pagination,{el:"swiper-pagination"});const e=t.params.pagination;if(!e.el)return;let s=d(e.el);0!==s.length&&(t.params.uniqueNavElements&&"string"==typeof e.el&&s.length>1&&(s=t.$el.find(e.el),s.length>1&&(s=s.filter((e=>d(e).parents(".swiper")[0]===t.el)))),"bullets"===e.type&&e.clickable&&s.addClass(e.clickableClass),s.addClass(e.modifierClass+e.type),s.addClass(t.isHorizontal()?e.horizontalClass:e.verticalClass),"bullets"===e.type&&e.dynamicBullets&&(s.addClass(`${e.modifierClass}${e.type}-dynamic`),l=0,e.dynamicMainBullets<1&&(e.dynamicMainBullets=1)),"progressbar"===e.type&&e.progressbarOpposite&&s.addClass(e.progressbarOppositeClass),e.clickable&&s.on("click",U(e.bulletClass),(function(e){e.preventDefault();let s=d(this).index()*t.params.slidesPerGroup;t.params.loop&&(s+=t.loopedSlides),t.slideTo(s)})),Object.assign(t.pagination,{$el:s,el:s[0]}),t.enabled||s.addClass(e.lockClass))}function m(){const e=t.params.pagination;if(o())return;const s=t.pagination.$el;s.removeClass(e.hiddenClass),s.removeClass(e.modifierClass+e.type),s.removeClass(t.isHorizontal()?e.horizontalClass:e.verticalClass),t.pagination.bullets&&t.pagination.bullets.removeClass&&t.pagination.bullets.removeClass(e.bulletActiveClass),e.clickable&&s.off("click",U(e.bulletClass))}a("init",(()=>{!1===t.params.pagination.enabled?f():(h(),u(),p())})),a("activeIndexChange",(()=>{(t.params.loop||void 0===t.snapIndex)&&p()})),a("snapIndexChange",(()=>{t.params.loop||p()})),a("slidesLengthChange",(()=>{t.params.loop&&(u(),p())})),a("snapGridLengthChange",(()=>{t.params.loop||(u(),p())})),a("destroy",(()=>{m()})),a("enable disable",(()=>{const{$el:e}=t.pagination;e&&e[t.enabled?"removeClass":"addClass"](t.params.pagination.lockClass)})),a("lock unlock",(()=>{p()})),a("click",((e,s)=>{const a=s.target,{$el:r}=t.pagination;if(t.params.pagination.el&&t.params.pagination.hideOnClick&&r.length>0&&!d(a).hasClass(t.params.pagination.bulletClass)){if(t.navigation&&(t.navigation.nextEl&&a===t.navigation.nextEl||t.navigation.prevEl&&a===t.navigation.prevEl))return;const e=r.hasClass(t.params.pagination.hiddenClass);i(!0===e?"paginationShow":"paginationHide"),r.toggleClass(t.params.pagination.hiddenClass)}}));const f=()=>{t.$el.addClass(t.params.pagination.paginationDisabledClass),t.pagination.$el&&t.pagination.$el.addClass(t.params.pagination.paginationDisabledClass),m()};Object.assign(t.pagination,{enable:()=>{t.$el.removeClass(t.params.pagination.paginationDisabledClass),t.pagination.$el&&t.pagination.$el.removeClass(t.params.pagination.paginationDisabledClass),h(),u(),p()},disable:f,render:u,update:p,init:h,destroy:m})},function(e){let{swiper:t,extendParams:s,on:i,emit:r}=e;const n=a();let l,o,c,u,h=!1,m=null,f=null;function g(){if(!t.params.scrollbar.el||!t.scrollbar.el)return;const{scrollbar:e,rtlTranslate:s,progress:a}=t,{$dragEl:i,$el:r}=e,n=t.params.scrollbar;let l=o,d=(c-o)*a;s?(d=-d,d>0?(l=o-d,d=0):-d+o>c&&(l=c+d)):d<0?(l=o+d,d=0):d+o>c&&(l=c-d),t.isHorizontal()?(i.transform(`translate3d(${d}px, 0, 0)`),i[0].style.width=`${l}px`):(i.transform(`translate3d(0px, ${d}px, 0)`),i[0].style.height=`${l}px`),n.hide&&(clearTimeout(m),r[0].style.opacity=1,m=setTimeout((()=>{r[0].style.opacity=0,r.transition(400)}),1e3))}function v(){if(!t.params.scrollbar.el||!t.scrollbar.el)return;const{scrollbar:e}=t,{$dragEl:s,$el:a}=e;s[0].style.width="",s[0].style.height="",c=t.isHorizontal()?a[0].offsetWidth:a[0].offsetHeight,u=t.size/(t.virtualSize+t.params.slidesOffsetBefore-(t.params.centeredSlides?t.snapGrid[0]:0)),o="auto"===t.params.scrollbar.dragSize?c*u:parseInt(t.params.scrollbar.dragSize,10),t.isHorizontal()?s[0].style.width=`${o}px`:s[0].style.height=`${o}px`,a[0].style.display=u>=1?"none":"",t.params.scrollbar.hide&&(a[0].style.opacity=0),t.params.watchOverflow&&t.enabled&&e.$el[t.isLocked?"addClass":"removeClass"](t.params.scrollbar.lockClass)}function w(e){return t.isHorizontal()?"touchstart"===e.type||"touchmove"===e.type?e.targetTouches[0].clientX:e.clientX:"touchstart"===e.type||"touchmove"===e.type?e.targetTouches[0].clientY:e.clientY}function b(e){const{scrollbar:s,rtlTranslate:a}=t,{$el:i}=s;let r;r=(w(e)-i.offset()[t.isHorizontal()?"left":"top"]-(null!==l?l:o/2))/(c-o),r=Math.max(Math.min(r,1),0),a&&(r=1-r);const n=t.minTranslate()+(t.maxTranslate()-t.minTranslate())*r;t.updateProgress(n),t.setTranslate(n),t.updateActiveIndex(),t.updateSlidesClasses()}function x(e){const s=t.params.scrollbar,{scrollbar:a,$wrapperEl:i}=t,{$el:n,$dragEl:o}=a;h=!0,l=e.target===o[0]||e.target===o?w(e)-e.target.getBoundingClientRect()[t.isHorizontal()?"left":"top"]:null,e.preventDefault(),e.stopPropagation(),i.transition(100),o.transition(100),b(e),clearTimeout(f),n.transition(0),s.hide&&n.css("opacity",1),t.params.cssMode&&t.$wrapperEl.css("scroll-snap-type","none"),r("scrollbarDragStart",e)}function y(e){const{scrollbar:s,$wrapperEl:a}=t,{$el:i,$dragEl:n}=s;h&&(e.preventDefault?e.preventDefault():e.returnValue=!1,b(e),a.transition(0),i.transition(0),n.transition(0),r("scrollbarDragMove",e))}function E(e){const s=t.params.scrollbar,{scrollbar:a,$wrapperEl:i}=t,{$el:n}=a;h&&(h=!1,t.params.cssMode&&(t.$wrapperEl.css("scroll-snap-type",""),i.transition("")),s.hide&&(clearTimeout(f),f=p((()=>{n.css("opacity",0),n.transition(400)}),1e3)),r("scrollbarDragEnd",e),s.snapOnRelease&&t.slideToClosest())}function C(e){const{scrollbar:s,touchEventsTouch:a,touchEventsDesktop:i,params:r,support:l}=t,o=s.$el;if(!o)return;const d=o[0],c=!(!l.passiveListener||!r.passiveListeners)&&{passive:!1,capture:!1},p=!(!l.passiveListener||!r.passiveListeners)&&{passive:!0,capture:!1};if(!d)return;const u="on"===e?"addEventListener":"removeEventListener";l.touch?(d[u](a.start,x,c),d[u](a.move,y,c),d[u](a.end,E,p)):(d[u](i.start,x,c),n[u](i.move,y,c),n[u](i.end,E,p))}function T(){const{scrollbar:e,$el:s}=t;t.params.scrollbar=F(t,t.originalParams.scrollbar,t.params.scrollbar,{el:"swiper-scrollbar"});const a=t.params.scrollbar;if(!a.el)return;let i=d(a.el);t.params.uniqueNavElements&&"string"==typeof a.el&&i.length>1&&1===s.find(a.el).length&&(i=s.find(a.el)),i.addClass(t.isHorizontal()?a.horizontalClass:a.verticalClass);let r=i.find(`.${t.params.scrollbar.dragClass}`);0===r.length&&(r=d(`<div class="${t.params.scrollbar.dragClass}"></div>`),i.append(r)),Object.assign(e,{$el:i,el:i[0],$dragEl:r,dragEl:r[0]}),a.draggable&&t.params.scrollbar.el&&t.scrollbar.el&&C("on"),i&&i[t.enabled?"removeClass":"addClass"](t.params.scrollbar.lockClass)}function $(){const e=t.params.scrollbar,s=t.scrollbar.$el;s&&s.removeClass(t.isHorizontal()?e.horizontalClass:e.verticalClass),t.params.scrollbar.el&&t.scrollbar.el&&C("off")}s({scrollbar:{el:null,dragSize:"auto",hide:!1,draggable:!1,snapOnRelease:!0,lockClass:"swiper-scrollbar-lock",dragClass:"swiper-scrollbar-drag",scrollbarDisabledClass:"swiper-scrollbar-disabled",horizontalClass:"swiper-scrollbar-horizontal",verticalClass:"swiper-scrollbar-vertical"}}),t.scrollbar={el:null,dragEl:null,$el:null,$dragEl:null},i("init",(()=>{!1===t.params.scrollbar.enabled?S():(T(),v(),g())})),i("update resize observerUpdate lock unlock",(()=>{v()})),i("setTranslate",(()=>{g()})),i("setTransition",((e,s)=>{!function(e){t.params.scrollbar.el&&t.scrollbar.el&&t.scrollbar.$dragEl.transition(e)}(s)})),i("enable disable",(()=>{const{$el:e}=t.scrollbar;e&&e[t.enabled?"removeClass":"addClass"](t.params.scrollbar.lockClass)})),i("destroy",(()=>{$()}));const S=()=>{t.$el.addClass(t.params.scrollbar.scrollbarDisabledClass),t.scrollbar.$el&&t.scrollbar.$el.addClass(t.params.scrollbar.scrollbarDisabledClass),$()};Object.assign(t.scrollbar,{enable:()=>{t.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass),t.scrollbar.$el&&t.scrollbar.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass),T(),v(),g()},disable:S,updateSize:v,setTranslate:g,init:T,destroy:$})},function(e){let{swiper:t,extendParams:s,on:a}=e;s({parallax:{enabled:!1}});const i=(e,s)=>{const{rtl:a}=t,i=d(e),r=a?-1:1,n=i.attr("data-swiper-parallax")||"0";let l=i.attr("data-swiper-parallax-x"),o=i.attr("data-swiper-parallax-y");const c=i.attr("data-swiper-parallax-scale"),p=i.attr("data-swiper-parallax-opacity");if(l||o?(l=l||"0",o=o||"0"):t.isHorizontal()?(l=n,o="0"):(o=n,l="0"),l=l.indexOf("%")>=0?parseInt(l,10)*s*r+"%":l*s*r+"px",o=o.indexOf("%")>=0?parseInt(o,10)*s+"%":o*s+"px",null!=p){const e=p-(p-1)*(1-Math.abs(s));i[0].style.opacity=e}if(null==c)i.transform(`translate3d(${l}, ${o}, 0px)`);else{const e=c-(c-1)*(1-Math.abs(s));i.transform(`translate3d(${l}, ${o}, 0px) scale(${e})`)}},r=()=>{const{$el:e,slides:s,progress:a,snapGrid:r}=t;e.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e=>{i(e,a)})),s.each(((e,s)=>{let n=e.progress;t.params.slidesPerGroup>1&&"auto"!==t.params.slidesPerView&&(n+=Math.ceil(s/2)-a*(r.length-1)),n=Math.min(Math.max(n,-1),1),d(e).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e=>{i(e,n)}))}))};a("beforeInit",(()=>{t.params.parallax.enabled&&(t.params.watchSlidesProgress=!0,t.originalParams.watchSlidesProgress=!0)})),a("init",(()=>{t.params.parallax.enabled&&r()})),a("setTranslate",(()=>{t.params.parallax.enabled&&r()})),a("setTransition",((e,s)=>{t.params.parallax.enabled&&function(e){void 0===e&&(e=t.params.speed);const{$el:s}=t;s.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t=>{const s=d(t);let a=parseInt(s.attr("data-swiper-parallax-duration"),10)||e;0===e&&(a=0),s.transition(a)}))}(s)}))},function(e){let{swiper:t,extendParams:s,on:a,emit:i}=e;const n=r();s({zoom:{enabled:!1,maxRatio:3,minRatio:1,toggle:!0,containerClass:"swiper-zoom-container",zoomedSlideClass:"swiper-slide-zoomed"}}),t.zoom={enabled:!1};let l,o,c,p=1,u=!1;const m={$slideEl:void 0,slideWidth:void 0,slideHeight:void 0,$imageEl:void 0,$imageWrapEl:void 0,maxRatio:3},f={isTouched:void 0,isMoved:void 0,currentX:void 0,currentY:void 0,minX:void 0,minY:void 0,maxX:void 0,maxY:void 0,width:void 0,height:void 0,startX:void 0,startY:void 0,touchesStart:{},touchesCurrent:{}},g={x:void 0,y:void 0,prevPositionX:void 0,prevPositionY:void 0,prevTime:void 0};let v=1;function w(e){if(e.targetTouches.length<2)return 1;const t=e.targetTouches[0].pageX,s=e.targetTouches[0].pageY,a=e.targetTouches[1].pageX,i=e.targetTouches[1].pageY;return Math.sqrt((a-t)**2+(i-s)**2)}function b(e){const s=t.support,a=t.params.zoom;if(o=!1,c=!1,!s.gestures){if("touchstart"!==e.type||"touchstart"===e.type&&e.targetTouches.length<2)return;o=!0,m.scaleStart=w(e)}m.$slideEl&&m.$slideEl.length||(m.$slideEl=d(e.target).closest(`.${t.params.slideClass}`),0===m.$slideEl.length&&(m.$slideEl=t.slides.eq(t.activeIndex)),m.$imageEl=m.$slideEl.find(`.${a.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0),m.$imageWrapEl=m.$imageEl.parent(`.${a.containerClass}`),m.maxRatio=m.$imageWrapEl.attr("data-swiper-zoom")||a.maxRatio,0!==m.$imageWrapEl.length)?(m.$imageEl&&m.$imageEl.transition(0),u=!0):m.$imageEl=void 0}function x(e){const s=t.support,a=t.params.zoom,i=t.zoom;if(!s.gestures){if("touchmove"!==e.type||"touchmove"===e.type&&e.targetTouches.length<2)return;c=!0,m.scaleMove=w(e)}m.$imageEl&&0!==m.$imageEl.length?(s.gestures?i.scale=e.scale*p:i.scale=m.scaleMove/m.scaleStart*p,i.scale>m.maxRatio&&(i.scale=m.maxRatio-1+(i.scale-m.maxRatio+1)**.5),i.scale<a.minRatio&&(i.scale=a.minRatio+1-(a.minRatio-i.scale+1)**.5),m.$imageEl.transform(`translate3d(0,0,0) scale(${i.scale})`)):"gesturechange"===e.type&&b(e)}function y(e){const s=t.device,a=t.support,i=t.params.zoom,r=t.zoom;if(!a.gestures){if(!o||!c)return;if("touchend"!==e.type||"touchend"===e.type&&e.changedTouches.length<2&&!s.android)return;o=!1,c=!1}m.$imageEl&&0!==m.$imageEl.length&&(r.scale=Math.max(Math.min(r.scale,m.maxRatio),i.minRatio),m.$imageEl.transition(t.params.speed).transform(`translate3d(0,0,0) scale(${r.scale})`),p=r.scale,u=!1,1===r.scale&&(m.$slideEl=void 0))}function E(e){const s=t.zoom;if(!m.$imageEl||0===m.$imageEl.length)return;if(t.allowClick=!1,!f.isTouched||!m.$slideEl)return;f.isMoved||(f.width=m.$imageEl[0].offsetWidth,f.height=m.$imageEl[0].offsetHeight,f.startX=h(m.$imageWrapEl[0],"x")||0,f.startY=h(m.$imageWrapEl[0],"y")||0,m.slideWidth=m.$slideEl[0].offsetWidth,m.slideHeight=m.$slideEl[0].offsetHeight,m.$imageWrapEl.transition(0));const a=f.width*s.scale,i=f.height*s.scale;if(!(a<m.slideWidth&&i<m.slideHeight)){if(f.minX=Math.min(m.slideWidth/2-a/2,0),f.maxX=-f.minX,f.minY=Math.min(m.slideHeight/2-i/2,0),f.maxY=-f.minY,f.touchesCurrent.x="touchmove"===e.type?e.targetTouches[0].pageX:e.pageX,f.touchesCurrent.y="touchmove"===e.type?e.targetTouches[0].pageY:e.pageY,!f.isMoved&&!u){if(t.isHorizontal()&&(Math.floor(f.minX)===Math.floor(f.startX)&&f.touchesCurrent.x<f.touchesStart.x||Math.floor(f.maxX)===Math.floor(f.startX)&&f.touchesCurrent.x>f.touchesStart.x))return void(f.isTouched=!1);if(!t.isHorizontal()&&(Math.floor(f.minY)===Math.floor(f.startY)&&f.touchesCurrent.y<f.touchesStart.y||Math.floor(f.maxY)===Math.floor(f.startY)&&f.touchesCurrent.y>f.touchesStart.y))return void(f.isTouched=!1)}e.cancelable&&e.preventDefault(),e.stopPropagation(),f.isMoved=!0,f.currentX=f.touchesCurrent.x-f.touchesStart.x+f.startX,f.currentY=f.touchesCurrent.y-f.touchesStart.y+f.startY,f.currentX<f.minX&&(f.currentX=f.minX+1-(f.minX-f.currentX+1)**.8),f.currentX>f.maxX&&(f.currentX=f.maxX-1+(f.currentX-f.maxX+1)**.8),f.currentY<f.minY&&(f.currentY=f.minY+1-(f.minY-f.currentY+1)**.8),f.currentY>f.maxY&&(f.currentY=f.maxY-1+(f.currentY-f.maxY+1)**.8),g.prevPositionX||(g.prevPositionX=f.touchesCurrent.x),g.prevPositionY||(g.prevPositionY=f.touchesCurrent.y),g.prevTime||(g.prevTime=Date.now()),g.x=(f.touchesCurrent.x-g.prevPositionX)/(Date.now()-g.prevTime)/2,g.y=(f.touchesCurrent.y-g.prevPositionY)/(Date.now()-g.prevTime)/2,Math.abs(f.touchesCurrent.x-g.prevPositionX)<2&&(g.x=0),Math.abs(f.touchesCurrent.y-g.prevPositionY)<2&&(g.y=0),g.prevPositionX=f.touchesCurrent.x,g.prevPositionY=f.touchesCurrent.y,g.prevTime=Date.now(),m.$imageWrapEl.transform(`translate3d(${f.currentX}px, ${f.currentY}px,0)`)}}function C(){const e=t.zoom;m.$slideEl&&t.previousIndex!==t.activeIndex&&(m.$imageEl&&m.$imageEl.transform("translate3d(0,0,0) scale(1)"),m.$imageWrapEl&&m.$imageWrapEl.transform("translate3d(0,0,0)"),e.scale=1,p=1,m.$slideEl=void 0,m.$imageEl=void 0,m.$imageWrapEl=void 0)}function T(e){const s=t.zoom,a=t.params.zoom;if(m.$slideEl||(e&&e.target&&(m.$slideEl=d(e.target).closest(`.${t.params.slideClass}`)),m.$slideEl||(t.params.virtual&&t.params.virtual.enabled&&t.virtual?m.$slideEl=t.$wrapperEl.children(`.${t.params.slideActiveClass}`):m.$slideEl=t.slides.eq(t.activeIndex)),m.$imageEl=m.$slideEl.find(`.${a.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0),m.$imageWrapEl=m.$imageEl.parent(`.${a.containerClass}`)),!m.$imageEl||0===m.$imageEl.length||!m.$imageWrapEl||0===m.$imageWrapEl.length)return;let i,r,l,o,c,u,h,g,v,w,b,x,y,E,C,T,$,S;t.params.cssMode&&(t.wrapperEl.style.overflow="hidden",t.wrapperEl.style.touchAction="none"),m.$slideEl.addClass(`${a.zoomedSlideClass}`),void 0===f.touchesStart.x&&e?(i="touchend"===e.type?e.changedTouches[0].pageX:e.pageX,r="touchend"===e.type?e.changedTouches[0].pageY:e.pageY):(i=f.touchesStart.x,r=f.touchesStart.y),s.scale=m.$imageWrapEl.attr("data-swiper-zoom")||a.maxRatio,p=m.$imageWrapEl.attr("data-swiper-zoom")||a.maxRatio,e?($=m.$slideEl[0].offsetWidth,S=m.$slideEl[0].offsetHeight,l=m.$slideEl.offset().left+n.scrollX,o=m.$slideEl.offset().top+n.scrollY,c=l+$/2-i,u=o+S/2-r,v=m.$imageEl[0].offsetWidth,w=m.$imageEl[0].offsetHeight,b=v*s.scale,x=w*s.scale,y=Math.min($/2-b/2,0),E=Math.min(S/2-x/2,0),C=-y,T=-E,h=c*s.scale,g=u*s.scale,h<y&&(h=y),h>C&&(h=C),g<E&&(g=E),g>T&&(g=T)):(h=0,g=0),m.$imageWrapEl.transition(300).transform(`translate3d(${h}px, ${g}px,0)`),m.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${s.scale})`)}function $(){const e=t.zoom,s=t.params.zoom;m.$slideEl||(t.params.virtual&&t.params.virtual.enabled&&t.virtual?m.$slideEl=t.$wrapperEl.children(`.${t.params.slideActiveClass}`):m.$slideEl=t.slides.eq(t.activeIndex),m.$imageEl=m.$slideEl.find(`.${s.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0),m.$imageWrapEl=m.$imageEl.parent(`.${s.containerClass}`)),m.$imageEl&&0!==m.$imageEl.length&&m.$imageWrapEl&&0!==m.$imageWrapEl.length&&(t.params.cssMode&&(t.wrapperEl.style.overflow="",t.wrapperEl.style.touchAction=""),e.scale=1,p=1,m.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"),m.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"),m.$slideEl.removeClass(`${s.zoomedSlideClass}`),m.$slideEl=void 0)}function S(e){const s=t.zoom;s.scale&&1!==s.scale?$():T(e)}function M(){const e=t.support;return{passiveListener:!("touchstart"!==t.touchEvents.start||!e.passiveListener||!t.params.passiveListeners)&&{passive:!0,capture:!1},activeListenerWithCapture:!e.passiveListener||{passive:!1,capture:!0}}}function P(){return`.${t.params.slideClass}`}function k(e){const{passiveListener:s}=M(),a=P();t.$wrapperEl[e]("gesturestart",a,b,s),t.$wrapperEl[e]("gesturechange",a,x,s),t.$wrapperEl[e]("gestureend",a,y,s)}function z(){l||(l=!0,k("on"))}function L(){l&&(l=!1,k("off"))}function O(){const e=t.zoom;if(e.enabled)return;e.enabled=!0;const s=t.support,{passiveListener:a,activeListenerWithCapture:i}=M(),r=P();s.gestures?(t.$wrapperEl.on(t.touchEvents.start,z,a),t.$wrapperEl.on(t.touchEvents.end,L,a)):"touchstart"===t.touchEvents.start&&(t.$wrapperEl.on(t.touchEvents.start,r,b,a),t.$wrapperEl.on(t.touchEvents.move,r,x,i),t.$wrapperEl.on(t.touchEvents.end,r,y,a),t.touchEvents.cancel&&t.$wrapperEl.on(t.touchEvents.cancel,r,y,a)),t.$wrapperEl.on(t.touchEvents.move,`.${t.params.zoom.containerClass}`,E,i)}function I(){const e=t.zoom;if(!e.enabled)return;const s=t.support;e.enabled=!1;const{passiveListener:a,activeListenerWithCapture:i}=M(),r=P();s.gestures?(t.$wrapperEl.off(t.touchEvents.start,z,a),t.$wrapperEl.off(t.touchEvents.end,L,a)):"touchstart"===t.touchEvents.start&&(t.$wrapperEl.off(t.touchEvents.start,r,b,a),t.$wrapperEl.off(t.touchEvents.move,r,x,i),t.$wrapperEl.off(t.touchEvents.end,r,y,a),t.touchEvents.cancel&&t.$wrapperEl.off(t.touchEvents.cancel,r,y,a)),t.$wrapperEl.off(t.touchEvents.move,`.${t.params.zoom.containerClass}`,E,i)}Object.defineProperty(t.zoom,"scale",{get:()=>v,set(e){if(v!==e){const t=m.$imageEl?m.$imageEl[0]:void 0,s=m.$slideEl?m.$slideEl[0]:void 0;i("zoomChange",e,t,s)}v=e}}),a("init",(()=>{t.params.zoom.enabled&&O()})),a("destroy",(()=>{I()})),a("touchStart",((e,s)=>{t.zoom.enabled&&function(e){const s=t.device;m.$imageEl&&0!==m.$imageEl.length&&(f.isTouched||(s.android&&e.cancelable&&e.preventDefault(),f.isTouched=!0,f.touchesStart.x="touchstart"===e.type?e.targetTouches[0].pageX:e.pageX,f.touchesStart.y="touchstart"===e.type?e.targetTouches[0].pageY:e.pageY))}(s)})),a("touchEnd",((e,s)=>{t.zoom.enabled&&function(){const e=t.zoom;if(!m.$imageEl||0===m.$imageEl.length)return;if(!f.isTouched||!f.isMoved)return f.isTouched=!1,void(f.isMoved=!1);f.isTouched=!1,f.isMoved=!1;let s=300,a=300;const i=g.x*s,r=f.currentX+i,n=g.y*a,l=f.currentY+n;0!==g.x&&(s=Math.abs((r-f.currentX)/g.x)),0!==g.y&&(a=Math.abs((l-f.currentY)/g.y));const o=Math.max(s,a);f.currentX=r,f.currentY=l;const d=f.width*e.scale,c=f.height*e.scale;f.minX=Math.min(m.slideWidth/2-d/2,0),f.maxX=-f.minX,f.minY=Math.min(m.slideHeight/2-c/2,0),f.maxY=-f.minY,f.currentX=Math.max(Math.min(f.currentX,f.maxX),f.minX),f.currentY=Math.max(Math.min(f.currentY,f.maxY),f.minY),m.$imageWrapEl.transition(o).transform(`translate3d(${f.currentX}px, ${f.currentY}px,0)`)}()})),a("doubleTap",((e,s)=>{!t.animating&&t.params.zoom.enabled&&t.zoom.enabled&&t.params.zoom.toggle&&S(s)})),a("transitionEnd",(()=>{t.zoom.enabled&&t.params.zoom.enabled&&C()})),a("slideChange",(()=>{t.zoom.enabled&&t.params.zoom.enabled&&t.params.cssMode&&C()})),Object.assign(t.zoom,{enable:O,disable:I,in:T,out:$,toggle:S})},function(e){let{swiper:t,extendParams:s,on:a,emit:i}=e;s({lazy:{checkInView:!1,enabled:!1,loadPrevNext:!1,loadPrevNextAmount:1,loadOnTransitionStart:!1,scrollingElement:"",elementClass:"swiper-lazy",loadingClass:"swiper-lazy-loading",loadedClass:"swiper-lazy-loaded",preloaderClass:"swiper-lazy-preloader"}}),t.lazy={};let n=!1,l=!1;function o(e,s){void 0===s&&(s=!0);const a=t.params.lazy;if(void 0===e)return;if(0===t.slides.length)return;const r=t.virtual&&t.params.virtual.enabled?t.$wrapperEl.children(`.${t.params.slideClass}[data-swiper-slide-index="${e}"]`):t.slides.eq(e),n=r.find(`.${a.elementClass}:not(.${a.loadedClass}):not(.${a.loadingClass})`);!r.hasClass(a.elementClass)||r.hasClass(a.loadedClass)||r.hasClass(a.loadingClass)||n.push(r[0]),0!==n.length&&n.each((e=>{const n=d(e);n.addClass(a.loadingClass);const l=n.attr("data-background"),c=n.attr("data-src"),p=n.attr("data-srcset"),u=n.attr("data-sizes"),h=n.parent("picture");t.loadImage(n[0],c||l,p,u,!1,(()=>{if(null!=t&&t&&(!t||t.params)&&!t.destroyed){if(l?(n.css("background-image",`url("${l}")`),n.removeAttr("data-background")):(p&&(n.attr("srcset",p),n.removeAttr("data-srcset")),u&&(n.attr("sizes",u),n.removeAttr("data-sizes")),h.length&&h.children("source").each((e=>{const t=d(e);t.attr("data-srcset")&&(t.attr("srcset",t.attr("data-srcset")),t.removeAttr("data-srcset"))})),c&&(n.attr("src",c),n.removeAttr("data-src"))),n.addClass(a.loadedClass).removeClass(a.loadingClass),r.find(`.${a.preloaderClass}`).remove(),t.params.loop&&s){const e=r.attr("data-swiper-slide-index");if(r.hasClass(t.params.slideDuplicateClass)){o(t.$wrapperEl.children(`[data-swiper-slide-index="${e}"]:not(.${t.params.slideDuplicateClass})`).index(),!1)}else{o(t.$wrapperEl.children(`.${t.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`).index(),!1)}}i("lazyImageReady",r[0],n[0]),t.params.autoHeight&&t.updateAutoHeight()}})),i("lazyImageLoad",r[0],n[0])}))}function c(){const{$wrapperEl:e,params:s,slides:a,activeIndex:i}=t,r=t.virtual&&s.virtual.enabled,n=s.lazy;let c=s.slidesPerView;function p(t){if(r){if(e.children(`.${s.slideClass}[data-swiper-slide-index="${t}"]`).length)return!0}else if(a[t])return!0;return!1}function u(e){return r?d(e).attr("data-swiper-slide-index"):d(e).index()}if("auto"===c&&(c=0),l||(l=!0),t.params.watchSlidesProgress)e.children(`.${s.slideVisibleClass}`).each((e=>{o(r?d(e).attr("data-swiper-slide-index"):d(e).index())}));else if(c>1)for(let e=i;e<i+c;e+=1)p(e)&&o(e);else o(i);if(n.loadPrevNext)if(c>1||n.loadPrevNextAmount&&n.loadPrevNextAmount>1){const e=n.loadPrevNextAmount,t=Math.ceil(c),s=Math.min(i+t+Math.max(e,t),a.length),r=Math.max(i-Math.max(t,e),0);for(let e=i+t;e<s;e+=1)p(e)&&o(e);for(let e=r;e<i;e+=1)p(e)&&o(e)}else{const t=e.children(`.${s.slideNextClass}`);t.length>0&&o(u(t));const a=e.children(`.${s.slidePrevClass}`);a.length>0&&o(u(a))}}function p(){const e=r();if(!t||t.destroyed)return;const s=t.params.lazy.scrollingElement?d(t.params.lazy.scrollingElement):d(e),a=s[0]===e,i=a?e.innerWidth:s[0].offsetWidth,l=a?e.innerHeight:s[0].offsetHeight,o=t.$el.offset(),{rtlTranslate:u}=t;let h=!1;u&&(o.left-=t.$el[0].scrollLeft);const m=[[o.left,o.top],[o.left+t.width,o.top],[o.left,o.top+t.height],[o.left+t.width,o.top+t.height]];for(let e=0;e<m.length;e+=1){const t=m[e];if(t[0]>=0&&t[0]<=i&&t[1]>=0&&t[1]<=l){if(0===t[0]&&0===t[1])continue;h=!0}}const f=!("touchstart"!==t.touchEvents.start||!t.support.passiveListener||!t.params.passiveListeners)&&{passive:!0,capture:!1};h?(c(),s.off("scroll",p,f)):n||(n=!0,s.on("scroll",p,f))}a("beforeInit",(()=>{t.params.lazy.enabled&&t.params.preloadImages&&(t.params.preloadImages=!1)})),a("init",(()=>{t.params.lazy.enabled&&(t.params.lazy.checkInView?p():c())})),a("scroll",(()=>{t.params.freeMode&&t.params.freeMode.enabled&&!t.params.freeMode.sticky&&c()})),a("scrollbarDragMove resize _freeModeNoMomentumRelease",(()=>{t.params.lazy.enabled&&(t.params.lazy.checkInView?p():c())})),a("transitionStart",(()=>{t.params.lazy.enabled&&(t.params.lazy.loadOnTransitionStart||!t.params.lazy.loadOnTransitionStart&&!l)&&(t.params.lazy.checkInView?p():c())})),a("transitionEnd",(()=>{t.params.lazy.enabled&&!t.params.lazy.loadOnTransitionStart&&(t.params.lazy.checkInView?p():c())})),a("slideChange",(()=>{const{lazy:e,cssMode:s,watchSlidesProgress:a,touchReleaseOnEdges:i,resistanceRatio:r}=t.params;e.enabled&&(s||a&&(i||0===r))&&c()})),a("destroy",(()=>{t.$el&&t.$el.find(`.${t.params.lazy.loadingClass}`).removeClass(t.params.lazy.loadingClass)})),Object.assign(t.lazy,{load:c,loadInSlide:o})},function(e){let{swiper:t,extendParams:s,on:a}=e;function i(e,t){const s=function(){let e,t,s;return(a,i)=>{for(t=-1,e=a.length;e-t>1;)s=e+t>>1,a[s]<=i?t=s:e=s;return e}}();let a,i;return this.x=e,this.y=t,this.lastIndex=e.length-1,this.interpolate=function(e){return e?(i=s(this.x,e),a=i-1,(e-this.x[a])*(this.y[i]-this.y[a])/(this.x[i]-this.x[a])+this.y[a]):0},this}function r(){t.controller.control&&t.controller.spline&&(t.controller.spline=void 0,delete t.controller.spline)}s({controller:{control:void 0,inverse:!1,by:"slide"}}),t.controller={control:void 0},a("beforeInit",(()=>{t.controller.control=t.params.controller.control})),a("update",(()=>{r()})),a("resize",(()=>{r()})),a("observerUpdate",(()=>{r()})),a("setTranslate",((e,s,a)=>{t.controller.control&&t.controller.setTranslate(s,a)})),a("setTransition",((e,s,a)=>{t.controller.control&&t.controller.setTransition(s,a)})),Object.assign(t.controller,{setTranslate:function(e,s){const a=t.controller.control;let r,n;const l=t.constructor;function o(e){const s=t.rtlTranslate?-t.translate:t.translate;"slide"===t.params.controller.by&&(!function(e){t.controller.spline||(t.controller.spline=t.params.loop?new i(t.slidesGrid,e.slidesGrid):new i(t.snapGrid,e.snapGrid))}(e),n=-t.controller.spline.interpolate(-s)),n&&"container"!==t.params.controller.by||(r=(e.maxTranslate()-e.minTranslate())/(t.maxTranslate()-t.minTranslate()),n=(s-t.minTranslate())*r+e.minTranslate()),t.params.controller.inverse&&(n=e.maxTranslate()-n),e.updateProgress(n),e.setTranslate(n,t),e.updateActiveIndex(),e.updateSlidesClasses()}if(Array.isArray(a))for(let e=0;e<a.length;e+=1)a[e]!==s&&a[e]instanceof l&&o(a[e]);else a instanceof l&&s!==a&&o(a)},setTransition:function(e,s){const a=t.constructor,i=t.controller.control;let r;function n(s){s.setTransition(e,t),0!==e&&(s.transitionStart(),s.params.autoHeight&&p((()=>{s.updateAutoHeight()})),s.$wrapperEl.transitionEnd((()=>{i&&(s.params.loop&&"slide"===t.params.controller.by&&s.loopFix(),s.transitionEnd())})))}if(Array.isArray(i))for(r=0;r<i.length;r+=1)i[r]!==s&&i[r]instanceof a&&n(i[r]);else i instanceof a&&s!==i&&n(i)}})},function(e){let{swiper:t,extendParams:s,on:a}=e;s({a11y:{enabled:!0,notificationClass:"swiper-notification",prevSlideMessage:"Previous slide",nextSlideMessage:"Next slide",firstSlideMessage:"This is the first slide",lastSlideMessage:"This is the last slide",paginationBulletMessage:"Go to slide {{index}}",slideLabelMessage:"{{index}} / {{slidesLength}}",containerMessage:null,containerRoleDescriptionMessage:null,itemRoleDescriptionMessage:null,slideRole:"group",id:null}});let i=null;function r(e){const t=i;0!==t.length&&(t.html(""),t.html(e))}function n(e){e.attr("tabIndex","0")}function l(e){e.attr("tabIndex","-1")}function o(e,t){e.attr("role",t)}function c(e,t){e.attr("aria-roledescription",t)}function p(e,t){e.attr("aria-label",t)}function u(e){e.attr("aria-disabled",!0)}function h(e){e.attr("aria-disabled",!1)}function m(e){if(13!==e.keyCode&&32!==e.keyCode)return;const s=t.params.a11y,a=d(e.target);t.navigation&&t.navigation.$nextEl&&a.is(t.navigation.$nextEl)&&(t.isEnd&&!t.params.loop||t.slideNext(),t.isEnd?r(s.lastSlideMessage):r(s.nextSlideMessage)),t.navigation&&t.navigation.$prevEl&&a.is(t.navigation.$prevEl)&&(t.isBeginning&&!t.params.loop||t.slidePrev(),t.isBeginning?r(s.firstSlideMessage):r(s.prevSlideMessage)),t.pagination&&a.is(U(t.params.pagination.bulletClass))&&a[0].click()}function f(){return t.pagination&&t.pagination.bullets&&t.pagination.bullets.length}function g(){return f()&&t.params.pagination.clickable}const v=(e,t,s)=>{n(e),"BUTTON"!==e[0].tagName&&(o(e,"button"),e.on("keydown",m)),p(e,s),function(e,t){e.attr("aria-controls",t)}(e,t)},w=e=>{const s=e.target.closest(`.${t.params.slideClass}`);if(!s||!t.slides.includes(s))return;const a=t.slides.indexOf(s)===t.activeIndex,i=t.params.watchSlidesProgress&&t.visibleSlides&&t.visibleSlides.includes(s);a||i||t.slideTo(t.slides.indexOf(s),0)},b=()=>{const e=t.params.a11y;e.itemRoleDescriptionMessage&&c(d(t.slides),e.itemRoleDescriptionMessage),o(d(t.slides),e.slideRole);const s=t.params.loop?t.slides.filter((e=>!e.classList.contains(t.params.slideDuplicateClass))).length:t.slides.length;e.slideLabelMessage&&t.slides.each(((a,i)=>{const r=d(a),n=t.params.loop?parseInt(r.attr("data-swiper-slide-index"),10):i;p(r,e.slideLabelMessage.replace(/\{\{index\}\}/,n+1).replace(/\{\{slidesLength\}\}/,s))}))},x=()=>{const e=t.params.a11y;t.$el.append(i);const s=t.$el;e.containerRoleDescriptionMessage&&c(s,e.containerRoleDescriptionMessage),e.containerMessage&&p(s,e.containerMessage);const a=t.$wrapperEl,r=e.id||a.attr("id")||`swiper-wrapper-${n=16,void 0===n&&(n=16),"x".repeat(n).replace(/x/g,(()=>Math.round(16*Math.random()).toString(16)))}`;var n;const l=t.params.autoplay&&t.params.autoplay.enabled?"off":"polite";var o;let d,u;o=r,a.attr("id",o),function(e,t){e.attr("aria-live",t)}(a,l),b(),t.navigation&&t.navigation.$nextEl&&(d=t.navigation.$nextEl),t.navigation&&t.navigation.$prevEl&&(u=t.navigation.$prevEl),d&&d.length&&v(d,r,e.nextSlideMessage),u&&u.length&&v(u,r,e.prevSlideMessage),g()&&t.pagination.$el.on("keydown",U(t.params.pagination.bulletClass),m),t.$el.on("focus",w,!0)};a("beforeInit",(()=>{i=d(`<span class="${t.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`)})),a("afterInit",(()=>{t.params.a11y.enabled&&x()})),a("slidesLengthChange snapGridLengthChange slidesGridLengthChange",(()=>{t.params.a11y.enabled&&b()})),a("fromEdge toEdge afterInit lock unlock",(()=>{t.params.a11y.enabled&&function(){if(t.params.loop||t.params.rewind||!t.navigation)return;const{$nextEl:e,$prevEl:s}=t.navigation;s&&s.length>0&&(t.isBeginning?(u(s),l(s)):(h(s),n(s))),e&&e.length>0&&(t.isEnd?(u(e),l(e)):(h(e),n(e)))}()})),a("paginationUpdate",(()=>{t.params.a11y.enabled&&function(){const e=t.params.a11y;f()&&t.pagination.bullets.each((s=>{const a=d(s);t.params.pagination.clickable&&(n(a),t.params.pagination.renderBullet||(o(a,"button"),p(a,e.paginationBulletMessage.replace(/\{\{index\}\}/,a.index()+1)))),a.is(`.${t.params.pagination.bulletActiveClass}`)?a.attr("aria-current","true"):a.removeAttr("aria-current")}))}()})),a("destroy",(()=>{t.params.a11y.enabled&&function(){let e,s;i&&i.length>0&&i.remove(),t.navigation&&t.navigation.$nextEl&&(e=t.navigation.$nextEl),t.navigation&&t.navigation.$prevEl&&(s=t.navigation.$prevEl),e&&e.off("keydown",m),s&&s.off("keydown",m),g()&&t.pagination.$el.off("keydown",U(t.params.pagination.bulletClass),m),t.$el.off("focus",w,!0)}()}))},function(e){let{swiper:t,extendParams:s,on:a}=e;s({history:{enabled:!1,root:"",replaceState:!1,key:"slides",keepQuery:!1}});let i=!1,n={};const l=e=>e.toString().replace(/\s+/g,"-").replace(/[^\w-]+/g,"").replace(/--+/g,"-").replace(/^-+/,"").replace(/-+$/,""),o=e=>{const t=r();let s;s=e?new URL(e):t.location;const a=s.pathname.slice(1).split("/").filter((e=>""!==e)),i=a.length;return{key:a[i-2],value:a[i-1]}},d=(e,s)=>{const a=r();if(!i||!t.params.history.enabled)return;let n;n=t.params.url?new URL(t.params.url):a.location;const o=t.slides.eq(s);let d=l(o.attr("data-history"));if(t.params.history.root.length>0){let s=t.params.history.root;"/"===s[s.length-1]&&(s=s.slice(0,s.length-1)),d=`${s}/${e}/${d}`}else n.pathname.includes(e)||(d=`${e}/${d}`);t.params.history.keepQuery&&(d+=n.search);const c=a.history.state;c&&c.value===d||(t.params.history.replaceState?a.history.replaceState({value:d},null,d):a.history.pushState({value:d},null,d))},c=(e,s,a)=>{if(s)for(let i=0,r=t.slides.length;i<r;i+=1){const r=t.slides.eq(i);if(l(r.attr("data-history"))===s&&!r.hasClass(t.params.slideDuplicateClass)){const s=r.index();t.slideTo(s,e,a)}}else t.slideTo(0,e,a)},p=()=>{n=o(t.params.url),c(t.params.speed,n.value,!1)};a("init",(()=>{t.params.history.enabled&&(()=>{const e=r();if(t.params.history){if(!e.history||!e.history.pushState)return t.params.history.enabled=!1,void(t.params.hashNavigation.enabled=!0);i=!0,n=o(t.params.url),(n.key||n.value)&&(c(0,n.value,t.params.runCallbacksOnInit),t.params.history.replaceState||e.addEventListener("popstate",p))}})()})),a("destroy",(()=>{t.params.history.enabled&&(()=>{const e=r();t.params.history.replaceState||e.removeEventListener("popstate",p)})()})),a("transitionEnd _freeModeNoMomentumRelease",(()=>{i&&d(t.params.history.key,t.activeIndex)})),a("slideChange",(()=>{i&&t.params.cssMode&&d(t.params.history.key,t.activeIndex)}))},function(e){let{swiper:t,extendParams:s,emit:i,on:n}=e,l=!1;const o=a(),c=r();s({hashNavigation:{enabled:!1,replaceState:!1,watchState:!1}});const p=()=>{i("hashChange");const e=o.location.hash.replace("#","");if(e!==t.slides.eq(t.activeIndex).attr("data-hash")){const s=t.$wrapperEl.children(`.${t.params.slideClass}[data-hash="${e}"]`).index();if(void 0===s)return;t.slideTo(s)}},u=()=>{if(l&&t.params.hashNavigation.enabled)if(t.params.hashNavigation.replaceState&&c.history&&c.history.replaceState)c.history.replaceState(null,null,`#${t.slides.eq(t.activeIndex).attr("data-hash")}`||""),i("hashSet");else{const e=t.slides.eq(t.activeIndex),s=e.attr("data-hash")||e.attr("data-history");o.location.hash=s||"",i("hashSet")}};n("init",(()=>{t.params.hashNavigation.enabled&&(()=>{if(!t.params.hashNavigation.enabled||t.params.history&&t.params.history.enabled)return;l=!0;const e=o.location.hash.replace("#","");if(e){const s=0;for(let a=0,i=t.slides.length;a<i;a+=1){const i=t.slides.eq(a);if((i.attr("data-hash")||i.attr("data-history"))===e&&!i.hasClass(t.params.slideDuplicateClass)){const e=i.index();t.slideTo(e,s,t.params.runCallbacksOnInit,!0)}}}t.params.hashNavigation.watchState&&d(c).on("hashchange",p)})()})),n("destroy",(()=>{t.params.hashNavigation.enabled&&t.params.hashNavigation.watchState&&d(c).off("hashchange",p)})),n("transitionEnd _freeModeNoMomentumRelease",(()=>{l&&u()})),n("slideChange",(()=>{l&&t.params.cssMode&&u()}))},function(e){let t,{swiper:s,extendParams:i,on:r,emit:n}=e;function l(){const e=s.slides.eq(s.activeIndex);let a=s.params.autoplay.delay;e.attr("data-swiper-autoplay")&&(a=e.attr("data-swiper-autoplay")||s.params.autoplay.delay),clearTimeout(t),t=p((()=>{let e;s.params.autoplay.reverseDirection?s.params.loop?(s.loopFix(),e=s.slidePrev(s.params.speed,!0,!0),n("autoplay")):s.isBeginning?s.params.autoplay.stopOnLastSlide?d():(e=s.slideTo(s.slides.length-1,s.params.speed,!0,!0),n("autoplay")):(e=s.slidePrev(s.params.speed,!0,!0),n("autoplay")):s.params.loop?(s.loopFix(),e=s.slideNext(s.params.speed,!0,!0),n("autoplay")):s.isEnd?s.params.autoplay.stopOnLastSlide?d():(e=s.slideTo(0,s.params.speed,!0,!0),n("autoplay")):(e=s.slideNext(s.params.speed,!0,!0),n("autoplay")),(s.params.cssMode&&s.autoplay.running||!1===e)&&l()}),a)}function o(){return void 0===t&&(!s.autoplay.running&&(s.autoplay.running=!0,n("autoplayStart"),l(),!0))}function d(){return!!s.autoplay.running&&(void 0!==t&&(t&&(clearTimeout(t),t=void 0),s.autoplay.running=!1,n("autoplayStop"),!0))}function c(e){s.autoplay.running&&(s.autoplay.paused||(t&&clearTimeout(t),s.autoplay.paused=!0,0!==e&&s.params.autoplay.waitForTransition?["transitionend","webkitTransitionEnd"].forEach((e=>{s.$wrapperEl[0].addEventListener(e,h)})):(s.autoplay.paused=!1,l())))}function u(){const e=a();"hidden"===e.visibilityState&&s.autoplay.running&&c(),"visible"===e.visibilityState&&s.autoplay.paused&&(l(),s.autoplay.paused=!1)}function h(e){s&&!s.destroyed&&s.$wrapperEl&&e.target===s.$wrapperEl[0]&&(["transitionend","webkitTransitionEnd"].forEach((e=>{s.$wrapperEl[0].removeEventListener(e,h)})),s.autoplay.paused=!1,s.autoplay.running?l():d())}function m(){s.params.autoplay.disableOnInteraction?d():(n("autoplayPause"),c()),["transitionend","webkitTransitionEnd"].forEach((e=>{s.$wrapperEl[0].removeEventListener(e,h)}))}function f(){s.params.autoplay.disableOnInteraction||(s.autoplay.paused=!1,n("autoplayResume"),l())}s.autoplay={running:!1,paused:!1},i({autoplay:{enabled:!1,delay:3e3,waitForTransition:!0,disableOnInteraction:!0,stopOnLastSlide:!1,reverseDirection:!1,pauseOnMouseEnter:!1}}),r("init",(()=>{if(s.params.autoplay.enabled){o();a().addEventListener("visibilitychange",u),s.params.autoplay.pauseOnMouseEnter&&(s.$el.on("mouseenter",m),s.$el.on("mouseleave",f))}})),r("beforeTransitionStart",((e,t,a)=>{s.autoplay.running&&(a||!s.params.autoplay.disableOnInteraction?s.autoplay.pause(t):d())})),r("sliderFirstMove",(()=>{s.autoplay.running&&(s.params.autoplay.disableOnInteraction?d():c())})),r("touchEnd",(()=>{s.params.cssMode&&s.autoplay.paused&&!s.params.autoplay.disableOnInteraction&&l()})),r("destroy",(()=>{s.$el.off("mouseenter",m),s.$el.off("mouseleave",f),s.autoplay.running&&d();a().removeEventListener("visibilitychange",u)})),Object.assign(s.autoplay,{pause:c,run:l,start:o,stop:d})},function(e){let{swiper:t,extendParams:s,on:a}=e;s({thumbs:{swiper:null,multipleActiveThumbs:!0,autoScrollOffset:0,slideThumbActiveClass:"swiper-slide-thumb-active",thumbsContainerClass:"swiper-thumbs"}});let i=!1,r=!1;function n(){const e=t.thumbs.swiper;if(!e||e.destroyed)return;const s=e.clickedIndex,a=e.clickedSlide;if(a&&d(a).hasClass(t.params.thumbs.slideThumbActiveClass))return;if(null==s)return;let i;if(i=e.params.loop?parseInt(d(e.clickedSlide).attr("data-swiper-slide-index"),10):s,t.params.loop){let e=t.activeIndex;t.slides.eq(e).hasClass(t.params.slideDuplicateClass)&&(t.loopFix(),t._clientLeft=t.$wrapperEl[0].clientLeft,e=t.activeIndex);const s=t.slides.eq(e).prevAll(`[data-swiper-slide-index="${i}"]`).eq(0).index(),a=t.slides.eq(e).nextAll(`[data-swiper-slide-index="${i}"]`).eq(0).index();i=void 0===s?a:void 0===a?s:a-e<e-s?a:s}t.slideTo(i)}function l(){const{thumbs:e}=t.params;if(i)return!1;i=!0;const s=t.constructor;if(e.swiper instanceof s)t.thumbs.swiper=e.swiper,Object.assign(t.thumbs.swiper.originalParams,{watchSlidesProgress:!0,slideToClickedSlide:!1}),Object.assign(t.thumbs.swiper.params,{watchSlidesProgress:!0,slideToClickedSlide:!1});else if(m(e.swiper)){const a=Object.assign({},e.swiper);Object.assign(a,{watchSlidesProgress:!0,slideToClickedSlide:!1}),t.thumbs.swiper=new s(a),r=!0}return t.thumbs.swiper.$el.addClass(t.params.thumbs.thumbsContainerClass),t.thumbs.swiper.on("tap",n),!0}function o(e){const s=t.thumbs.swiper;if(!s||s.destroyed)return;const a="auto"===s.params.slidesPerView?s.slidesPerViewDynamic():s.params.slidesPerView,i=t.params.thumbs.autoScrollOffset,r=i&&!s.params.loop;if(t.realIndex!==s.realIndex||r){let n,l,o=s.activeIndex;if(s.params.loop){s.slides.eq(o).hasClass(s.params.slideDuplicateClass)&&(s.loopFix(),s._clientLeft=s.$wrapperEl[0].clientLeft,o=s.activeIndex);const e=s.slides.eq(o).prevAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(),a=s.slides.eq(o).nextAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index();n=void 0===e?a:void 0===a?e:a-o==o-e?s.params.slidesPerGroup>1?a:o:a-o<o-e?a:e,l=t.activeIndex>t.previousIndex?"next":"prev"}else n=t.realIndex,l=n>t.previousIndex?"next":"prev";r&&(n+="next"===l?i:-1*i),s.visibleSlidesIndexes&&s.visibleSlidesIndexes.indexOf(n)<0&&(s.params.centeredSlides?n=n>o?n-Math.floor(a/2)+1:n+Math.floor(a/2)-1:n>o&&s.params.slidesPerGroup,s.slideTo(n,e?0:void 0))}let n=1;const l=t.params.thumbs.slideThumbActiveClass;if(t.params.slidesPerView>1&&!t.params.centeredSlides&&(n=t.params.slidesPerView),t.params.thumbs.multipleActiveThumbs||(n=1),n=Math.floor(n),s.slides.removeClass(l),s.params.loop||s.params.virtual&&s.params.virtual.enabled)for(let e=0;e<n;e+=1)s.$wrapperEl.children(`[data-swiper-slide-index="${t.realIndex+e}"]`).addClass(l);else for(let e=0;e<n;e+=1)s.slides.eq(t.realIndex+e).addClass(l)}t.thumbs={swiper:null},a("beforeInit",(()=>{const{thumbs:e}=t.params;e&&e.swiper&&(l(),o(!0))})),a("slideChange update resize observerUpdate",(()=>{o()})),a("setTransition",((e,s)=>{const a=t.thumbs.swiper;a&&!a.destroyed&&a.setTransition(s)})),a("beforeDestroy",(()=>{const e=t.thumbs.swiper;e&&!e.destroyed&&r&&e.destroy()})),Object.assign(t.thumbs,{init:l,update:o})},function(e){let{swiper:t,extendParams:s,emit:a,once:i}=e;s({freeMode:{enabled:!1,momentum:!0,momentumRatio:1,momentumBounce:!0,momentumBounceRatio:1,momentumVelocityRatio:1,sticky:!1,minimumVelocity:.02}}),Object.assign(t,{freeMode:{onTouchStart:function(){const e=t.getTranslate();t.setTranslate(e),t.setTransition(0),t.touchEventsData.velocities.length=0,t.freeMode.onTouchEnd({currentPos:t.rtl?t.translate:-t.translate})},onTouchMove:function(){const{touchEventsData:e,touches:s}=t;0===e.velocities.length&&e.velocities.push({position:s[t.isHorizontal()?"startX":"startY"],time:e.touchStartTime}),e.velocities.push({position:s[t.isHorizontal()?"currentX":"currentY"],time:u()})},onTouchEnd:function(e){let{currentPos:s}=e;const{params:r,$wrapperEl:n,rtlTranslate:l,snapGrid:o,touchEventsData:d}=t,c=u()-d.touchStartTime;if(s<-t.minTranslate())t.slideTo(t.activeIndex);else if(s>-t.maxTranslate())t.slides.length<o.length?t.slideTo(o.length-1):t.slideTo(t.slides.length-1);else{if(r.freeMode.momentum){if(d.velocities.length>1){const e=d.velocities.pop(),s=d.velocities.pop(),a=e.position-s.position,i=e.time-s.time;t.velocity=a/i,t.velocity/=2,Math.abs(t.velocity)<r.freeMode.minimumVelocity&&(t.velocity=0),(i>150||u()-e.time>300)&&(t.velocity=0)}else t.velocity=0;t.velocity*=r.freeMode.momentumVelocityRatio,d.velocities.length=0;let e=1e3*r.freeMode.momentumRatio;const s=t.velocity*e;let c=t.translate+s;l&&(c=-c);let p,h=!1;const m=20*Math.abs(t.velocity)*r.freeMode.momentumBounceRatio;let f;if(c<t.maxTranslate())r.freeMode.momentumBounce?(c+t.maxTranslate()<-m&&(c=t.maxTranslate()-m),p=t.maxTranslate(),h=!0,d.allowMomentumBounce=!0):c=t.maxTranslate(),r.loop&&r.centeredSlides&&(f=!0);else if(c>t.minTranslate())r.freeMode.momentumBounce?(c-t.minTranslate()>m&&(c=t.minTranslate()+m),p=t.minTranslate(),h=!0,d.allowMomentumBounce=!0):c=t.minTranslate(),r.loop&&r.centeredSlides&&(f=!0);else if(r.freeMode.sticky){let e;for(let t=0;t<o.length;t+=1)if(o[t]>-c){e=t;break}c=Math.abs(o[e]-c)<Math.abs(o[e-1]-c)||"next"===t.swipeDirection?o[e]:o[e-1],c=-c}if(f&&i("transitionEnd",(()=>{t.loopFix()})),0!==t.velocity){if(e=l?Math.abs((-c-t.translate)/t.velocity):Math.abs((c-t.translate)/t.velocity),r.freeMode.sticky){const s=Math.abs((l?-c:c)-t.translate),a=t.slidesSizesGrid[t.activeIndex];e=s<a?r.speed:s<2*a?1.5*r.speed:2.5*r.speed}}else if(r.freeMode.sticky)return void t.slideToClosest();r.freeMode.momentumBounce&&h?(t.updateProgress(p),t.setTransition(e),t.setTranslate(c),t.transitionStart(!0,t.swipeDirection),t.animating=!0,n.transitionEnd((()=>{t&&!t.destroyed&&d.allowMomentumBounce&&(a("momentumBounce"),t.setTransition(r.speed),setTimeout((()=>{t.setTranslate(p),n.transitionEnd((()=>{t&&!t.destroyed&&t.transitionEnd()}))}),0))}))):t.velocity?(a("_freeModeNoMomentumRelease"),t.updateProgress(c),t.setTransition(e),t.setTranslate(c),t.transitionStart(!0,t.swipeDirection),t.animating||(t.animating=!0,n.transitionEnd((()=>{t&&!t.destroyed&&t.transitionEnd()})))):t.updateProgress(c),t.updateActiveIndex(),t.updateSlidesClasses()}else{if(r.freeMode.sticky)return void t.slideToClosest();r.freeMode&&a("_freeModeNoMomentumRelease")}(!r.freeMode.momentum||c>=r.longSwipesMs)&&(t.updateProgress(),t.updateActiveIndex(),t.updateSlidesClasses())}}}})},function(e){let t,s,a,{swiper:i,extendParams:r}=e;r({grid:{rows:1,fill:"column"}}),i.grid={initSlides:e=>{const{slidesPerView:r}=i.params,{rows:n,fill:l}=i.params.grid;s=t/n,a=Math.floor(e/n),t=Math.floor(e/n)===e/n?e:Math.ceil(e/n)*n,"auto"!==r&&"row"===l&&(t=Math.max(t,r*n))},updateSlide:(e,r,n,l)=>{const{slidesPerGroup:o,spaceBetween:d}=i.params,{rows:c,fill:p}=i.params.grid;let u,h,m;if("row"===p&&o>1){const s=Math.floor(e/(o*c)),a=e-c*o*s,i=0===s?o:Math.min(Math.ceil((n-s*c*o)/c),o);m=Math.floor(a/i),h=a-m*i+s*o,u=h+m*t/c,r.css({"-webkit-order":u,order:u})}else"column"===p?(h=Math.floor(e/c),m=e-h*c,(h>a||h===a&&m===c-1)&&(m+=1,m>=c&&(m=0,h+=1))):(m=Math.floor(e/s),h=e-m*s);r.css(l("margin-top"),0!==m?d&&`${d}px`:"")},updateWrapperSize:(e,s,a)=>{const{spaceBetween:r,centeredSlides:n,roundLengths:l}=i.params,{rows:o}=i.params.grid;if(i.virtualSize=(e+r)*t,i.virtualSize=Math.ceil(i.virtualSize/o)-r,i.$wrapperEl.css({[a("width")]:`${i.virtualSize+r}px`}),n){s.splice(0,s.length);const e=[];for(let t=0;t<s.length;t+=1){let a=s[t];l&&(a=Math.floor(a)),s[t]<i.virtualSize+s[0]&&e.push(a)}s.push(...e)}}}},function(e){let{swiper:t}=e;Object.assign(t,{appendSlide:K.bind(t),prependSlide:Z.bind(t),addSlide:Q.bind(t),removeSlide:J.bind(t),removeAllSlides:ee.bind(t)})},function(e){let{swiper:t,extendParams:s,on:a}=e;s({fadeEffect:{crossFade:!1,transformEl:null}}),te({effect:"fade",swiper:t,on:a,setTranslate:()=>{const{slides:e}=t,s=t.params.fadeEffect;for(let a=0;a<e.length;a+=1){const e=t.slides.eq(a);let i=-e[0].swiperSlideOffset;t.params.virtualTranslate||(i-=t.translate);let r=0;t.isHorizontal()||(r=i,i=0);const n=t.params.fadeEffect.crossFade?Math.max(1-Math.abs(e[0].progress),0):1+Math.min(Math.max(e[0].progress,-1),0);se(s,e).css({opacity:n}).transform(`translate3d(${i}px, ${r}px, 0px)`)}},setTransition:e=>{const{transformEl:s}=t.params.fadeEffect;(s?t.slides.find(s):t.slides).transition(e),ae({swiper:t,duration:e,transformEl:s,allSlides:!0})},overwriteParams:()=>({slidesPerView:1,slidesPerGroup:1,watchSlidesProgress:!0,spaceBetween:0,virtualTranslate:!t.params.cssMode})})},function(e){let{swiper:t,extendParams:s,on:a}=e;s({cubeEffect:{slideShadows:!0,shadow:!0,shadowOffset:20,shadowScale:.94}});const i=(e,t,s)=>{let a=s?e.find(".swiper-slide-shadow-left"):e.find(".swiper-slide-shadow-top"),i=s?e.find(".swiper-slide-shadow-right"):e.find(".swiper-slide-shadow-bottom");0===a.length&&(a=d(`<div class="swiper-slide-shadow-${s?"left":"top"}"></div>`),e.append(a)),0===i.length&&(i=d(`<div class="swiper-slide-shadow-${s?"right":"bottom"}"></div>`),e.append(i)),a.length&&(a[0].style.opacity=Math.max(-t,0)),i.length&&(i[0].style.opacity=Math.max(t,0))};te({effect:"cube",swiper:t,on:a,setTranslate:()=>{const{$el:e,$wrapperEl:s,slides:a,width:r,height:n,rtlTranslate:l,size:o,browser:c}=t,p=t.params.cubeEffect,u=t.isHorizontal(),h=t.virtual&&t.params.virtual.enabled;let m,f=0;p.shadow&&(u?(m=s.find(".swiper-cube-shadow"),0===m.length&&(m=d('<div class="swiper-cube-shadow"></div>'),s.append(m)),m.css({height:`${r}px`})):(m=e.find(".swiper-cube-shadow"),0===m.length&&(m=d('<div class="swiper-cube-shadow"></div>'),e.append(m))));for(let e=0;e<a.length;e+=1){const t=a.eq(e);let s=e;h&&(s=parseInt(t.attr("data-swiper-slide-index"),10));let r=90*s,n=Math.floor(r/360);l&&(r=-r,n=Math.floor(-r/360));const d=Math.max(Math.min(t[0].progress,1),-1);let c=0,m=0,g=0;s%4==0?(c=4*-n*o,g=0):(s-1)%4==0?(c=0,g=4*-n*o):(s-2)%4==0?(c=o+4*n*o,g=o):(s-3)%4==0&&(c=-o,g=3*o+4*o*n),l&&(c=-c),u||(m=c,c=0);const v=`rotateX(${u?0:-r}deg) rotateY(${u?r:0}deg) translate3d(${c}px, ${m}px, ${g}px)`;d<=1&&d>-1&&(f=90*s+90*d,l&&(f=90*-s-90*d)),t.transform(v),p.slideShadows&&i(t,d,u)}if(s.css({"-webkit-transform-origin":`50% 50% -${o/2}px`,"transform-origin":`50% 50% -${o/2}px`}),p.shadow)if(u)m.transform(`translate3d(0px, ${r/2+p.shadowOffset}px, ${-r/2}px) rotateX(90deg) rotateZ(0deg) scale(${p.shadowScale})`);else{const e=Math.abs(f)-90*Math.floor(Math.abs(f)/90),t=1.5-(Math.sin(2*e*Math.PI/360)/2+Math.cos(2*e*Math.PI/360)/2),s=p.shadowScale,a=p.shadowScale/t,i=p.shadowOffset;m.transform(`scale3d(${s}, 1, ${a}) translate3d(0px, ${n/2+i}px, ${-n/2/a}px) rotateX(-90deg)`)}const g=c.isSafari||c.isWebView?-o/2:0;s.transform(`translate3d(0px,0,${g}px) rotateX(${t.isHorizontal()?0:f}deg) rotateY(${t.isHorizontal()?-f:0}deg)`),s[0].style.setProperty("--swiper-cube-translate-z",`${g}px`)},setTransition:e=>{const{$el:s,slides:a}=t;a.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e),t.params.cubeEffect.shadow&&!t.isHorizontal()&&s.find(".swiper-cube-shadow").transition(e)},recreateShadows:()=>{const e=t.isHorizontal();t.slides.each((t=>{const s=Math.max(Math.min(t.progress,1),-1);i(d(t),s,e)}))},getEffectParams:()=>t.params.cubeEffect,perspective:()=>!0,overwriteParams:()=>({slidesPerView:1,slidesPerGroup:1,watchSlidesProgress:!0,resistanceRatio:0,spaceBetween:0,centeredSlides:!1,virtualTranslate:!0})})},function(e){let{swiper:t,extendParams:s,on:a}=e;s({flipEffect:{slideShadows:!0,limitRotation:!0,transformEl:null}});const i=(e,s,a)=>{let i=t.isHorizontal()?e.find(".swiper-slide-shadow-left"):e.find(".swiper-slide-shadow-top"),r=t.isHorizontal()?e.find(".swiper-slide-shadow-right"):e.find(".swiper-slide-shadow-bottom");0===i.length&&(i=ie(a,e,t.isHorizontal()?"left":"top")),0===r.length&&(r=ie(a,e,t.isHorizontal()?"right":"bottom")),i.length&&(i[0].style.opacity=Math.max(-s,0)),r.length&&(r[0].style.opacity=Math.max(s,0))};te({effect:"flip",swiper:t,on:a,setTranslate:()=>{const{slides:e,rtlTranslate:s}=t,a=t.params.flipEffect;for(let r=0;r<e.length;r+=1){const n=e.eq(r);let l=n[0].progress;t.params.flipEffect.limitRotation&&(l=Math.max(Math.min(n[0].progress,1),-1));const o=n[0].swiperSlideOffset;let d=-180*l,c=0,p=t.params.cssMode?-o-t.translate:-o,u=0;t.isHorizontal()?s&&(d=-d):(u=p,p=0,c=-d,d=0),n[0].style.zIndex=-Math.abs(Math.round(l))+e.length,a.slideShadows&&i(n,l,a);const h=`translate3d(${p}px, ${u}px, 0px) rotateX(${c}deg) rotateY(${d}deg)`;se(a,n).transform(h)}},setTransition:e=>{const{transformEl:s}=t.params.flipEffect;(s?t.slides.find(s):t.slides).transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e),ae({swiper:t,duration:e,transformEl:s})},recreateShadows:()=>{const e=t.params.flipEffect;t.slides.each((s=>{const a=d(s);let r=a[0].progress;t.params.flipEffect.limitRotation&&(r=Math.max(Math.min(s.progress,1),-1)),i(a,r,e)}))},getEffectParams:()=>t.params.flipEffect,perspective:()=>!0,overwriteParams:()=>({slidesPerView:1,slidesPerGroup:1,watchSlidesProgress:!0,spaceBetween:0,virtualTranslate:!t.params.cssMode})})},function(e){let{swiper:t,extendParams:s,on:a}=e;s({coverflowEffect:{rotate:50,stretch:0,depth:100,scale:1,modifier:1,slideShadows:!0,transformEl:null}}),te({effect:"coverflow",swiper:t,on:a,setTranslate:()=>{const{width:e,height:s,slides:a,slidesSizesGrid:i}=t,r=t.params.coverflowEffect,n=t.isHorizontal(),l=t.translate,o=n?e/2-l:s/2-l,d=n?r.rotate:-r.rotate,c=r.depth;for(let e=0,t=a.length;e<t;e+=1){const t=a.eq(e),s=i[e],l=(o-t[0].swiperSlideOffset-s/2)/s,p="function"==typeof r.modifier?r.modifier(l):l*r.modifier;let u=n?d*p:0,h=n?0:d*p,m=-c*Math.abs(p),f=r.stretch;"string"==typeof f&&-1!==f.indexOf("%")&&(f=parseFloat(r.stretch)/100*s);let g=n?0:f*p,v=n?f*p:0,w=1-(1-r.scale)*Math.abs(p);Math.abs(v)<.001&&(v=0),Math.abs(g)<.001&&(g=0),Math.abs(m)<.001&&(m=0),Math.abs(u)<.001&&(u=0),Math.abs(h)<.001&&(h=0),Math.abs(w)<.001&&(w=0);const b=`translate3d(${v}px,${g}px,${m}px)  rotateX(${h}deg) rotateY(${u}deg) scale(${w})`;if(se(r,t).transform(b),t[0].style.zIndex=1-Math.abs(Math.round(p)),r.slideShadows){let e=n?t.find(".swiper-slide-shadow-left"):t.find(".swiper-slide-shadow-top"),s=n?t.find(".swiper-slide-shadow-right"):t.find(".swiper-slide-shadow-bottom");0===e.length&&(e=ie(r,t,n?"left":"top")),0===s.length&&(s=ie(r,t,n?"right":"bottom")),e.length&&(e[0].style.opacity=p>0?p:0),s.length&&(s[0].style.opacity=-p>0?-p:0)}}},setTransition:e=>{const{transformEl:s}=t.params.coverflowEffect;(s?t.slides.find(s):t.slides).transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e)},perspective:()=>!0,overwriteParams:()=>({watchSlidesProgress:!0})})},function(e){let{swiper:t,extendParams:s,on:a}=e;s({creativeEffect:{transformEl:null,limitProgress:1,shadowPerProgress:!1,progressMultiplier:1,perspective:!0,prev:{translate:[0,0,0],rotate:[0,0,0],opacity:1,scale:1},next:{translate:[0,0,0],rotate:[0,0,0],opacity:1,scale:1}}});const i=e=>"string"==typeof e?e:`${e}px`;te({effect:"creative",swiper:t,on:a,setTranslate:()=>{const{slides:e,$wrapperEl:s,slidesSizesGrid:a}=t,r=t.params.creativeEffect,{progressMultiplier:n}=r,l=t.params.centeredSlides;if(l){const e=a[0]/2-t.params.slidesOffsetBefore||0;s.transform(`translateX(calc(50% - ${e}px))`)}for(let s=0;s<e.length;s+=1){const a=e.eq(s),o=a[0].progress,d=Math.min(Math.max(a[0].progress,-r.limitProgress),r.limitProgress);let c=d;l||(c=Math.min(Math.max(a[0].originalProgress,-r.limitProgress),r.limitProgress));const p=a[0].swiperSlideOffset,u=[t.params.cssMode?-p-t.translate:-p,0,0],h=[0,0,0];let m=!1;t.isHorizontal()||(u[1]=u[0],u[0]=0);let f={translate:[0,0,0],rotate:[0,0,0],scale:1,opacity:1};d<0?(f=r.next,m=!0):d>0&&(f=r.prev,m=!0),u.forEach(((e,t)=>{u[t]=`calc(${e}px + (${i(f.translate[t])} * ${Math.abs(d*n)}))`})),h.forEach(((e,t)=>{h[t]=f.rotate[t]*Math.abs(d*n)})),a[0].style.zIndex=-Math.abs(Math.round(o))+e.length;const g=u.join(", "),v=`rotateX(${h[0]}deg) rotateY(${h[1]}deg) rotateZ(${h[2]}deg)`,w=c<0?`scale(${1+(1-f.scale)*c*n})`:`scale(${1-(1-f.scale)*c*n})`,b=c<0?1+(1-f.opacity)*c*n:1-(1-f.opacity)*c*n,x=`translate3d(${g}) ${v} ${w}`;if(m&&f.shadow||!m){let e=a.children(".swiper-slide-shadow");if(0===e.length&&f.shadow&&(e=ie(r,a)),e.length){const t=r.shadowPerProgress?d*(1/r.limitProgress):d;e[0].style.opacity=Math.min(Math.max(Math.abs(t),0),1)}}const y=se(r,a);y.transform(x).css({opacity:b}),f.origin&&y.css("transform-origin",f.origin)}},setTransition:e=>{const{transformEl:s}=t.params.creativeEffect;(s?t.slides.find(s):t.slides).transition(e).find(".swiper-slide-shadow").transition(e),ae({swiper:t,duration:e,transformEl:s,allSlides:!0})},perspective:()=>t.params.creativeEffect.perspective,overwriteParams:()=>({watchSlidesProgress:!0,virtualTranslate:!t.params.cssMode})})},function(e){let{swiper:t,extendParams:s,on:a}=e;s({cardsEffect:{slideShadows:!0,transformEl:null,rotate:!0}}),te({effect:"cards",swiper:t,on:a,setTranslate:()=>{const{slides:e,activeIndex:s}=t,a=t.params.cardsEffect,{startTranslate:i,isTouched:r}=t.touchEventsData,n=t.translate;for(let l=0;l<e.length;l+=1){const o=e.eq(l),d=o[0].progress,c=Math.min(Math.max(d,-4),4);let p=o[0].swiperSlideOffset;t.params.centeredSlides&&!t.params.cssMode&&t.$wrapperEl.transform(`translateX(${t.minTranslate()}px)`),t.params.centeredSlides&&t.params.cssMode&&(p-=e[0].swiperSlideOffset);let u=t.params.cssMode?-p-t.translate:-p,h=0;const m=-100*Math.abs(c);let f=1,g=-2*c,v=8-.75*Math.abs(c);const w=t.virtual&&t.params.virtual.enabled?t.virtual.from+l:l,b=(w===s||w===s-1)&&c>0&&c<1&&(r||t.params.cssMode)&&n<i,x=(w===s||w===s+1)&&c<0&&c>-1&&(r||t.params.cssMode)&&n>i;if(b||x){const e=(1-Math.abs((Math.abs(c)-.5)/.5))**.5;g+=-28*c*e,f+=-.5*e,v+=96*e,h=-25*e*Math.abs(c)+"%"}if(u=c<0?`calc(${u}px + (${v*Math.abs(c)}%))`:c>0?`calc(${u}px + (-${v*Math.abs(c)}%))`:`${u}px`,!t.isHorizontal()){const e=h;h=u,u=e}const y=c<0?""+(1+(1-f)*c):""+(1-(1-f)*c),E=`\n        translate3d(${u}, ${h}, ${m}px)\n        rotateZ(${a.rotate?g:0}deg)\n        scale(${y})\n      `;if(a.slideShadows){let e=o.find(".swiper-slide-shadow");0===e.length&&(e=ie(a,o)),e.length&&(e[0].style.opacity=Math.min(Math.max((Math.abs(c)-.5)/.5,0),1))}o[0].style.zIndex=-Math.abs(Math.round(d))+e.length;se(a,o).transform(E)}},setTransition:e=>{const{transformEl:s}=t.params.cardsEffect;(s?t.slides.find(s):t.slides).transition(e).find(".swiper-slide-shadow").transition(e),ae({swiper:t,duration:e,transformEl:s})},perspective:()=>!0,overwriteParams:()=>({watchSlidesProgress:!0,virtualTranslate:!t.params.cssMode})})}];return V.use(re),V}));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJzd2lwZXItYnVuZGxlLm1pbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogU3dpcGVyIDguMi40XHJcbiAqIE1vc3QgbW9kZXJuIG1vYmlsZSB0b3VjaCBzbGlkZXIgYW5kIGZyYW1ld29yayB3aXRoIGhhcmR3YXJlIGFjY2VsZXJhdGVkIHRyYW5zaXRpb25zXHJcbiAqIGh0dHBzOi8vc3dpcGVyanMuY29tXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDE0LTIwMjIgVmxhZGltaXIgS2hhcmxhbXBpZGlcclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXHJcbiAqXHJcbiAqIFJlbGVhc2VkIG9uOiBKdW5lIDEzLCAyMDIyXHJcbiAqL1xyXG5cclxuISBmdW5jdGlvbihlLCB0KSB7IFwib2JqZWN0XCIgPT0gdHlwZW9mIGV4cG9ydHMgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgPSB0KCkgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKHQpIDogKGUgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcyA6IGUgfHwgc2VsZikuU3dpcGVyID0gdCgpIH0odGhpcywgKGZ1bmN0aW9uKCkgeyBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGUoZSkgeyByZXR1cm4gbnVsbCAhPT0gZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIFwiY29uc3RydWN0b3JcIiBpbiBlICYmIGUuY29uc3RydWN0b3IgPT09IE9iamVjdCB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiB0KHMsIGEpIHsgdm9pZCAwID09PSBzICYmIChzID0ge30pLCB2b2lkIDAgPT09IGEgJiYgKGEgPSB7fSksIE9iamVjdC5rZXlzKGEpLmZvckVhY2goKGkgPT4geyB2b2lkIDAgPT09IHNbaV0gPyBzW2ldID0gYVtpXSA6IGUoYVtpXSkgJiYgZShzW2ldKSAmJiBPYmplY3Qua2V5cyhhW2ldKS5sZW5ndGggPiAwICYmIHQoc1tpXSwgYVtpXSkgfSkpIH0gY29uc3QgcyA9IHsgYm9keToge30sIGFkZEV2ZW50TGlzdGVuZXIoKSB7fSwgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHt9LCBhY3RpdmVFbGVtZW50OiB7IGJsdXIoKSB7fSwgbm9kZU5hbWU6IFwiXCIgfSwgcXVlcnlTZWxlY3RvcjogKCkgPT4gbnVsbCwgcXVlcnlTZWxlY3RvckFsbDogKCkgPT4gW10sIGdldEVsZW1lbnRCeUlkOiAoKSA9PiBudWxsLCBjcmVhdGVFdmVudDogKCkgPT4gKHsgaW5pdEV2ZW50KCkge30gfSksIGNyZWF0ZUVsZW1lbnQ6ICgpID0+ICh7IGNoaWxkcmVuOiBbXSwgY2hpbGROb2RlczogW10sIHN0eWxlOiB7fSwgc2V0QXR0cmlidXRlKCkge30sIGdldEVsZW1lbnRzQnlUYWdOYW1lOiAoKSA9PiBbXSB9KSwgY3JlYXRlRWxlbWVudE5TOiAoKSA9PiAoe30pLCBpbXBvcnROb2RlOiAoKSA9PiBudWxsLCBsb2NhdGlvbjogeyBoYXNoOiBcIlwiLCBob3N0OiBcIlwiLCBob3N0bmFtZTogXCJcIiwgaHJlZjogXCJcIiwgb3JpZ2luOiBcIlwiLCBwYXRobmFtZTogXCJcIiwgcHJvdG9jb2w6IFwiXCIsIHNlYXJjaDogXCJcIiB9IH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBhKCkgeyBjb25zdCBlID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZG9jdW1lbnQgPyBkb2N1bWVudCA6IHt9OyByZXR1cm4gdChlLCBzKSwgZSB9IGNvbnN0IGkgPSB7IGRvY3VtZW50OiBzLCBuYXZpZ2F0b3I6IHsgdXNlckFnZW50OiBcIlwiIH0sIGxvY2F0aW9uOiB7IGhhc2g6IFwiXCIsIGhvc3Q6IFwiXCIsIGhvc3RuYW1lOiBcIlwiLCBocmVmOiBcIlwiLCBvcmlnaW46IFwiXCIsIHBhdGhuYW1lOiBcIlwiLCBwcm90b2NvbDogXCJcIiwgc2VhcmNoOiBcIlwiIH0sIGhpc3Rvcnk6IHsgcmVwbGFjZVN0YXRlKCkge30sIHB1c2hTdGF0ZSgpIHt9LCBnbygpIHt9LCBiYWNrKCkge30gfSwgQ3VzdG9tRXZlbnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9LCBhZGRFdmVudExpc3RlbmVyKCkge30sIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7fSwgZ2V0Q29tcHV0ZWRTdHlsZTogKCkgPT4gKHsgZ2V0UHJvcGVydHlWYWx1ZTogKCkgPT4gXCJcIiB9KSwgSW1hZ2UoKSB7fSwgRGF0ZSgpIHt9LCBzY3JlZW46IHt9LCBzZXRUaW1lb3V0KCkge30sIGNsZWFyVGltZW91dCgpIHt9LCBtYXRjaE1lZGlhOiAoKSA9PiAoe30pLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGUgPT4gXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2Ygc2V0VGltZW91dCA/IChlKCksIG51bGwpIDogc2V0VGltZW91dChlLCAwKSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZSkgeyBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBzZXRUaW1lb3V0ICYmIGNsZWFyVGltZW91dChlKSB9IH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiByKCkgeyBjb25zdCBlID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDoge307IHJldHVybiB0KGUsIGkpLCBlIH1cclxuICAgICAgICAgICAgY2xhc3MgbiBleHRlbmRzIEFycmF5IHsgY29uc3RydWN0b3IoZSkgeyBcIm51bWJlclwiID09IHR5cGVvZiBlID8gc3VwZXIoZSkgOiAoc3VwZXIoLi4uZSB8fCBbXSksIGZ1bmN0aW9uKGUpIHsgY29uc3QgdCA9IGUuX19wcm90b19fO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX3Byb3RvX19cIiwgeyBnZXQ6ICgpID0+IHQsIHNldChlKSB7IHQuX19wcm90b19fID0gZSB9IH0pIH0odGhpcykpIH0gfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gbChlKSB7IHZvaWQgMCA9PT0gZSAmJiAoZSA9IFtdKTsgY29uc3QgdCA9IFtdOyByZXR1cm4gZS5mb3JFYWNoKChlID0+IHsgQXJyYXkuaXNBcnJheShlKSA/IHQucHVzaCguLi5sKGUpKSA6IHQucHVzaChlKSB9KSksIHQgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gbyhlLCB0KSB7IHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZSwgdCkgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZChlLCB0KSB7IGNvbnN0IHMgPSByKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IGEoKTsgbGV0IGwgPSBbXTsgaWYgKCF0ICYmIGUgaW5zdGFuY2VvZiBuKSByZXR1cm4gZTsgaWYgKCFlKSByZXR1cm4gbmV3IG4obCk7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7IGNvbnN0IHMgPSBlLnRyaW0oKTsgaWYgKHMuaW5kZXhPZihcIjxcIikgPj0gMCAmJiBzLmluZGV4T2YoXCI+XCIpID49IDApIHsgbGV0IGUgPSBcImRpdlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAwID09PSBzLmluZGV4T2YoXCI8bGlcIikgJiYgKGUgPSBcInVsXCIpLCAwID09PSBzLmluZGV4T2YoXCI8dHJcIikgJiYgKGUgPSBcInRib2R5XCIpLCAwICE9PSBzLmluZGV4T2YoXCI8dGRcIikgJiYgMCAhPT0gcy5pbmRleE9mKFwiPHRoXCIpIHx8IChlID0gXCJ0clwiKSwgMCA9PT0gcy5pbmRleE9mKFwiPHRib2R5XCIpICYmIChlID0gXCJ0YWJsZVwiKSwgMCA9PT0gcy5pbmRleE9mKFwiPG9wdGlvblwiKSAmJiAoZSA9IFwic2VsZWN0XCIpOyBjb25zdCB0ID0gaS5jcmVhdGVFbGVtZW50KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0LmlubmVySFRNTCA9IHM7IGZvciAobGV0IGUgPSAwOyBlIDwgdC5jaGlsZE5vZGVzLmxlbmd0aDsgZSArPSAxKSBsLnB1c2godC5jaGlsZE5vZGVzW2VdKSB9IGVsc2UgbCA9IGZ1bmN0aW9uKGUsIHQpIHsgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUpIHJldHVybiBbZV07IGNvbnN0IHMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSB0LnF1ZXJ5U2VsZWN0b3JBbGwoZSk7IGZvciAobGV0IGUgPSAwOyBlIDwgYS5sZW5ndGg7IGUgKz0gMSkgcy5wdXNoKGFbZV0pOyByZXR1cm4gcyB9KGUudHJpbSgpLCB0IHx8IGkpIH0gZWxzZSBpZiAoZS5ub2RlVHlwZSB8fCBlID09PSBzIHx8IGUgPT09IGkpIGwucHVzaChlKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHsgaWYgKGUgaW5zdGFuY2VvZiBuKSByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICBsID0gZSB9IHJldHVybiBuZXcgbihmdW5jdGlvbihlKSB7IGNvbnN0IHQgPSBbXTsgZm9yIChsZXQgcyA9IDA7IHMgPCBlLmxlbmd0aDsgcyArPSAxKSAtIDEgPT09IHQuaW5kZXhPZihlW3NdKSAmJiB0LnB1c2goZVtzXSk7IHJldHVybiB0IH0obCkpIH1cclxuICAgICAgICAgICAgZC5mbiA9IG4ucHJvdG90eXBlOyBjb25zdCBjID0geyBhZGRDbGFzczogZnVuY3Rpb24oKSB7IGZvciAodmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KGUpLCBzID0gMDsgcyA8IGU7IHMrKykgdFtzXSA9IGFyZ3VtZW50c1tzXTsgY29uc3QgYSA9IGwodC5tYXAoKGUgPT4gZS5zcGxpdChcIiBcIikpKSk7IHJldHVybiB0aGlzLmZvckVhY2goKGUgPT4geyBlLmNsYXNzTGlzdC5hZGQoLi4uYSkgfSkpLCB0aGlzIH0sIHJlbW92ZUNsYXNzOiBmdW5jdGlvbigpIHsgZm9yICh2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoZSksIHMgPSAwOyBzIDwgZTsgcysrKSB0W3NdID0gYXJndW1lbnRzW3NdOyBjb25zdCBhID0gbCh0Lm1hcCgoZSA9PiBlLnNwbGl0KFwiIFwiKSkpKTsgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZSA9PiB7IGUuY2xhc3NMaXN0LnJlbW92ZSguLi5hKSB9KSksIHRoaXMgfSwgaGFzQ2xhc3M6IGZ1bmN0aW9uKCkgeyBmb3IgKHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShlKSwgcyA9IDA7IHMgPCBlOyBzKyspIHRbc10gPSBhcmd1bWVudHNbc107IGNvbnN0IGEgPSBsKHQubWFwKChlID0+IGUuc3BsaXQoXCIgXCIpKSkpOyByZXR1cm4gbyh0aGlzLCAoZSA9PiBhLmZpbHRlcigodCA9PiBlLmNsYXNzTGlzdC5jb250YWlucyh0KSkpLmxlbmd0aCA+IDApKS5sZW5ndGggPiAwIH0sIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbigpIHsgZm9yICh2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoZSksIHMgPSAwOyBzIDwgZTsgcysrKSB0W3NdID0gYXJndW1lbnRzW3NdOyBjb25zdCBhID0gbCh0Lm1hcCgoZSA9PiBlLnNwbGl0KFwiIFwiKSkpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvckVhY2goKGUgPT4geyBhLmZvckVhY2goKHQgPT4geyBlLmNsYXNzTGlzdC50b2dnbGUodCkgfSkpIH0pKSB9LCBhdHRyOiBmdW5jdGlvbihlLCB0KSB7IGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHJldHVybiB0aGlzWzBdID8gdGhpc1swXS5nZXRBdHRyaWJ1dGUoZSkgOiB2b2lkIDA7IGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5sZW5ndGg7IHMgKz0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHRoaXNbc10uc2V0QXR0cmlidXRlKGUsIHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHQgaW4gZSkgdGhpc1tzXVt0XSA9IGVbdF0sIHRoaXNbc10uc2V0QXR0cmlidXRlKHQsIGVbdF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzIH0sIHJlbW92ZUF0dHI6IGZ1bmN0aW9uKGUpIHsgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLmxlbmd0aDsgdCArPSAxKSB0aGlzW3RdLnJlbW92ZUF0dHJpYnV0ZShlKTsgcmV0dXJuIHRoaXMgfSwgdHJhbnNmb3JtOiBmdW5jdGlvbihlKSB7IGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5sZW5ndGg7IHQgKz0gMSkgdGhpc1t0XS5zdHlsZS50cmFuc2Zvcm0gPSBlOyByZXR1cm4gdGhpcyB9LCB0cmFuc2l0aW9uOiBmdW5jdGlvbihlKSB7IGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5sZW5ndGg7IHQgKz0gMSkgdGhpc1t0XS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBcInN0cmluZ1wiICE9IHR5cGVvZiBlID8gYCR7ZX1tc2AgOiBlOyByZXR1cm4gdGhpcyB9LCBvbjogZnVuY3Rpb24oKSB7IGZvciAodmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KGUpLCBzID0gMDsgcyA8IGU7IHMrKykgdFtzXSA9IGFyZ3VtZW50c1tzXTsgbGV0IFthLCBpLCByLCBuXSA9IHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGwoZSkgeyBjb25zdCB0ID0gZS50YXJnZXQ7IGlmICghdCkgcmV0dXJuOyBjb25zdCBzID0gZS50YXJnZXQuZG9tN0V2ZW50RGF0YSB8fCBbXTsgaWYgKHMuaW5kZXhPZihlKSA8IDAgJiYgcy51bnNoaWZ0KGUpLCBkKHQpLmlzKGkpKSByLmFwcGx5KHQsIHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgY29uc3QgZSA9IGQodCkucGFyZW50cygpOyBmb3IgKGxldCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0ICs9IDEpIGQoZVt0XSkuaXMoaSkgJiYgci5hcHBseShlW3RdLCBzKSB9IH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbyhlKSB7IGNvbnN0IHQgPSBlICYmIGUudGFyZ2V0ICYmIGUudGFyZ2V0LmRvbTdFdmVudERhdGEgfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuaW5kZXhPZihlKSA8IDAgJiYgdC51bnNoaWZ0KGUpLCByLmFwcGx5KHRoaXMsIHQpIH0gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0WzFdICYmIChbYSwgciwgbl0gPSB0LCBpID0gdm9pZCAwKSwgbiB8fCAobiA9ICExKTsgY29uc3QgYyA9IGEuc3BsaXQoXCIgXCIpOyBsZXQgcDsgZm9yIChsZXQgZSA9IDA7IGUgPCB0aGlzLmxlbmd0aDsgZSArPSAxKSB7IGNvbnN0IHQgPSB0aGlzW2VdOyBpZiAoaSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocCA9IDA7IHAgPCBjLmxlbmd0aDsgcCArPSAxKSB7IGNvbnN0IGUgPSBjW3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuZG9tN0xpdmVMaXN0ZW5lcnMgfHwgKHQuZG9tN0xpdmVMaXN0ZW5lcnMgPSB7fSksIHQuZG9tN0xpdmVMaXN0ZW5lcnNbZV0gfHwgKHQuZG9tN0xpdmVMaXN0ZW5lcnNbZV0gPSBbXSksIHQuZG9tN0xpdmVMaXN0ZW5lcnNbZV0ucHVzaCh7IGxpc3RlbmVyOiByLCBwcm94eUxpc3RlbmVyOiBsIH0pLCB0LmFkZEV2ZW50TGlzdGVuZXIoZSwgbCwgbikgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwID0gMDsgcCA8IGMubGVuZ3RoOyBwICs9IDEpIHsgY29uc3QgZSA9IGNbcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuZG9tN0xpc3RlbmVycyB8fCAodC5kb203TGlzdGVuZXJzID0ge30pLCB0LmRvbTdMaXN0ZW5lcnNbZV0gfHwgKHQuZG9tN0xpc3RlbmVyc1tlXSA9IFtdKSwgdC5kb203TGlzdGVuZXJzW2VdLnB1c2goeyBsaXN0ZW5lcjogciwgcHJveHlMaXN0ZW5lcjogbyB9KSwgdC5hZGRFdmVudExpc3RlbmVyKGUsIG8sIG4pIH0gfSByZXR1cm4gdGhpcyB9LCBvZmY6IGZ1bmN0aW9uKCkgeyBmb3IgKHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShlKSwgcyA9IDA7IHMgPCBlOyBzKyspIHRbc10gPSBhcmd1bWVudHNbc107IGxldCBbYSwgaSwgciwgbl0gPSB0OyBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRbMV0gJiYgKFthLCByLCBuXSA9IHQsIGkgPSB2b2lkIDApLCBuIHx8IChuID0gITEpOyBjb25zdCBsID0gYS5zcGxpdChcIiBcIik7IGZvciAobGV0IGUgPSAwOyBlIDwgbC5sZW5ndGg7IGUgKz0gMSkgeyBjb25zdCB0ID0gbFtlXTsgZm9yIChsZXQgZSA9IDA7IGUgPCB0aGlzLmxlbmd0aDsgZSArPSAxKSB7IGNvbnN0IHMgPSB0aGlzW2VdOyBsZXQgYTsgaWYgKCFpICYmIHMuZG9tN0xpc3RlbmVycyA/IGEgPSBzLmRvbTdMaXN0ZW5lcnNbdF0gOiBpICYmIHMuZG9tN0xpdmVMaXN0ZW5lcnMgJiYgKGEgPSBzLmRvbTdMaXZlTGlzdGVuZXJzW3RdKSwgYSAmJiBhLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBlID0gYS5sZW5ndGggLSAxOyBlID49IDA7IGUgLT0gMSkgeyBjb25zdCBpID0gYVtlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciAmJiBpLmxpc3RlbmVyID09PSByIHx8IHIgJiYgaS5saXN0ZW5lciAmJiBpLmxpc3RlbmVyLmRvbTdwcm94eSAmJiBpLmxpc3RlbmVyLmRvbTdwcm94eSA9PT0gciA/IChzLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgaS5wcm94eUxpc3RlbmVyLCBuKSwgYS5zcGxpY2UoZSwgMSkpIDogciB8fCAocy5yZW1vdmVFdmVudExpc3RlbmVyKHQsIGkucHJveHlMaXN0ZW5lciwgbiksIGEuc3BsaWNlKGUsIDEpKSB9IH0gfSByZXR1cm4gdGhpcyB9LCB0cmlnZ2VyOiBmdW5jdGlvbigpIHsgY29uc3QgZSA9IHIoKTsgZm9yICh2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGgsIHMgPSBuZXcgQXJyYXkodCksIGEgPSAwOyBhIDwgdDsgYSsrKSBzW2FdID0gYXJndW1lbnRzW2FdOyBjb25zdCBpID0gc1swXS5zcGxpdChcIiBcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBzWzFdOyBmb3IgKGxldCB0ID0gMDsgdCA8IGkubGVuZ3RoOyB0ICs9IDEpIHsgY29uc3QgYSA9IGlbdF07IGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5sZW5ndGg7IHQgKz0gMSkgeyBjb25zdCBpID0gdGhpc1t0XTsgaWYgKGUuQ3VzdG9tRXZlbnQpIHsgY29uc3QgdCA9IG5ldyBlLkN1c3RvbUV2ZW50KGEsIHsgZGV0YWlsOiBuLCBidWJibGVzOiAhMCwgY2FuY2VsYWJsZTogITAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaS5kb203RXZlbnREYXRhID0gcy5maWx0ZXIoKChlLCB0KSA9PiB0ID4gMCkpLCBpLmRpc3BhdGNoRXZlbnQodCksIGkuZG9tN0V2ZW50RGF0YSA9IFtdLCBkZWxldGUgaS5kb203RXZlbnREYXRhIH0gfSB9IHJldHVybiB0aGlzIH0sIHRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uKGUpIHsgY29uc3QgdCA9IHRoaXM7IHJldHVybiBlICYmIHQub24oXCJ0cmFuc2l0aW9uZW5kXCIsIChmdW5jdGlvbiBzKGEpIHsgYS50YXJnZXQgPT09IHRoaXMgJiYgKGUuY2FsbCh0aGlzLCBhKSwgdC5vZmYoXCJ0cmFuc2l0aW9uZW5kXCIsIHMpKSB9KSksIHRoaXMgfSwgb3V0ZXJXaWR0aDogZnVuY3Rpb24oZSkgeyBpZiAodGhpcy5sZW5ndGggPiAwKSB7IGlmIChlKSB7IGNvbnN0IGUgPSB0aGlzLnN0eWxlcygpOyByZXR1cm4gdGhpc1swXS5vZmZzZXRXaWR0aCArIHBhcnNlRmxvYXQoZS5nZXRQcm9wZXJ0eVZhbHVlKFwibWFyZ2luLXJpZ2h0XCIpKSArIHBhcnNlRmxvYXQoZS5nZXRQcm9wZXJ0eVZhbHVlKFwibWFyZ2luLWxlZnRcIikpIH0gcmV0dXJuIHRoaXNbMF0ub2Zmc2V0V2lkdGggfSByZXR1cm4gbnVsbCB9LCBvdXRlckhlaWdodDogZnVuY3Rpb24oZSkgeyBpZiAodGhpcy5sZW5ndGggPiAwKSB7IGlmIChlKSB7IGNvbnN0IGUgPSB0aGlzLnN0eWxlcygpOyByZXR1cm4gdGhpc1swXS5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KGUuZ2V0UHJvcGVydHlWYWx1ZShcIm1hcmdpbi10b3BcIikpICsgcGFyc2VGbG9hdChlLmdldFByb3BlcnR5VmFsdWUoXCJtYXJnaW4tYm90dG9tXCIpKSB9IHJldHVybiB0aGlzWzBdLm9mZnNldEhlaWdodCB9IHJldHVybiBudWxsIH0sIHN0eWxlczogZnVuY3Rpb24oKSB7IGNvbnN0IGUgPSByKCk7IHJldHVybiB0aGlzWzBdID8gZS5nZXRDb21wdXRlZFN0eWxlKHRoaXNbMF0sIG51bGwpIDoge30gfSwgb2Zmc2V0OiBmdW5jdGlvbigpIHsgaWYgKHRoaXMubGVuZ3RoID4gMCkgeyBjb25zdCBlID0gcigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGEoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB0aGlzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gdC5ib2R5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHMuY2xpZW50VG9wIHx8IG4uY2xpZW50VG9wIHx8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gcy5jbGllbnRMZWZ0IHx8IG4uY2xpZW50TGVmdCB8fCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHMgPT09IGUgPyBlLnNjcm9sbFkgOiBzLnNjcm9sbFRvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBzID09PSBlID8gZS5zY3JvbGxYIDogcy5zY3JvbGxMZWZ0OyByZXR1cm4geyB0b3A6IGkudG9wICsgZCAtIGwsIGxlZnQ6IGkubGVmdCArIGMgLSBvIH0gfSByZXR1cm4gbnVsbCB9LCBjc3M6IGZ1bmN0aW9uKGUsIHQpIHsgY29uc3QgcyA9IHIoKTsgbGV0IGE7IGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7IGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiBlKSB7IGZvciAoYSA9IDA7IGEgPCB0aGlzLmxlbmd0aDsgYSArPSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdCBpbiBlKSB0aGlzW2FdLnN0eWxlW3RdID0gZVt0XTsgcmV0dXJuIHRoaXMgfSBpZiAodGhpc1swXSkgcmV0dXJuIHMuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzWzBdLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKGUpIH0gaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGggJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkgeyBmb3IgKGEgPSAwOyBhIDwgdGhpcy5sZW5ndGg7IGEgKz0gMSkgdGhpc1thXS5zdHlsZVtlXSA9IHQ7IHJldHVybiB0aGlzIH0gcmV0dXJuIHRoaXMgfSwgZWFjaDogZnVuY3Rpb24oZSkgeyByZXR1cm4gZSA/ICh0aGlzLmZvckVhY2goKCh0LCBzKSA9PiB7IGUuYXBwbHkodCwgW3QsIHNdKSB9KSksIHRoaXMpIDogdGhpcyB9LCBodG1sOiBmdW5jdGlvbihlKSB7IGlmICh2b2lkIDAgPT09IGUpIHJldHVybiB0aGlzWzBdID8gdGhpc1swXS5pbm5lckhUTUwgOiBudWxsOyBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMubGVuZ3RoOyB0ICs9IDEpIHRoaXNbdF0uaW5uZXJIVE1MID0gZTsgcmV0dXJuIHRoaXMgfSwgdGV4dDogZnVuY3Rpb24oZSkgeyBpZiAodm9pZCAwID09PSBlKSByZXR1cm4gdGhpc1swXSA/IHRoaXNbMF0udGV4dENvbnRlbnQudHJpbSgpIDogbnVsbDsgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLmxlbmd0aDsgdCArPSAxKSB0aGlzW3RdLnRleHRDb250ZW50ID0gZTsgcmV0dXJuIHRoaXMgfSwgaXM6IGZ1bmN0aW9uKGUpIHsgY29uc3QgdCA9IHIoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IGEoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHRoaXNbMF07IGxldCBsLCBvOyBpZiAoIWkgfHwgdm9pZCAwID09PSBlKSByZXR1cm4gITE7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7IGlmIChpLm1hdGNoZXMpIHJldHVybiBpLm1hdGNoZXMoZSk7IGlmIChpLndlYmtpdE1hdGNoZXNTZWxlY3RvcikgcmV0dXJuIGkud2Via2l0TWF0Y2hlc1NlbGVjdG9yKGUpOyBpZiAoaS5tc01hdGNoZXNTZWxlY3RvcikgcmV0dXJuIGkubXNNYXRjaGVzU2VsZWN0b3IoZSk7IGZvciAobCA9IGQoZSksIG8gPSAwOyBvIDwgbC5sZW5ndGg7IG8gKz0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsW29dID09PSBpKSByZXR1cm4gITA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMSB9IGlmIChlID09PSBzKSByZXR1cm4gaSA9PT0gczsgaWYgKGUgPT09IHQpIHJldHVybiBpID09PSB0OyBpZiAoZS5ub2RlVHlwZSB8fCBlIGluc3RhbmNlb2YgbikgeyBmb3IgKGwgPSBlLm5vZGVUeXBlID8gW2VdIDogZSwgbyA9IDA7IG8gPCBsLmxlbmd0aDsgbyArPSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxbb10gPT09IGkpIHJldHVybiAhMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExIH0gcmV0dXJuICExIH0sIGluZGV4OiBmdW5jdGlvbigpIHsgbGV0IGUsIHQgPSB0aGlzWzBdOyBpZiAodCkgeyBmb3IgKGUgPSAwOyBudWxsICE9PSAodCA9IHQucHJldmlvdXNTaWJsaW5nKTspIDEgPT09IHQubm9kZVR5cGUgJiYgKGUgKz0gMSk7IHJldHVybiBlIH0gfSwgZXE6IGZ1bmN0aW9uKGUpIHsgaWYgKHZvaWQgMCA9PT0gZSkgcmV0dXJuIHRoaXM7IGNvbnN0IHQgPSB0aGlzLmxlbmd0aDsgaWYgKGUgPiB0IC0gMSkgcmV0dXJuIGQoW10pOyBpZiAoZSA8IDApIHsgY29uc3QgcyA9IHQgKyBlOyByZXR1cm4gZChzIDwgMCA/IFtdIDogW3RoaXNbc11dKSB9IHJldHVybiBkKFt0aGlzW2VdXSkgfSwgYXBwZW5kOiBmdW5jdGlvbigpIHsgbGV0IGU7IGNvbnN0IHQgPSBhKCk7IGZvciAobGV0IHMgPSAwOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcyArPSAxKSB7IGUgPSBzIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IHMgPyB2b2lkIDAgOiBhcmd1bWVudHNbc107IGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5sZW5ndGg7IHMgKz0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7IGNvbnN0IGEgPSB0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7IGZvciAoYS5pbm5lckhUTUwgPSBlOyBhLmZpcnN0Q2hpbGQ7KSB0aGlzW3NdLmFwcGVuZENoaWxkKGEuZmlyc3RDaGlsZCkgfSBlbHNlIGlmIChlIGluc3RhbmNlb2YgbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQgKz0gMSkgdGhpc1tzXS5hcHBlbmRDaGlsZChlW3RdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB0aGlzW3NdLmFwcGVuZENoaWxkKGUpIH0gcmV0dXJuIHRoaXMgfSwgcHJlcGVuZDogZnVuY3Rpb24oZSkgeyBjb25zdCB0ID0gYSgpOyBsZXQgcywgaTsgZm9yIChzID0gMDsgcyA8IHRoaXMubGVuZ3RoOyBzICs9IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7IGNvbnN0IGEgPSB0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7IGZvciAoYS5pbm5lckhUTUwgPSBlLCBpID0gYS5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB0aGlzW3NdLmluc2VydEJlZm9yZShhLmNoaWxkTm9kZXNbaV0sIHRoaXNbc10uY2hpbGROb2Rlc1swXSkgfSBlbHNlIGlmIChlIGluc3RhbmNlb2YgbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGUubGVuZ3RoOyBpICs9IDEpIHRoaXNbc10uaW5zZXJ0QmVmb3JlKGVbaV0sIHRoaXNbc10uY2hpbGROb2Rlc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB0aGlzW3NdLmluc2VydEJlZm9yZShlLCB0aGlzW3NdLmNoaWxkTm9kZXNbMF0pOyByZXR1cm4gdGhpcyB9LCBuZXh0OiBmdW5jdGlvbihlKSB7IHJldHVybiB0aGlzLmxlbmd0aCA+IDAgPyBlID8gdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcgJiYgZCh0aGlzWzBdLm5leHRFbGVtZW50U2libGluZykuaXMoZSkgPyBkKFt0aGlzWzBdLm5leHRFbGVtZW50U2libGluZ10pIDogZChbXSkgOiB0aGlzWzBdLm5leHRFbGVtZW50U2libGluZyA/IGQoW3RoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nXSkgOiBkKFtdKSA6IGQoW10pIH0sIG5leHRBbGw6IGZ1bmN0aW9uKGUpIHsgY29uc3QgdCA9IFtdOyBsZXQgcyA9IHRoaXNbMF07IGlmICghcykgcmV0dXJuIGQoW10pOyBmb3IgKDsgcy5uZXh0RWxlbWVudFNpYmxpbmc7KSB7IGNvbnN0IGEgPSBzLm5leHRFbGVtZW50U2libGluZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA/IGQoYSkuaXMoZSkgJiYgdC5wdXNoKGEpIDogdC5wdXNoKGEpLCBzID0gYSB9IHJldHVybiBkKHQpIH0sIHByZXY6IGZ1bmN0aW9uKGUpIHsgaWYgKHRoaXMubGVuZ3RoID4gMCkgeyBjb25zdCB0ID0gdGhpc1swXTsgcmV0dXJuIGUgPyB0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgZCh0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcpLmlzKGUpID8gZChbdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXSkgOiBkKFtdKSA6IHQucHJldmlvdXNFbGVtZW50U2libGluZyA/IGQoW3QucHJldmlvdXNFbGVtZW50U2libGluZ10pIDogZChbXSkgfSByZXR1cm4gZChbXSkgfSwgcHJldkFsbDogZnVuY3Rpb24oZSkgeyBjb25zdCB0ID0gW107IGxldCBzID0gdGhpc1swXTsgaWYgKCFzKSByZXR1cm4gZChbXSk7IGZvciAoOyBzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7KSB7IGNvbnN0IGEgPSBzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPyBkKGEpLmlzKGUpICYmIHQucHVzaChhKSA6IHQucHVzaChhKSwgcyA9IGEgfSByZXR1cm4gZCh0KSB9LCBwYXJlbnQ6IGZ1bmN0aW9uKGUpIHsgY29uc3QgdCA9IFtdOyBmb3IgKGxldCBzID0gMDsgcyA8IHRoaXMubGVuZ3RoOyBzICs9IDEpIG51bGwgIT09IHRoaXNbc10ucGFyZW50Tm9kZSAmJiAoZSA/IGQodGhpc1tzXS5wYXJlbnROb2RlKS5pcyhlKSAmJiB0LnB1c2godGhpc1tzXS5wYXJlbnROb2RlKSA6IHQucHVzaCh0aGlzW3NdLnBhcmVudE5vZGUpKTsgcmV0dXJuIGQodCkgfSwgcGFyZW50czogZnVuY3Rpb24oZSkgeyBjb25zdCB0ID0gW107IGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5sZW5ndGg7IHMgKz0gMSkgeyBsZXQgYSA9IHRoaXNbc10ucGFyZW50Tm9kZTsgZm9yICg7IGE7KSBlID8gZChhKS5pcyhlKSAmJiB0LnB1c2goYSkgOiB0LnB1c2goYSksIGEgPSBhLnBhcmVudE5vZGUgfSByZXR1cm4gZCh0KSB9LCBjbG9zZXN0OiBmdW5jdGlvbihlKSB7IGxldCB0ID0gdGhpczsgcmV0dXJuIHZvaWQgMCA9PT0gZSA/IGQoW10pIDogKHQuaXMoZSkgfHwgKHQgPSB0LnBhcmVudHMoZSkuZXEoMCkpLCB0KSB9LCBmaW5kOiBmdW5jdGlvbihlKSB7IGNvbnN0IHQgPSBbXTsgZm9yIChsZXQgcyA9IDA7IHMgPCB0aGlzLmxlbmd0aDsgcyArPSAxKSB7IGNvbnN0IGEgPSB0aGlzW3NdLnF1ZXJ5U2VsZWN0b3JBbGwoZSk7IGZvciAobGV0IGUgPSAwOyBlIDwgYS5sZW5ndGg7IGUgKz0gMSkgdC5wdXNoKGFbZV0pIH0gcmV0dXJuIGQodCkgfSwgY2hpbGRyZW46IGZ1bmN0aW9uKGUpIHsgY29uc3QgdCA9IFtdOyBmb3IgKGxldCBzID0gMDsgcyA8IHRoaXMubGVuZ3RoOyBzICs9IDEpIHsgY29uc3QgYSA9IHRoaXNbc10uY2hpbGRyZW47IGZvciAobGV0IHMgPSAwOyBzIDwgYS5sZW5ndGg7IHMgKz0gMSkgZSAmJiAhZChhW3NdKS5pcyhlKSB8fCB0LnB1c2goYVtzXSkgfSByZXR1cm4gZCh0KSB9LCBmaWx0ZXI6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGQobyh0aGlzLCBlKSkgfSwgcmVtb3ZlOiBmdW5jdGlvbigpIHsgZm9yIChsZXQgZSA9IDA7IGUgPCB0aGlzLmxlbmd0aDsgZSArPSAxKSB0aGlzW2VdLnBhcmVudE5vZGUgJiYgdGhpc1tlXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXNbZV0pOyByZXR1cm4gdGhpcyB9IH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwKGUsIHQpIHsgcmV0dXJuIHZvaWQgMCA9PT0gdCAmJiAodCA9IDApLCBzZXRUaW1lb3V0KGUsIHQpIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHUoKSB7IHJldHVybiBEYXRlLm5vdygpIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGgoZSwgdCkgeyB2b2lkIDAgPT09IHQgJiYgKHQgPSBcInhcIik7IGNvbnN0IHMgPSByKCk7IGxldCBhLCBpLCBuOyBjb25zdCBsID0gZnVuY3Rpb24oZSkgeyBjb25zdCB0ID0gcigpOyBsZXQgczsgcmV0dXJuIHQuZ2V0Q29tcHV0ZWRTdHlsZSAmJiAocyA9IHQuZ2V0Q29tcHV0ZWRTdHlsZShlLCBudWxsKSksICFzICYmIGUuY3VycmVudFN0eWxlICYmIChzID0gZS5jdXJyZW50U3R5bGUpLCBzIHx8IChzID0gZS5zdHlsZSksIHMgfShlKTsgcmV0dXJuIHMuV2ViS2l0Q1NTTWF0cml4ID8gKGkgPSBsLnRyYW5zZm9ybSB8fCBsLndlYmtpdFRyYW5zZm9ybSwgaS5zcGxpdChcIixcIikubGVuZ3RoID4gNiAmJiAoaSA9IGkuc3BsaXQoXCIsIFwiKS5tYXAoKGUgPT4gZS5yZXBsYWNlKFwiLFwiLCBcIi5cIikpKS5qb2luKFwiLCBcIikpLCBuID0gbmV3IHMuV2ViS2l0Q1NTTWF0cml4KFwibm9uZVwiID09PSBpID8gXCJcIiA6IGkpKSA6IChuID0gbC5Nb3pUcmFuc2Zvcm0gfHwgbC5PVHJhbnNmb3JtIHx8IGwuTXNUcmFuc2Zvcm0gfHwgbC5tc1RyYW5zZm9ybSB8fCBsLnRyYW5zZm9ybSB8fCBsLmdldFByb3BlcnR5VmFsdWUoXCJ0cmFuc2Zvcm1cIikucmVwbGFjZShcInRyYW5zbGF0ZShcIiwgXCJtYXRyaXgoMSwgMCwgMCwgMSxcIiksIGEgPSBuLnRvU3RyaW5nKCkuc3BsaXQoXCIsXCIpKSwgXCJ4XCIgPT09IHQgJiYgKGkgPSBzLldlYktpdENTU01hdHJpeCA/IG4ubTQxIDogMTYgPT09IGEubGVuZ3RoID8gcGFyc2VGbG9hdChhWzEyXSkgOiBwYXJzZUZsb2F0KGFbNF0pKSwgXCJ5XCIgPT09IHQgJiYgKGkgPSBzLldlYktpdENTU01hdHJpeCA/IG4ubTQyIDogMTYgPT09IGEubGVuZ3RoID8gcGFyc2VGbG9hdChhWzEzXSkgOiBwYXJzZUZsb2F0KGFbNV0pKSwgaSB8fCAwIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG0oZSkgeyByZXR1cm4gXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiBudWxsICE9PSBlICYmIGUuY29uc3RydWN0b3IgJiYgXCJPYmplY3RcIiA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsIC0xKSB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBmKGUpIHsgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiB2b2lkIDAgIT09IHdpbmRvdy5IVE1MRWxlbWVudCA/IGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA6IGUgJiYgKDEgPT09IGUubm9kZVR5cGUgfHwgMTEgPT09IGUubm9kZVR5cGUpIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGcoKSB7IGNvbnN0IGUgPSBPYmplY3QoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdm9pZCAwIDogYXJndW1lbnRzWzBdKSxcclxuICAgICAgICAgICAgICAgICAgICB0ID0gW1wiX19wcm90b19fXCIsIFwiY29uc3RydWN0b3JcIiwgXCJwcm90b3R5cGVcIl07IGZvciAobGV0IHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcyArPSAxKSB7IGNvbnN0IGEgPSBzIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IHMgPyB2b2lkIDAgOiBhcmd1bWVudHNbc107IGlmIChudWxsICE9IGEgJiYgIWYoYSkpIHsgY29uc3QgcyA9IE9iamVjdC5rZXlzKE9iamVjdChhKSkuZmlsdGVyKChlID0+IHQuaW5kZXhPZihlKSA8IDApKTsgZm9yIChsZXQgdCA9IDAsIGkgPSBzLmxlbmd0aDsgdCA8IGk7IHQgKz0gMSkgeyBjb25zdCBpID0gc1t0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gciAmJiByLmVudW1lcmFibGUgJiYgKG0oZVtpXSkgJiYgbShhW2ldKSA/IGFbaV0uX19zd2lwZXJfXyA/IGVbaV0gPSBhW2ldIDogZyhlW2ldLCBhW2ldKSA6ICFtKGVbaV0pICYmIG0oYVtpXSkgPyAoZVtpXSA9IHt9LCBhW2ldLl9fc3dpcGVyX18gPyBlW2ldID0gYVtpXSA6IGcoZVtpXSwgYVtpXSkpIDogZVtpXSA9IGFbaV0pIH0gfSB9IHJldHVybiBlIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHYoZSwgdCwgcykgeyBlLnN0eWxlLnNldFByb3BlcnR5KHQsIHMpIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHcoZSkgeyBsZXQgeyBzd2lwZXI6IHQsIHRhcmdldFBvc2l0aW9uOiBzLCBzaWRlOiBhIH0gPSBlOyBjb25zdCBpID0gcigpLFxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSAtdC50cmFuc2xhdGU7IGxldCBsLCBvID0gbnVsbDsgY29uc3QgZCA9IHQucGFyYW1zLnNwZWVkO1xyXG4gICAgICAgICAgICAgICAgdC53cmFwcGVyRWwuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSBcIm5vbmVcIiwgaS5jYW5jZWxBbmltYXRpb25GcmFtZSh0LmNzc01vZGVGcmFtZUlEKTsgY29uc3QgYyA9IHMgPiBuID8gXCJuZXh0XCIgOiBcInByZXZcIixcclxuICAgICAgICAgICAgICAgICAgICBwID0gKGUsIHQpID0+IFwibmV4dFwiID09PSBjICYmIGUgPj0gdCB8fCBcInByZXZcIiA9PT0gYyAmJiBlIDw9IHQsXHJcbiAgICAgICAgICAgICAgICAgICAgdSA9ICgpID0+IHsgbCA9IChuZXcgRGF0ZSkuZ2V0VGltZSgpLCBudWxsID09PSBvICYmIChvID0gbCk7IGNvbnN0IGUgPSBNYXRoLm1heChNYXRoLm1pbigobCAtIG8pIC8gZCwgMSksIDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IC41IC0gTWF0aC5jb3MoZSAqIE1hdGguUEkpIC8gMjsgbGV0IGMgPSBuICsgciAqIChzIC0gbik7IGlmIChwKGMsIHMpICYmIChjID0gcyksIHQud3JhcHBlckVsLnNjcm9sbFRvKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYV06IGMgfSksIHAoYywgcykpIHJldHVybiB0LndyYXBwZXJFbC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCIsIHQud3JhcHBlckVsLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gXCJcIiwgc2V0VGltZW91dCgoKCkgPT4geyB0LndyYXBwZXJFbC5zdHlsZS5vdmVyZmxvdyA9IFwiXCIsIHQud3JhcHBlckVsLnNjcm9sbFRvKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYV06IGMgfSkgfSkpLCB2b2lkIGkuY2FuY2VsQW5pbWF0aW9uRnJhbWUodC5jc3NNb2RlRnJhbWVJRCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuY3NzTW9kZUZyYW1lSUQgPSBpLnJlcXVlc3RBbmltYXRpb25GcmFtZSh1KSB9O1xyXG4gICAgICAgICAgICAgICAgdSgpIH0gbGV0IGIsIHgsIHk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBFKCkgeyByZXR1cm4gYiB8fCAoYiA9IGZ1bmN0aW9uKCkgeyBjb25zdCBlID0gcigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gYSgpOyByZXR1cm4geyBzbW9vdGhTY3JvbGw6IHQuZG9jdW1lbnRFbGVtZW50ICYmIFwic2Nyb2xsQmVoYXZpb3JcIiBpbiB0LmRvY3VtZW50RWxlbWVudC5zdHlsZSwgdG91Y2g6ICEhKFwib250b3VjaHN0YXJ0XCIgaW4gZSB8fCBlLkRvY3VtZW50VG91Y2ggJiYgdCBpbnN0YW5jZW9mIGUuRG9jdW1lbnRUb3VjaCksIHBhc3NpdmVMaXN0ZW5lcjogZnVuY3Rpb24oKSB7IGxldCB0ID0gITE7IHRyeSB7IGNvbnN0IHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwicGFzc2l2ZVwiLCB7Z2V0KCkgeyB0ID0gITAgfSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0UGFzc2l2ZUxpc3RlbmVyXCIsIG51bGwsIHMpIH0gY2F0Y2ggKGUpIHt9IHJldHVybiB0IH0oKSwgZ2VzdHVyZXM6IFwib25nZXN0dXJlc3RhcnRcIiBpbiBlIH0gfSgpKSwgYiB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBDKGUpIHsgcmV0dXJuIHZvaWQgMCA9PT0gZSAmJiAoZSA9IHt9KSwgeCB8fCAoeCA9IGZ1bmN0aW9uKGUpIHsgbGV0IHsgdXNlckFnZW50OiB0IH0gPSB2b2lkIDAgPT09IGUgPyB7fSA6IGU7IGNvbnN0IHMgPSBFKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSByKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBhLm5hdmlnYXRvci5wbGF0Zm9ybSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHQgfHwgYS5uYXZpZ2F0b3IudXNlckFnZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0geyBpb3M6ICExLCBhbmRyb2lkOiAhMSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gYS5zY3JlZW4ud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBhLnNjcmVlbi5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBuLm1hdGNoKC8oQW5kcm9pZCk7P1tcXHNcXC9dKyhbXFxkLl0rKT8vKTsgbGV0IHAgPSBuLm1hdGNoKC8oaVBhZCkuKk9TXFxzKFtcXGRfXSspLyk7IGNvbnN0IHUgPSBuLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/LyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSAhcCAmJiBuLm1hdGNoKC8oaVBob25lXFxzT1N8aU9TKVxccyhbXFxkX10rKS8pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gXCJXaW4zMlwiID09PSBpOyBsZXQgZiA9IFwiTWFjSW50ZWxcIiA9PT0gaTsgcmV0dXJuICFwICYmIGYgJiYgcy50b3VjaCAmJiBbXCIxMDI0eDEzNjZcIiwgXCIxMzY2eDEwMjRcIiwgXCI4MzR4MTE5NFwiLCBcIjExOTR4ODM0XCIsIFwiODM0eDExMTJcIiwgXCIxMTEyeDgzNFwiLCBcIjc2OHgxMDI0XCIsIFwiMTAyNHg3NjhcIiwgXCI4MjB4MTE4MFwiLCBcIjExODB4ODIwXCIsIFwiODEweDEwODBcIiwgXCIxMDgweDgxMFwiXS5pbmRleE9mKGAke299eCR7ZH1gKSA+PSAwICYmIChwID0gbi5tYXRjaCgvKFZlcnNpb24pXFwvKFtcXGQuXSspLyksIHAgfHwgKHAgPSBbMCwgMSwgXCIxM18wXzBcIl0pLCBmID0gITEpLCBjICYmICFtICYmIChsLm9zID0gXCJhbmRyb2lkXCIsIGwuYW5kcm9pZCA9ICEwKSwgKHAgfHwgaCB8fCB1KSAmJiAobC5vcyA9IFwiaW9zXCIsIGwuaW9zID0gITApLCBsIH0oZSkpLCB4IH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFQoKSB7IHJldHVybiB5IHx8ICh5ID0gZnVuY3Rpb24oKSB7IGNvbnN0IGUgPSByKCk7IHJldHVybiB7IGlzU2FmYXJpOiBmdW5jdGlvbigpIHsgY29uc3QgdCA9IGUubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpOyByZXR1cm4gdC5pbmRleE9mKFwic2FmYXJpXCIpID49IDAgJiYgdC5pbmRleE9mKFwiY2hyb21lXCIpIDwgMCAmJiB0LmluZGV4T2YoXCJhbmRyb2lkXCIpIDwgMCB9KCksIGlzV2ViVmlldzogLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvaS50ZXN0KGUubmF2aWdhdG9yLnVzZXJBZ2VudCkgfSB9KCkpLCB5IH1cclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYykuZm9yRWFjaCgoZSA9PiB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkLmZuLCBlLCB7IHZhbHVlOiBjW2VdLCB3cml0YWJsZTogITAgfSkgfSkpOyB2YXIgJCA9IHsgb24oZSwgdCwgcykgeyBjb25zdCBhID0gdGhpczsgaWYgKCFhLmV2ZW50c0xpc3RlbmVycyB8fCBhLmRlc3Ryb3llZCkgcmV0dXJuIGE7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQpIHJldHVybiBhOyBjb25zdCBpID0gcyA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCI7IHJldHVybiBlLnNwbGl0KFwiIFwiKS5mb3JFYWNoKChlID0+IHsgYS5ldmVudHNMaXN0ZW5lcnNbZV0gfHwgKGEuZXZlbnRzTGlzdGVuZXJzW2VdID0gW10pLCBhLmV2ZW50c0xpc3RlbmVyc1tlXVtpXSh0KSB9KSksIGEgfSwgb25jZShlLCB0LCBzKSB7IGNvbnN0IGEgPSB0aGlzOyBpZiAoIWEuZXZlbnRzTGlzdGVuZXJzIHx8IGEuZGVzdHJveWVkKSByZXR1cm4gYTsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCkgcmV0dXJuIGE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGkoKSB7IGEub2ZmKGUsIGkpLCBpLl9fZW1pdHRlclByb3h5ICYmIGRlbGV0ZSBpLl9fZW1pdHRlclByb3h5OyBmb3IgKHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IG5ldyBBcnJheShzKSwgbiA9IDA7IG4gPCBzOyBuKyspIHJbbl0gPSBhcmd1bWVudHNbbl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuYXBwbHkoYSwgcikgfSByZXR1cm4gaS5fX2VtaXR0ZXJQcm94eSA9IHQsIGEub24oZSwgaSwgcykgfSwgb25BbnkoZSwgdCkgeyBjb25zdCBzID0gdGhpczsgaWYgKCFzLmV2ZW50c0xpc3RlbmVycyB8fCBzLmRlc3Ryb3llZCkgcmV0dXJuIHM7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiBzOyBjb25zdCBhID0gdCA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCI7IHJldHVybiBzLmV2ZW50c0FueUxpc3RlbmVycy5pbmRleE9mKGUpIDwgMCAmJiBzLmV2ZW50c0FueUxpc3RlbmVyc1thXShlKSwgcyB9LCBvZmZBbnkoZSkgeyBjb25zdCB0ID0gdGhpczsgaWYgKCF0LmV2ZW50c0xpc3RlbmVycyB8fCB0LmRlc3Ryb3llZCkgcmV0dXJuIHQ7IGlmICghdC5ldmVudHNBbnlMaXN0ZW5lcnMpIHJldHVybiB0OyBjb25zdCBzID0gdC5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihlKTsgcmV0dXJuIHMgPj0gMCAmJiB0LmV2ZW50c0FueUxpc3RlbmVycy5zcGxpY2UocywgMSksIHQgfSwgb2ZmKGUsIHQpIHsgY29uc3QgcyA9IHRoaXM7IHJldHVybiAhcy5ldmVudHNMaXN0ZW5lcnMgfHwgcy5kZXN0cm95ZWQgPyBzIDogcy5ldmVudHNMaXN0ZW5lcnMgPyAoZS5zcGxpdChcIiBcIikuZm9yRWFjaCgoZSA9PiB7IHZvaWQgMCA9PT0gdCA/IHMuZXZlbnRzTGlzdGVuZXJzW2VdID0gW10gOiBzLmV2ZW50c0xpc3RlbmVyc1tlXSAmJiBzLmV2ZW50c0xpc3RlbmVyc1tlXS5mb3JFYWNoKCgoYSwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGEgPT09IHQgfHwgYS5fX2VtaXR0ZXJQcm94eSAmJiBhLl9fZW1pdHRlclByb3h5ID09PSB0KSAmJiBzLmV2ZW50c0xpc3RlbmVyc1tlXS5zcGxpY2UoaSwgMSkgfSkpIH0pKSwgcykgOiBzIH0sIGVtaXQoKSB7IGNvbnN0IGUgPSB0aGlzOyBpZiAoIWUuZXZlbnRzTGlzdGVuZXJzIHx8IGUuZGVzdHJveWVkKSByZXR1cm4gZTsgaWYgKCFlLmV2ZW50c0xpc3RlbmVycykgcmV0dXJuIGU7IGxldCB0LCBzLCBhOyBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IG5ldyBBcnJheShpKSwgbiA9IDA7IG4gPCBpOyBuKyspIHJbbl0gPSBhcmd1bWVudHNbbl07IFwic3RyaW5nXCIgPT0gdHlwZW9mIHJbMF0gfHwgQXJyYXkuaXNBcnJheShyWzBdKSA/ICh0ID0gclswXSwgcyA9IHIuc2xpY2UoMSwgci5sZW5ndGgpLCBhID0gZSkgOiAodCA9IHJbMF0uZXZlbnRzLCBzID0gclswXS5kYXRhLCBhID0gclswXS5jb250ZXh0IHx8IGUpLCBzLnVuc2hpZnQoYSk7IHJldHVybiAoQXJyYXkuaXNBcnJheSh0KSA/IHQgOiB0LnNwbGl0KFwiIFwiKSkuZm9yRWFjaCgodCA9PiB7IGUuZXZlbnRzQW55TGlzdGVuZXJzICYmIGUuZXZlbnRzQW55TGlzdGVuZXJzLmxlbmd0aCAmJiBlLmV2ZW50c0FueUxpc3RlbmVycy5mb3JFYWNoKChlID0+IHsgZS5hcHBseShhLCBbdCwgLi4uc10pIH0pKSwgZS5ldmVudHNMaXN0ZW5lcnMgJiYgZS5ldmVudHNMaXN0ZW5lcnNbdF0gJiYgZS5ldmVudHNMaXN0ZW5lcnNbdF0uZm9yRWFjaCgoZSA9PiB7IGUuYXBwbHkoYSwgcykgfSkpIH0pKSwgZSB9IH07IHZhciBTID0geyB1cGRhdGVTaXplOiBmdW5jdGlvbigpIHsgY29uc3QgZSA9IHRoaXM7IGxldCB0LCBzOyBjb25zdCBhID0gZS4kZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHZvaWQgMCAhPT0gZS5wYXJhbXMud2lkdGggJiYgbnVsbCAhPT0gZS5wYXJhbXMud2lkdGggPyBlLnBhcmFtcy53aWR0aCA6IGFbMF0uY2xpZW50V2lkdGgsIHMgPSB2b2lkIDAgIT09IGUucGFyYW1zLmhlaWdodCAmJiBudWxsICE9PSBlLnBhcmFtcy5oZWlnaHQgPyBlLnBhcmFtcy5oZWlnaHQgOiBhWzBdLmNsaWVudEhlaWdodCwgMCA9PT0gdCAmJiBlLmlzSG9yaXpvbnRhbCgpIHx8IDAgPT09IHMgJiYgZS5pc1ZlcnRpY2FsKCkgfHwgKHQgPSB0IC0gcGFyc2VJbnQoYS5jc3MoXCJwYWRkaW5nLWxlZnRcIikgfHwgMCwgMTApIC0gcGFyc2VJbnQoYS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIpIHx8IDAsIDEwKSwgcyA9IHMgLSBwYXJzZUludChhLmNzcyhcInBhZGRpbmctdG9wXCIpIHx8IDAsIDEwKSAtIHBhcnNlSW50KGEuY3NzKFwicGFkZGluZy1ib3R0b21cIikgfHwgMCwgMTApLCBOdW1iZXIuaXNOYU4odCkgJiYgKHQgPSAwKSwgTnVtYmVyLmlzTmFOKHMpICYmIChzID0gMCksIE9iamVjdC5hc3NpZ24oZSwgeyB3aWR0aDogdCwgaGVpZ2h0OiBzLCBzaXplOiBlLmlzSG9yaXpvbnRhbCgpID8gdCA6IHMgfSkpIH0sIHVwZGF0ZVNsaWRlczogZnVuY3Rpb24oKSB7IGNvbnN0IGUgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0KHQpIHsgcmV0dXJuIGUuaXNIb3Jpem9udGFsKCkgPyB0IDogeyB3aWR0aDogXCJoZWlnaHRcIiwgXCJtYXJnaW4tdG9wXCI6IFwibWFyZ2luLWxlZnRcIiwgXCJtYXJnaW4tYm90dG9tIFwiOiBcIm1hcmdpbi1yaWdodFwiLCBcIm1hcmdpbi1sZWZ0XCI6IFwibWFyZ2luLXRvcFwiLCBcIm1hcmdpbi1yaWdodFwiOiBcIm1hcmdpbi1ib3R0b21cIiwgXCJwYWRkaW5nLWxlZnRcIjogXCJwYWRkaW5nLXRvcFwiLCBcInBhZGRpbmctcmlnaHRcIjogXCJwYWRkaW5nLWJvdHRvbVwiLCBtYXJnaW5SaWdodDogXCJtYXJnaW5Cb3R0b21cIiB9W3RdIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcyhlLCBzKSB7IHJldHVybiBwYXJzZUZsb2F0KGUuZ2V0UHJvcGVydHlWYWx1ZSh0KHMpKSB8fCAwKSB9IGNvbnN0IGEgPSBlLnBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyAkd3JhcHBlckVsOiBpLCBzaXplOiByLCBydGxUcmFuc2xhdGU6IG4sIHdyb25nUlRMOiBsIH0gPSBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gZS52aXJ0dWFsICYmIGEudmlydHVhbC5lbmFibGVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gbyA/IGUudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogZS5zbGlkZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gaS5jaGlsZHJlbihgLiR7ZS5wYXJhbXMuc2xpZGVDbGFzc31gKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IG8gPyBlLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IGMubGVuZ3RoOyBsZXQgdSA9IFtdOyBjb25zdCBoID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBbXTsgbGV0IGYgPSBhLnNsaWRlc09mZnNldEJlZm9yZTsgXCJmdW5jdGlvblwiID09IHR5cGVvZiBmICYmIChmID0gYS5zbGlkZXNPZmZzZXRCZWZvcmUuY2FsbChlKSk7IGxldCBnID0gYS5zbGlkZXNPZmZzZXRBZnRlcjsgXCJmdW5jdGlvblwiID09IHR5cGVvZiBnICYmIChnID0gYS5zbGlkZXNPZmZzZXRBZnRlci5jYWxsKGUpKTsgY29uc3QgdyA9IGUuc25hcEdyaWQubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gZS5zbGlkZXNHcmlkLmxlbmd0aDsgbGV0IHggPSBhLnNwYWNlQmV0d2VlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IC1mLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBFID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgQyA9IDA7IGlmICh2b2lkIDAgPT09IHIpIHJldHVybjsgXCJzdHJpbmdcIiA9PSB0eXBlb2YgeCAmJiB4LmluZGV4T2YoXCIlXCIpID49IDAgJiYgKHggPSBwYXJzZUZsb2F0KHgucmVwbGFjZShcIiVcIiwgXCJcIikpIC8gMTAwICogciksIGUudmlydHVhbFNpemUgPSAteCwgbiA/IGMuY3NzKHsgbWFyZ2luTGVmdDogXCJcIiwgbWFyZ2luQm90dG9tOiBcIlwiLCBtYXJnaW5Ub3A6IFwiXCIgfSkgOiBjLmNzcyh7IG1hcmdpblJpZ2h0OiBcIlwiLCBtYXJnaW5Cb3R0b206IFwiXCIsIG1hcmdpblRvcDogXCJcIiB9KSwgYS5jZW50ZXJlZFNsaWRlcyAmJiBhLmNzc01vZGUgJiYgKHYoZS53cmFwcGVyRWwsIFwiLS1zd2lwZXItY2VudGVyZWQtb2Zmc2V0LWJlZm9yZVwiLCBcIlwiKSwgdihlLndyYXBwZXJFbCwgXCItLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYWZ0ZXJcIiwgXCJcIikpOyBjb25zdCBUID0gYS5ncmlkICYmIGEuZ3JpZC5yb3dzID4gMSAmJiBlLmdyaWQ7IGxldCAkO1xyXG4gICAgICAgICAgICAgICAgICAgIFQgJiYgZS5ncmlkLmluaXRTbGlkZXMocCk7IGNvbnN0IFMgPSBcImF1dG9cIiA9PT0gYS5zbGlkZXNQZXJWaWV3ICYmIGEuYnJlYWtwb2ludHMgJiYgT2JqZWN0LmtleXMoYS5icmVha3BvaW50cykuZmlsdGVyKChlID0+IHZvaWQgMCAhPT0gYS5icmVha3BvaW50c1tlXS5zbGlkZXNQZXJWaWV3KSkubGVuZ3RoID4gMDsgZm9yIChsZXQgaSA9IDA7IGkgPCBwOyBpICs9IDEpIHsgJCA9IDA7IGNvbnN0IG4gPSBjLmVxKGkpOyBpZiAoVCAmJiBlLmdyaWQudXBkYXRlU2xpZGUoaSwgbiwgcCwgdCksIFwibm9uZVwiICE9PSBuLmNzcyhcImRpc3BsYXlcIikpIHsgaWYgKFwiYXV0b1wiID09PSBhLnNsaWRlc1BlclZpZXcpIHsgUyAmJiAoY1tpXS5zdHlsZVt0KFwid2lkdGhcIildID0gXCJcIik7IGNvbnN0IHIgPSBnZXRDb21wdXRlZFN0eWxlKG5bMF0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gblswXS5zdHlsZS50cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBuWzBdLnN0eWxlLndlYmtpdFRyYW5zZm9ybTsgaWYgKGwgJiYgKG5bMF0uc3R5bGUudHJhbnNmb3JtID0gXCJub25lXCIpLCBvICYmIChuWzBdLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IFwibm9uZVwiKSwgYS5yb3VuZExlbmd0aHMpICQgPSBlLmlzSG9yaXpvbnRhbCgpID8gbi5vdXRlcldpZHRoKCEwKSA6IG4ub3V0ZXJIZWlnaHQoITApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyBjb25zdCBlID0gcyhyLCBcIndpZHRoXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHMociwgXCJwYWRkaW5nLWxlZnRcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gcyhyLCBcInBhZGRpbmctcmlnaHRcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gcyhyLCBcIm1hcmdpbi1sZWZ0XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHMociwgXCJtYXJnaW4tcmlnaHRcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gci5nZXRQcm9wZXJ0eVZhbHVlKFwiYm94LXNpemluZ1wiKTsgaWYgKG8gJiYgXCJib3JkZXItYm94XCIgPT09IG8pICQgPSBlICsgaSArIGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyBjb25zdCB7IGNsaWVudFdpZHRoOiBzLCBvZmZzZXRXaWR0aDogciB9ID0gblswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQgPSBlICsgdCArIGEgKyBpICsgbCArIChyIC0gcykgfSB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCAmJiAoblswXS5zdHlsZS50cmFuc2Zvcm0gPSBsKSwgbyAmJiAoblswXS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBvKSwgYS5yb3VuZExlbmd0aHMgJiYgKCQgPSBNYXRoLmZsb29yKCQpKSB9IGVsc2UgJCA9IChyIC0gKGEuc2xpZGVzUGVyVmlldyAtIDEpICogeCkgLyBhLnNsaWRlc1BlclZpZXcsIGEucm91bmRMZW5ndGhzICYmICgkID0gTWF0aC5mbG9vcigkKSksIGNbaV0gJiYgKGNbaV0uc3R5bGVbdChcIndpZHRoXCIpXSA9IGAkeyR9cHhgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbaV0gJiYgKGNbaV0uc3dpcGVyU2xpZGVTaXplID0gJCksIG0ucHVzaCgkKSwgYS5jZW50ZXJlZFNsaWRlcyA/ICh5ID0geSArICQgLyAyICsgRSAvIDIgKyB4LCAwID09PSBFICYmIDAgIT09IGkgJiYgKHkgPSB5IC0gciAvIDIgLSB4KSwgMCA9PT0gaSAmJiAoeSA9IHkgLSByIC8gMiAtIHgpLCBNYXRoLmFicyh5KSA8IC4wMDEgJiYgKHkgPSAwKSwgYS5yb3VuZExlbmd0aHMgJiYgKHkgPSBNYXRoLmZsb29yKHkpKSwgQyAlIGEuc2xpZGVzUGVyR3JvdXAgPT0gMCAmJiB1LnB1c2goeSksIGgucHVzaCh5KSkgOiAoYS5yb3VuZExlbmd0aHMgJiYgKHkgPSBNYXRoLmZsb29yKHkpKSwgKEMgLSBNYXRoLm1pbihlLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIEMpKSAlIGUucGFyYW1zLnNsaWRlc1Blckdyb3VwID09IDAgJiYgdS5wdXNoKHkpLCBoLnB1c2goeSksIHkgPSB5ICsgJCArIHgpLCBlLnZpcnR1YWxTaXplICs9ICQgKyB4LCBFID0gJCwgQyArPSAxIH0gfSBpZiAoZS52aXJ0dWFsU2l6ZSA9IE1hdGgubWF4KGUudmlydHVhbFNpemUsIHIpICsgZywgbiAmJiBsICYmIChcInNsaWRlXCIgPT09IGEuZWZmZWN0IHx8IFwiY292ZXJmbG93XCIgPT09IGEuZWZmZWN0KSAmJiBpLmNzcyh7IHdpZHRoOiBgJHtlLnZpcnR1YWxTaXplK2Euc3BhY2VCZXR3ZWVufXB4YCB9KSwgYS5zZXRXcmFwcGVyU2l6ZSAmJiBpLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdChcIndpZHRoXCIpXTogYCR7ZS52aXJ0dWFsU2l6ZSthLnNwYWNlQmV0d2Vlbn1weGAgfSksIFQgJiYgZS5ncmlkLnVwZGF0ZVdyYXBwZXJTaXplKCQsIHUsIHQpLCAhYS5jZW50ZXJlZFNsaWRlcykgeyBjb25zdCB0ID0gW107IGZvciAobGV0IHMgPSAwOyBzIDwgdS5sZW5ndGg7IHMgKz0gMSkgeyBsZXQgaSA9IHVbc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnJvdW5kTGVuZ3RocyAmJiAoaSA9IE1hdGguZmxvb3IoaSkpLCB1W3NdIDw9IGUudmlydHVhbFNpemUgLSByICYmIHQucHVzaChpKSB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB0LCBNYXRoLmZsb29yKGUudmlydHVhbFNpemUgLSByKSAtIE1hdGguZmxvb3IodVt1Lmxlbmd0aCAtIDFdKSA+IDEgJiYgdS5wdXNoKGUudmlydHVhbFNpemUgLSByKSB9IGlmICgwID09PSB1Lmxlbmd0aCAmJiAodSA9IFswXSksIDAgIT09IGEuc3BhY2VCZXR3ZWVuKSB7IGNvbnN0IHMgPSBlLmlzSG9yaXpvbnRhbCgpICYmIG4gPyBcIm1hcmdpbkxlZnRcIiA6IHQoXCJtYXJnaW5SaWdodFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5maWx0ZXIoKChlLCB0KSA9PiAhYS5jc3NNb2RlIHx8IHQgIT09IGMubGVuZ3RoIC0gMSkpLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc106IGAke3h9cHhgIH0pIH0gaWYgKGEuY2VudGVyZWRTbGlkZXMgJiYgYS5jZW50ZXJlZFNsaWRlc0JvdW5kcykgeyBsZXQgZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uZm9yRWFjaCgodCA9PiB7IGUgKz0gdCArIChhLnNwYWNlQmV0d2VlbiA/IGEuc3BhY2VCZXR3ZWVuIDogMCkgfSkpLCBlIC09IGEuc3BhY2VCZXR3ZWVuOyBjb25zdCB0ID0gZSAtIHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB1Lm1hcCgoZSA9PiBlIDwgMCA/IC1mIDogZSA+IHQgPyB0ICsgZyA6IGUpKSB9IGlmIChhLmNlbnRlckluc3VmZmljaWVudFNsaWRlcykgeyBsZXQgZSA9IDA7IGlmIChtLmZvckVhY2goKHQgPT4geyBlICs9IHQgKyAoYS5zcGFjZUJldHdlZW4gPyBhLnNwYWNlQmV0d2VlbiA6IDApIH0pKSwgZSAtPSBhLnNwYWNlQmV0d2VlbiwgZSA8IHIpIHsgY29uc3QgdCA9IChyIC0gZSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdS5mb3JFYWNoKCgoZSwgcykgPT4geyB1W3NdID0gZSAtIHQgfSkpLCBoLmZvckVhY2goKChlLCBzKSA9PiB7IGhbc10gPSBlICsgdCB9KSkgfSB9IGlmIChPYmplY3QuYXNzaWduKGUsIHsgc2xpZGVzOiBjLCBzbmFwR3JpZDogdSwgc2xpZGVzR3JpZDogaCwgc2xpZGVzU2l6ZXNHcmlkOiBtIH0pLCBhLmNlbnRlcmVkU2xpZGVzICYmIGEuY3NzTW9kZSAmJiAhYS5jZW50ZXJlZFNsaWRlc0JvdW5kcykgeyB2KGUud3JhcHBlckVsLCBcIi0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1iZWZvcmVcIiwgLXVbMF0gKyBcInB4XCIpLCB2KGUud3JhcHBlckVsLCBcIi0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlclwiLCBlLnNpemUgLyAyIC0gbVttLmxlbmd0aCAtIDFdIC8gMiArIFwicHhcIik7IGNvbnN0IHQgPSAtZS5zbmFwR3JpZFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSAtZS5zbGlkZXNHcmlkWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNuYXBHcmlkID0gZS5zbmFwR3JpZC5tYXAoKGUgPT4gZSArIHQpKSwgZS5zbGlkZXNHcmlkID0gZS5zbGlkZXNHcmlkLm1hcCgoZSA9PiBlICsgcykpIH0gaWYgKHAgIT09IGQgJiYgZS5lbWl0KFwic2xpZGVzTGVuZ3RoQ2hhbmdlXCIpLCB1Lmxlbmd0aCAhPT0gdyAmJiAoZS5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBlLmNoZWNrT3ZlcmZsb3coKSwgZS5lbWl0KFwic25hcEdyaWRMZW5ndGhDaGFuZ2VcIikpLCBoLmxlbmd0aCAhPT0gYiAmJiBlLmVtaXQoXCJzbGlkZXNHcmlkTGVuZ3RoQ2hhbmdlXCIpLCBhLndhdGNoU2xpZGVzUHJvZ3Jlc3MgJiYgZS51cGRhdGVTbGlkZXNPZmZzZXQoKSwgIShvIHx8IGEuY3NzTW9kZSB8fCBcInNsaWRlXCIgIT09IGEuZWZmZWN0ICYmIFwiZmFkZVwiICE9PSBhLmVmZmVjdCkpIHsgY29uc3QgdCA9IGAke2EuY29udGFpbmVyTW9kaWZpZXJDbGFzc31iYWNrZmFjZS1oaWRkZW5gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IGUuJGVsLmhhc0NsYXNzKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwIDw9IGEubWF4QmFja2ZhY2VIaWRkZW5TbGlkZXMgPyBzIHx8IGUuJGVsLmFkZENsYXNzKHQpIDogcyAmJiBlLiRlbC5yZW1vdmVDbGFzcyh0KSB9IH0sIHVwZGF0ZUF1dG9IZWlnaHQ6IGZ1bmN0aW9uKGUpIHsgY29uc3QgdCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHQudmlydHVhbCAmJiB0LnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7IGxldCBpLCByID0gMDsgXCJudW1iZXJcIiA9PSB0eXBlb2YgZSA/IHQuc2V0VHJhbnNpdGlvbihlKSA6ICEwID09PSBlICYmIHQuc2V0VHJhbnNpdGlvbih0LnBhcmFtcy5zcGVlZCk7IGNvbnN0IG4gPSBlID0+IGEgPyB0LnNsaWRlcy5maWx0ZXIoKHQgPT4gcGFyc2VJbnQodC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSwgMTApID09PSBlKSlbMF0gOiB0LnNsaWRlcy5lcShlKVswXTsgaWYgKFwiYXV0b1wiICE9PSB0LnBhcmFtcy5zbGlkZXNQZXJWaWV3ICYmIHQucGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5wYXJhbXMuY2VudGVyZWRTbGlkZXMpKHQudmlzaWJsZVNsaWRlcyB8fCBkKFtdKSkuZWFjaCgoZSA9PiB7IHMucHVzaChlKSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBNYXRoLmNlaWwodC5wYXJhbXMuc2xpZGVzUGVyVmlldyk7IGkgKz0gMSkgeyBjb25zdCBlID0gdC5hY3RpdmVJbmRleCArIGk7IGlmIChlID4gdC5zbGlkZXMubGVuZ3RoICYmICFhKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnB1c2gobihlKSkgfSBlbHNlIHMucHVzaChuKHQuYWN0aXZlSW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gc1tpXSkgeyBjb25zdCBlID0gc1tpXS5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gZSA+IHIgPyBlIDogciB9KHIgfHwgMCA9PT0gcikgJiYgdC4kd3JhcHBlckVsLmNzcyhcImhlaWdodFwiLCBgJHtyfXB4YCkgfSwgdXBkYXRlU2xpZGVzT2Zmc2V0OiBmdW5jdGlvbigpIHsgY29uc3QgZSA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBlLnNsaWRlczsgZm9yIChsZXQgcyA9IDA7IHMgPCB0Lmxlbmd0aDsgcyArPSAxKSB0W3NdLnN3aXBlclNsaWRlT2Zmc2V0ID0gZS5pc0hvcml6b250YWwoKSA/IHRbc10ub2Zmc2V0TGVmdCA6IHRbc10ub2Zmc2V0VG9wIH0sIHVwZGF0ZVNsaWRlc1Byb2dyZXNzOiBmdW5jdGlvbihlKSB7IHZvaWQgMCA9PT0gZSAmJiAoZSA9IHRoaXMgJiYgdGhpcy50cmFuc2xhdGUgfHwgMCk7IGNvbnN0IHQgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gdC5wYXJhbXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgc2xpZGVzOiBhLCBydGxUcmFuc2xhdGU6IGksIHNuYXBHcmlkOiByIH0gPSB0OyBpZiAoMCA9PT0gYS5sZW5ndGgpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGFbMF0uc3dpcGVyU2xpZGVPZmZzZXQgJiYgdC51cGRhdGVTbGlkZXNPZmZzZXQoKTsgbGV0IG4gPSAtZTtcclxuICAgICAgICAgICAgICAgICAgICBpICYmIChuID0gZSksIGEucmVtb3ZlQ2xhc3Mocy5zbGlkZVZpc2libGVDbGFzcyksIHQudmlzaWJsZVNsaWRlc0luZGV4ZXMgPSBbXSwgdC52aXNpYmxlU2xpZGVzID0gW107IGZvciAobGV0IGUgPSAwOyBlIDwgYS5sZW5ndGg7IGUgKz0gMSkgeyBjb25zdCBsID0gYVtlXTsgbGV0IG8gPSBsLnN3aXBlclNsaWRlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzLmNzc01vZGUgJiYgcy5jZW50ZXJlZFNsaWRlcyAmJiAobyAtPSBhWzBdLnN3aXBlclNsaWRlT2Zmc2V0KTsgY29uc3QgZCA9IChuICsgKHMuY2VudGVyZWRTbGlkZXMgPyB0Lm1pblRyYW5zbGF0ZSgpIDogMCkgLSBvKSAvIChsLnN3aXBlclNsaWRlU2l6ZSArIHMuc3BhY2VCZXR3ZWVuKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAobiAtIHJbMF0gKyAocy5jZW50ZXJlZFNsaWRlcyA/IHQubWluVHJhbnNsYXRlKCkgOiAwKSAtIG8pIC8gKGwuc3dpcGVyU2xpZGVTaXplICsgcy5zcGFjZUJldHdlZW4pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IC0obiAtIG8pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHAgKyB0LnNsaWRlc1NpemVzR3JpZFtlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHAgPj0gMCAmJiBwIDwgdC5zaXplIC0gMSB8fCB1ID4gMSAmJiB1IDw9IHQuc2l6ZSB8fCBwIDw9IDAgJiYgdSA+PSB0LnNpemUpICYmICh0LnZpc2libGVTbGlkZXMucHVzaChsKSwgdC52aXNpYmxlU2xpZGVzSW5kZXhlcy5wdXNoKGUpLCBhLmVxKGUpLmFkZENsYXNzKHMuc2xpZGVWaXNpYmxlQ2xhc3MpKSwgbC5wcm9ncmVzcyA9IGkgPyAtZCA6IGQsIGwub3JpZ2luYWxQcm9ncmVzcyA9IGkgPyAtYyA6IGMgfVxyXG4gICAgICAgICAgICAgICAgICAgIHQudmlzaWJsZVNsaWRlcyA9IGQodC52aXNpYmxlU2xpZGVzKSB9LCB1cGRhdGVQcm9ncmVzczogZnVuY3Rpb24oZSkgeyBjb25zdCB0ID0gdGhpczsgaWYgKHZvaWQgMCA9PT0gZSkgeyBjb25zdCBzID0gdC5ydGxUcmFuc2xhdGUgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0ICYmIHQudHJhbnNsYXRlICYmIHQudHJhbnNsYXRlICogcyB8fCAwIH0gY29uc3QgcyA9IHQucGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gdC5tYXhUcmFuc2xhdGUoKSAtIHQubWluVHJhbnNsYXRlKCk7IGxldCB7IHByb2dyZXNzOiBpLCBpc0JlZ2lubmluZzogciwgaXNFbmQ6IG4gfSA9IHQ7IGNvbnN0IGwgPSByLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gbjtcclxuICAgICAgICAgICAgICAgICAgICAwID09PSBhID8gKGkgPSAwLCByID0gITAsIG4gPSAhMCkgOiAoaSA9IChlIC0gdC5taW5UcmFuc2xhdGUoKSkgLyBhLCByID0gaSA8PSAwLCBuID0gaSA+PSAxKSwgT2JqZWN0LmFzc2lnbih0LCB7IHByb2dyZXNzOiBpLCBpc0JlZ2lubmluZzogciwgaXNFbmQ6IG4gfSksIChzLndhdGNoU2xpZGVzUHJvZ3Jlc3MgfHwgcy5jZW50ZXJlZFNsaWRlcyAmJiBzLmF1dG9IZWlnaHQpICYmIHQudXBkYXRlU2xpZGVzUHJvZ3Jlc3MoZSksIHIgJiYgIWwgJiYgdC5lbWl0KFwicmVhY2hCZWdpbm5pbmcgdG9FZGdlXCIpLCBuICYmICFvICYmIHQuZW1pdChcInJlYWNoRW5kIHRvRWRnZVwiKSwgKGwgJiYgIXIgfHwgbyAmJiAhbikgJiYgdC5lbWl0KFwiZnJvbUVkZ2VcIiksIHQuZW1pdChcInByb2dyZXNzXCIsIGkpIH0sIHVwZGF0ZVNsaWRlc0NsYXNzZXM6IGZ1bmN0aW9uKCkgeyBjb25zdCBlID0gdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBzbGlkZXM6IHQsIHBhcmFtczogcywgJHdyYXBwZXJFbDogYSwgYWN0aXZlSW5kZXg6IGksIHJlYWxJbmRleDogciB9ID0gZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGUudmlydHVhbCAmJiBzLnZpcnR1YWwuZW5hYmxlZDsgbGV0IGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5yZW1vdmVDbGFzcyhgJHtzLnNsaWRlQWN0aXZlQ2xhc3N9ICR7cy5zbGlkZU5leHRDbGFzc30gJHtzLnNsaWRlUHJldkNsYXNzfSAke3Muc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzc30gJHtzLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzfSAke3Muc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3N9YCksIGwgPSBuID8gZS4kd3JhcHBlckVsLmZpbmQoYC4ke3Muc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2l9XCJdYCkgOiB0LmVxKGkpLCBsLmFkZENsYXNzKHMuc2xpZGVBY3RpdmVDbGFzcyksIHMubG9vcCAmJiAobC5oYXNDbGFzcyhzLnNsaWRlRHVwbGljYXRlQ2xhc3MpID8gYS5jaGlsZHJlbihgLiR7cy5zbGlkZUNsYXNzfTpub3QoLiR7cy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3J9XCJdYCkuYWRkQ2xhc3Mocy5zbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzKSA6IGEuY2hpbGRyZW4oYC4ke3Muc2xpZGVDbGFzc30uJHtzLnNsaWRlRHVwbGljYXRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtyfVwiXWApLmFkZENsYXNzKHMuc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzcykpOyBsZXQgbyA9IGwubmV4dEFsbChgLiR7cy5zbGlkZUNsYXNzfWApLmVxKDApLmFkZENsYXNzKHMuc2xpZGVOZXh0Q2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHMubG9vcCAmJiAwID09PSBvLmxlbmd0aCAmJiAobyA9IHQuZXEoMCksIG8uYWRkQ2xhc3Mocy5zbGlkZU5leHRDbGFzcykpOyBsZXQgZCA9IGwucHJldkFsbChgLiR7cy5zbGlkZUNsYXNzfWApLmVxKDApLmFkZENsYXNzKHMuc2xpZGVQcmV2Q2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHMubG9vcCAmJiAwID09PSBkLmxlbmd0aCAmJiAoZCA9IHQuZXEoLTEpLCBkLmFkZENsYXNzKHMuc2xpZGVQcmV2Q2xhc3MpKSwgcy5sb29wICYmIChvLmhhc0NsYXNzKHMuc2xpZGVEdXBsaWNhdGVDbGFzcykgPyBhLmNoaWxkcmVuKGAuJHtzLnNsaWRlQ2xhc3N9Om5vdCguJHtzLnNsaWRlRHVwbGljYXRlQ2xhc3N9KVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7by5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIil9XCJdYCkuYWRkQ2xhc3Mocy5zbGlkZUR1cGxpY2F0ZU5leHRDbGFzcykgOiBhLmNoaWxkcmVuKGAuJHtzLnNsaWRlQ2xhc3N9LiR7cy5zbGlkZUR1cGxpY2F0ZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7by5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIil9XCJdYCkuYWRkQ2xhc3Mocy5zbGlkZUR1cGxpY2F0ZU5leHRDbGFzcyksIGQuaGFzQ2xhc3Mocy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSA/IGEuY2hpbGRyZW4oYC4ke3Muc2xpZGVDbGFzc306bm90KC4ke3Muc2xpZGVEdXBsaWNhdGVDbGFzc30pW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtkLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKX1cIl1gKS5hZGRDbGFzcyhzLnNsaWRlRHVwbGljYXRlUHJldkNsYXNzKSA6IGEuY2hpbGRyZW4oYC4ke3Muc2xpZGVDbGFzc30uJHtzLnNsaWRlRHVwbGljYXRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtkLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKX1cIl1gKS5hZGRDbGFzcyhzLnNsaWRlRHVwbGljYXRlUHJldkNsYXNzKSksIGUuZW1pdFNsaWRlc0NsYXNzZXMoKSB9LCB1cGRhdGVBY3RpdmVJbmRleDogZnVuY3Rpb24oZSkgeyBjb25zdCB0ID0gdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHQucnRsVHJhbnNsYXRlID8gdC50cmFuc2xhdGUgOiAtdC50cmFuc2xhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgc2xpZGVzR3JpZDogYSwgc25hcEdyaWQ6IGksIHBhcmFtczogciwgYWN0aXZlSW5kZXg6IG4sIHJlYWxJbmRleDogbCwgc25hcEluZGV4OiBvIH0gPSB0OyBsZXQgZCwgYyA9IGU7IGlmICh2b2lkIDAgPT09IGMpIHsgZm9yIChsZXQgZSA9IDA7IGUgPCBhLmxlbmd0aDsgZSArPSAxKSB2b2lkIDAgIT09IGFbZSArIDFdID8gcyA+PSBhW2VdICYmIHMgPCBhW2UgKyAxXSAtIChhW2UgKyAxXSAtIGFbZV0pIC8gMiA/IGMgPSBlIDogcyA+PSBhW2VdICYmIHMgPCBhW2UgKyAxXSAmJiAoYyA9IGUgKyAxKSA6IHMgPj0gYVtlXSAmJiAoYyA9IGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByLm5vcm1hbGl6ZVNsaWRlSW5kZXggJiYgKGMgPCAwIHx8IHZvaWQgMCA9PT0gYykgJiYgKGMgPSAwKSB9IGlmIChpLmluZGV4T2YocykgPj0gMCkgZCA9IGkuaW5kZXhPZihzKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgY29uc3QgZSA9IE1hdGgubWluKHIuc2xpZGVzUGVyR3JvdXBTa2lwLCBjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGUgKyBNYXRoLmZsb29yKChjIC0gZSkgLyByLnNsaWRlc1Blckdyb3VwKSB9IGlmIChkID49IGkubGVuZ3RoICYmIChkID0gaS5sZW5ndGggLSAxKSwgYyA9PT0gbikgcmV0dXJuIHZvaWQoZCAhPT0gbyAmJiAodC5zbmFwSW5kZXggPSBkLCB0LmVtaXQoXCJzbmFwSW5kZXhDaGFuZ2VcIikpKTsgY29uc3QgcCA9IHBhcnNlSW50KHQuc2xpZGVzLmVxKGMpLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSB8fCBjLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0LCB7IHNuYXBJbmRleDogZCwgcmVhbEluZGV4OiBwLCBwcmV2aW91c0luZGV4OiBuLCBhY3RpdmVJbmRleDogYyB9KSwgdC5lbWl0KFwiYWN0aXZlSW5kZXhDaGFuZ2VcIiksIHQuZW1pdChcInNuYXBJbmRleENoYW5nZVwiKSwgbCAhPT0gcCAmJiB0LmVtaXQoXCJyZWFsSW5kZXhDaGFuZ2VcIiksICh0LmluaXRpYWxpemVkIHx8IHQucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCkgJiYgdC5lbWl0KFwic2xpZGVDaGFuZ2VcIikgfSwgdXBkYXRlQ2xpY2tlZFNsaWRlOiBmdW5jdGlvbihlKSB7IGNvbnN0IHQgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gdC5wYXJhbXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBkKGUpLmNsb3Nlc3QoYC4ke3Muc2xpZGVDbGFzc31gKVswXTsgbGV0IGksIHIgPSAhMTsgaWYgKGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgdC5zbGlkZXMubGVuZ3RoOyBlICs9IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5zbGlkZXNbZV0gPT09IGEpIHsgciA9ICEwLCBpID0gZTsgYnJlYWsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYSB8fCAhcikgcmV0dXJuIHQuY2xpY2tlZFNsaWRlID0gdm9pZCAwLCB2b2lkKHQuY2xpY2tlZEluZGV4ID0gdm9pZCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB0LmNsaWNrZWRTbGlkZSA9IGEsIHQudmlydHVhbCAmJiB0LnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgPyB0LmNsaWNrZWRJbmRleCA9IHBhcnNlSW50KGQoYSkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpLCAxMCkgOiB0LmNsaWNrZWRJbmRleCA9IGksIHMuc2xpZGVUb0NsaWNrZWRTbGlkZSAmJiB2b2lkIDAgIT09IHQuY2xpY2tlZEluZGV4ICYmIHQuY2xpY2tlZEluZGV4ICE9PSB0LmFjdGl2ZUluZGV4ICYmIHQuc2xpZGVUb0NsaWNrZWRTbGlkZSgpIH0gfTsgdmFyIE0gPSB7IGdldFRyYW5zbGF0ZTogZnVuY3Rpb24oZSkgeyB2b2lkIDAgPT09IGUgJiYgKGUgPSB0aGlzLmlzSG9yaXpvbnRhbCgpID8gXCJ4XCIgOiBcInlcIik7IGNvbnN0IHsgcGFyYW1zOiB0LCBydGxUcmFuc2xhdGU6IHMsIHRyYW5zbGF0ZTogYSwgJHdyYXBwZXJFbDogaSB9ID0gdGhpczsgaWYgKHQudmlydHVhbFRyYW5zbGF0ZSkgcmV0dXJuIHMgPyAtYSA6IGE7IGlmICh0LmNzc01vZGUpIHJldHVybiBhOyBsZXQgciA9IGgoaVswXSwgZSk7IHJldHVybiBzICYmIChyID0gLXIpLCByIHx8IDAgfSwgc2V0VHJhbnNsYXRlOiBmdW5jdGlvbihlLCB0KSB7IGNvbnN0IHMgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHJ0bFRyYW5zbGF0ZTogYSwgcGFyYW1zOiBpLCAkd3JhcHBlckVsOiByLCB3cmFwcGVyRWw6IG4sIHByb2dyZXNzOiBsIH0gPSBzOyBsZXQgbywgZCA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHMuaXNIb3Jpem9udGFsKCkgPyBkID0gYSA/IC1lIDogZSA6IGMgPSBlLCBpLnJvdW5kTGVuZ3RocyAmJiAoZCA9IE1hdGguZmxvb3IoZCksIGMgPSBNYXRoLmZsb29yKGMpKSwgaS5jc3NNb2RlID8gbltzLmlzSG9yaXpvbnRhbCgpID8gXCJzY3JvbGxMZWZ0XCIgOiBcInNjcm9sbFRvcFwiXSA9IHMuaXNIb3Jpem9udGFsKCkgPyAtZCA6IC1jIDogaS52aXJ0dWFsVHJhbnNsYXRlIHx8IHIudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2R9cHgsICR7Y31weCwgMHB4KWApLCBzLnByZXZpb3VzVHJhbnNsYXRlID0gcy50cmFuc2xhdGUsIHMudHJhbnNsYXRlID0gcy5pc0hvcml6b250YWwoKSA/IGQgOiBjOyBjb25zdCBwID0gcy5tYXhUcmFuc2xhdGUoKSAtIHMubWluVHJhbnNsYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbyA9IDAgPT09IHAgPyAwIDogKGUgLSBzLm1pblRyYW5zbGF0ZSgpKSAvIHAsIG8gIT09IGwgJiYgcy51cGRhdGVQcm9ncmVzcyhlKSwgcy5lbWl0KFwic2V0VHJhbnNsYXRlXCIsIHMudHJhbnNsYXRlLCB0KSB9LCBtaW5UcmFuc2xhdGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLXRoaXMuc25hcEdyaWRbMF0gfSwgbWF4VHJhbnNsYXRlOiBmdW5jdGlvbigpIHsgcmV0dXJuIC10aGlzLnNuYXBHcmlkW3RoaXMuc25hcEdyaWQubGVuZ3RoIC0gMV0gfSwgdHJhbnNsYXRlVG86IGZ1bmN0aW9uKGUsIHQsIHMsIGEsIGkpIHsgdm9pZCAwID09PSBlICYmIChlID0gMCksIHZvaWQgMCA9PT0gdCAmJiAodCA9IHRoaXMucGFyYW1zLnNwZWVkKSwgdm9pZCAwID09PSBzICYmIChzID0gITApLCB2b2lkIDAgPT09IGEgJiYgKGEgPSAhMCk7IGNvbnN0IHIgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHBhcmFtczogbiwgd3JhcHBlckVsOiBsIH0gPSByOyBpZiAoci5hbmltYXRpbmcgJiYgbi5wcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb24pIHJldHVybiAhMTsgY29uc3QgbyA9IHIubWluVHJhbnNsYXRlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSByLm1heFRyYW5zbGF0ZSgpOyBsZXQgYzsgaWYgKGMgPSBhICYmIGUgPiBvID8gbyA6IGEgJiYgZSA8IGQgPyBkIDogZSwgci51cGRhdGVQcm9ncmVzcyhjKSwgbi5jc3NNb2RlKSB7IGNvbnN0IGUgPSByLmlzSG9yaXpvbnRhbCgpOyBpZiAoMCA9PT0gdCkgbFtlID8gXCJzY3JvbGxMZWZ0XCIgOiBcInNjcm9sbFRvcFwiXSA9IC1jO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgaWYgKCFyLnN1cHBvcnQuc21vb3RoU2Nyb2xsKSByZXR1cm4gdyh7IHN3aXBlcjogciwgdGFyZ2V0UG9zaXRpb246IC1jLCBzaWRlOiBlID8gXCJsZWZ0XCIgOiBcInRvcFwiIH0pLCAhMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwuc2Nyb2xsVG8oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtlID8gXCJsZWZ0XCIgOiBcInRvcFwiXTogLWMsIGJlaGF2aW9yOiBcInNtb290aFwiIH0pIH0gcmV0dXJuICEwIH0gcmV0dXJuIDAgPT09IHQgPyAoci5zZXRUcmFuc2l0aW9uKDApLCByLnNldFRyYW5zbGF0ZShjKSwgcyAmJiAoci5lbWl0KFwiYmVmb3JlVHJhbnNpdGlvblN0YXJ0XCIsIHQsIGkpLCByLmVtaXQoXCJ0cmFuc2l0aW9uRW5kXCIpKSkgOiAoci5zZXRUcmFuc2l0aW9uKHQpLCByLnNldFRyYW5zbGF0ZShjKSwgcyAmJiAoci5lbWl0KFwiYmVmb3JlVHJhbnNpdGlvblN0YXJ0XCIsIHQsIGkpLCByLmVtaXQoXCJ0cmFuc2l0aW9uU3RhcnRcIikpLCByLmFuaW1hdGluZyB8fCAoci5hbmltYXRpbmcgPSAhMCwgci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgfHwgKHIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oZSkgeyByICYmICFyLmRlc3Ryb3llZCAmJiBlLnRhcmdldCA9PT0gdGhpcyAmJiAoci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIHIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSwgci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsIHIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSwgci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBudWxsLCBkZWxldGUgci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQsIHMgJiYgci5lbWl0KFwidHJhbnNpdGlvbkVuZFwiKSkgfSksIHIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCByLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCksIHIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKFwid2Via2l0VHJhbnNpdGlvbkVuZFwiLCByLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCkpKSwgITAgfSB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gUChlKSB7IGxldCB7IHN3aXBlcjogdCwgcnVuQ2FsbGJhY2tzOiBzLCBkaXJlY3Rpb246IGEsIHN0ZXA6IGkgfSA9IGU7IGNvbnN0IHsgYWN0aXZlSW5kZXg6IHIsIHByZXZpb3VzSW5kZXg6IG4gfSA9IHQ7IGxldCBsID0gYTsgaWYgKGwgfHwgKGwgPSByID4gbiA/IFwibmV4dFwiIDogciA8IG4gPyBcInByZXZcIiA6IFwicmVzZXRcIiksIHQuZW1pdChgdHJhbnNpdGlvbiR7aX1gKSwgcyAmJiByICE9PSBuKSB7IGlmIChcInJlc2V0XCIgPT09IGwpIHJldHVybiB2b2lkIHQuZW1pdChgc2xpZGVSZXNldFRyYW5zaXRpb24ke2l9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5lbWl0KGBzbGlkZUNoYW5nZVRyYW5zaXRpb24ke2l9YCksIFwibmV4dFwiID09PSBsID8gdC5lbWl0KGBzbGlkZU5leHRUcmFuc2l0aW9uJHtpfWApIDogdC5lbWl0KGBzbGlkZVByZXZUcmFuc2l0aW9uJHtpfWApIH0gfSB2YXIgayA9IHsgc2xpZGVUbzogZnVuY3Rpb24oZSwgdCwgcywgYSwgaSkgeyBpZiAodm9pZCAwID09PSBlICYmIChlID0gMCksIHZvaWQgMCA9PT0gdCAmJiAodCA9IHRoaXMucGFyYW1zLnNwZWVkKSwgdm9pZCAwID09PSBzICYmIChzID0gITApLCBcIm51bWJlclwiICE9IHR5cGVvZiBlICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIGUpIHRocm93IG5ldyBFcnJvcihgVGhlICdpbmRleCcgYXJndW1lbnQgY2Fubm90IGhhdmUgdHlwZSBvdGhlciB0aGFuICdudW1iZXInIG9yICdzdHJpbmcnLiBbJHt0eXBlb2YgZX1dIGdpdmVuLmApOyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkgeyBjb25zdCB0ID0gcGFyc2VJbnQoZSwgMTApOyBpZiAoIWlzRmluaXRlKHQpKSB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwYXNzZWQtaW4gJ2luZGV4JyAoc3RyaW5nKSBjb3VsZG4ndCBiZSBjb252ZXJ0ZWQgdG8gJ251bWJlcicuIFske2V9XSBnaXZlbi5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHQgfSBjb25zdCByID0gdGhpczsgbGV0IG4gPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPCAwICYmIChuID0gMCk7IGNvbnN0IHsgcGFyYW1zOiBsLCBzbmFwR3JpZDogbywgc2xpZGVzR3JpZDogZCwgcHJldmlvdXNJbmRleDogYywgYWN0aXZlSW5kZXg6IHAsIHJ0bFRyYW5zbGF0ZTogdSwgd3JhcHBlckVsOiBoLCBlbmFibGVkOiBtIH0gPSByOyBpZiAoci5hbmltYXRpbmcgJiYgbC5wcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb24gfHwgIW0gJiYgIWEgJiYgIWkpIHJldHVybiAhMTsgY29uc3QgZiA9IE1hdGgubWluKHIucGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCwgbik7IGxldCBnID0gZiArIE1hdGguZmxvb3IoKG4gLSBmKSAvIHIucGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICBnID49IG8ubGVuZ3RoICYmIChnID0gby5sZW5ndGggLSAxKSwgKHAgfHwgbC5pbml0aWFsU2xpZGUgfHwgMCkgPT09IChjIHx8IDApICYmIHMgJiYgci5lbWl0KFwiYmVmb3JlU2xpZGVDaGFuZ2VTdGFydFwiKTsgY29uc3QgdiA9IC1vW2ddOyBpZiAoci51cGRhdGVQcm9ncmVzcyh2KSwgbC5ub3JtYWxpemVTbGlkZUluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IGQubGVuZ3RoOyBlICs9IDEpIHsgY29uc3QgdCA9IC1NYXRoLmZsb29yKDEwMCAqIHYpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBNYXRoLmZsb29yKDEwMCAqIGRbZV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBNYXRoLmZsb29yKDEwMCAqIGRbZSArIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gZFtlICsgMV0gPyB0ID49IHMgJiYgdCA8IGEgLSAoYSAtIHMpIC8gMiA/IG4gPSBlIDogdCA+PSBzICYmIHQgPCBhICYmIChuID0gZSArIDEpIDogdCA+PSBzICYmIChuID0gZSkgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmluaXRpYWxpemVkICYmIG4gIT09IHApIHsgaWYgKCFyLmFsbG93U2xpZGVOZXh0ICYmIHYgPCByLnRyYW5zbGF0ZSAmJiB2IDwgci5taW5UcmFuc2xhdGUoKSkgcmV0dXJuICExOyBpZiAoIXIuYWxsb3dTbGlkZVByZXYgJiYgdiA+IHIudHJhbnNsYXRlICYmIHYgPiByLm1heFRyYW5zbGF0ZSgpICYmIChwIHx8IDApICE9PSBuKSByZXR1cm4gITEgfSBsZXQgYjsgaWYgKGIgPSBuID4gcCA/IFwibmV4dFwiIDogbiA8IHAgPyBcInByZXZcIiA6IFwicmVzZXRcIiwgdSAmJiAtdiA9PT0gci50cmFuc2xhdGUgfHwgIXUgJiYgdiA9PT0gci50cmFuc2xhdGUpIHJldHVybiByLnVwZGF0ZUFjdGl2ZUluZGV4KG4pLCBsLmF1dG9IZWlnaHQgJiYgci51cGRhdGVBdXRvSGVpZ2h0KCksIHIudXBkYXRlU2xpZGVzQ2xhc3NlcygpLCBcInNsaWRlXCIgIT09IGwuZWZmZWN0ICYmIHIuc2V0VHJhbnNsYXRlKHYpLCBcInJlc2V0XCIgIT09IGIgJiYgKHIudHJhbnNpdGlvblN0YXJ0KHMsIGIpLCByLnRyYW5zaXRpb25FbmQocywgYikpLCAhMTsgaWYgKGwuY3NzTW9kZSkgeyBjb25zdCBlID0gci5pc0hvcml6b250YWwoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB1ID8gdiA6IC12OyBpZiAoMCA9PT0gdCkgeyBjb25zdCB0ID0gci52aXJ0dWFsICYmIHIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgJiYgKHIud3JhcHBlckVsLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gXCJub25lXCIsIHIuX2ltbWVkaWF0ZVZpcnR1YWwgPSAhMCksIGhbZSA/IFwic2Nyb2xsTGVmdFwiIDogXCJzY3JvbGxUb3BcIl0gPSBzLCB0ICYmIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKCkgPT4geyByLndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9IFwiXCIsIHIuX3N3aXBlckltbWVkaWF0ZVZpcnR1YWwgPSAhMSB9KSkgfSBlbHNlIHsgaWYgKCFyLnN1cHBvcnQuc21vb3RoU2Nyb2xsKSByZXR1cm4gdyh7IHN3aXBlcjogciwgdGFyZ2V0UG9zaXRpb246IHMsIHNpZGU6IGUgPyBcImxlZnRcIiA6IFwidG9wXCIgfSksICEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaC5zY3JvbGxUbyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2UgPyBcImxlZnRcIiA6IFwidG9wXCJdOiBzLCBiZWhhdmlvcjogXCJzbW9vdGhcIiB9KSB9IHJldHVybiAhMCB9IHJldHVybiByLnNldFRyYW5zaXRpb24odCksIHIuc2V0VHJhbnNsYXRlKHYpLCByLnVwZGF0ZUFjdGl2ZUluZGV4KG4pLCByLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSwgci5lbWl0KFwiYmVmb3JlVHJhbnNpdGlvblN0YXJ0XCIsIHQsIGEpLCByLnRyYW5zaXRpb25TdGFydChzLCBiKSwgMCA9PT0gdCA/IHIudHJhbnNpdGlvbkVuZChzLCBiKSA6IHIuYW5pbWF0aW5nIHx8IChyLmFuaW1hdGluZyA9ICEwLCByLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kIHx8IChyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oZSkgeyByICYmICFyLmRlc3Ryb3llZCAmJiBlLnRhcmdldCA9PT0gdGhpcyAmJiAoci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIHIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpLCByLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmtpdFRyYW5zaXRpb25FbmRcIiwgci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCksIHIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBudWxsLCBkZWxldGUgci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCwgci50cmFuc2l0aW9uRW5kKHMsIGIpKSB9KSwgci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIHIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpLCByLiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcihcIndlYmtpdFRyYW5zaXRpb25FbmRcIiwgci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCkpLCAhMCB9LCBzbGlkZVRvTG9vcDogZnVuY3Rpb24oZSwgdCwgcywgYSkgeyBpZiAodm9pZCAwID09PSBlICYmIChlID0gMCksIHZvaWQgMCA9PT0gdCAmJiAodCA9IHRoaXMucGFyYW1zLnNwZWVkKSwgdm9pZCAwID09PSBzICYmIChzID0gITApLCBcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7IGNvbnN0IHQgPSBwYXJzZUludChlLCAxMCk7IGlmICghaXNGaW5pdGUodCkpIHRocm93IG5ldyBFcnJvcihgVGhlIHBhc3NlZC1pbiAnaW5kZXgnIChzdHJpbmcpIGNvdWxkbid0IGJlIGNvbnZlcnRlZCB0byAnbnVtYmVyJy4gWyR7ZX1dIGdpdmVuLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gdCB9IGNvbnN0IGkgPSB0aGlzOyBsZXQgciA9IGU7IHJldHVybiBpLnBhcmFtcy5sb29wICYmIChyICs9IGkubG9vcGVkU2xpZGVzKSwgaS5zbGlkZVRvKHIsIHQsIHMsIGEpIH0sIHNsaWRlTmV4dDogZnVuY3Rpb24oZSwgdCwgcykgeyB2b2lkIDAgPT09IGUgJiYgKGUgPSB0aGlzLnBhcmFtcy5zcGVlZCksIHZvaWQgMCA9PT0gdCAmJiAodCA9ICEwKTsgY29uc3QgYSA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYW5pbWF0aW5nOiBpLCBlbmFibGVkOiByLCBwYXJhbXM6IG4gfSA9IGE7IGlmICghcikgcmV0dXJuIGE7IGxldCBsID0gbi5zbGlkZXNQZXJHcm91cDsgXCJhdXRvXCIgPT09IG4uc2xpZGVzUGVyVmlldyAmJiAxID09PSBuLnNsaWRlc1Blckdyb3VwICYmIG4uc2xpZGVzUGVyR3JvdXBBdXRvICYmIChsID0gTWF0aC5tYXgoYS5zbGlkZXNQZXJWaWV3RHluYW1pYyhcImN1cnJlbnRcIiwgITApLCAxKSk7IGNvbnN0IG8gPSBhLmFjdGl2ZUluZGV4IDwgbi5zbGlkZXNQZXJHcm91cFNraXAgPyAxIDogbDsgaWYgKG4ubG9vcCkgeyBpZiAoaSAmJiBuLmxvb3BQcmV2ZW50c1NsaWRlKSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEubG9vcEZpeCgpLCBhLl9jbGllbnRMZWZ0ID0gYS4kd3JhcHBlckVsWzBdLmNsaWVudExlZnQgfSByZXR1cm4gbi5yZXdpbmQgJiYgYS5pc0VuZCA/IGEuc2xpZGVUbygwLCBlLCB0LCBzKSA6IGEuc2xpZGVUbyhhLmFjdGl2ZUluZGV4ICsgbywgZSwgdCwgcykgfSwgc2xpZGVQcmV2OiBmdW5jdGlvbihlLCB0LCBzKSB7IHZvaWQgMCA9PT0gZSAmJiAoZSA9IHRoaXMucGFyYW1zLnNwZWVkKSwgdm9pZCAwID09PSB0ICYmICh0ID0gITApOyBjb25zdCBhID0gdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwYXJhbXM6IGksIGFuaW1hdGluZzogciwgc25hcEdyaWQ6IG4sIHNsaWRlc0dyaWQ6IGwsIHJ0bFRyYW5zbGF0ZTogbywgZW5hYmxlZDogZCB9ID0gYTsgaWYgKCFkKSByZXR1cm4gYTsgaWYgKGkubG9vcCkgeyBpZiAociAmJiBpLmxvb3BQcmV2ZW50c1NsaWRlKSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEubG9vcEZpeCgpLCBhLl9jbGllbnRMZWZ0ID0gYS4kd3JhcHBlckVsWzBdLmNsaWVudExlZnQgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKGUpIHsgcmV0dXJuIGUgPCAwID8gLU1hdGguZmxvb3IoTWF0aC5hYnMoZSkpIDogTWF0aC5mbG9vcihlKSB9IGNvbnN0IHAgPSBjKG8gPyBhLnRyYW5zbGF0ZSA6IC1hLnRyYW5zbGF0ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBuLm1hcCgoZSA9PiBjKGUpKSk7IGxldCBoID0gblt1LmluZGV4T2YocCkgLSAxXTsgaWYgKHZvaWQgMCA9PT0gaCAmJiBpLmNzc01vZGUpIHsgbGV0IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uZm9yRWFjaCgoKHQsIHMpID0+IHsgcCA+PSB0ICYmIChlID0gcykgfSkpLCB2b2lkIDAgIT09IGUgJiYgKGggPSBuW2UgPiAwID8gZSAtIDEgOiBlXSkgfSBsZXQgbSA9IDA7IGlmICh2b2lkIDAgIT09IGggJiYgKG0gPSBsLmluZGV4T2YoaCksIG0gPCAwICYmIChtID0gYS5hY3RpdmVJbmRleCAtIDEpLCBcImF1dG9cIiA9PT0gaS5zbGlkZXNQZXJWaWV3ICYmIDEgPT09IGkuc2xpZGVzUGVyR3JvdXAgJiYgaS5zbGlkZXNQZXJHcm91cEF1dG8gJiYgKG0gPSBtIC0gYS5zbGlkZXNQZXJWaWV3RHluYW1pYyhcInByZXZpb3VzXCIsICEwKSArIDEsIG0gPSBNYXRoLm1heChtLCAwKSkpLCBpLnJld2luZCAmJiBhLmlzQmVnaW5uaW5nKSB7IGNvbnN0IGkgPSBhLnBhcmFtcy52aXJ0dWFsICYmIGEucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCAmJiBhLnZpcnR1YWwgPyBhLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCAtIDEgOiBhLnNsaWRlcy5sZW5ndGggLSAxOyByZXR1cm4gYS5zbGlkZVRvKGksIGUsIHQsIHMpIH0gcmV0dXJuIGEuc2xpZGVUbyhtLCBlLCB0LCBzKSB9LCBzbGlkZVJlc2V0OiBmdW5jdGlvbihlLCB0LCBzKSB7IHJldHVybiB2b2lkIDAgPT09IGUgJiYgKGUgPSB0aGlzLnBhcmFtcy5zcGVlZCksIHZvaWQgMCA9PT0gdCAmJiAodCA9ICEwKSwgdGhpcy5zbGlkZVRvKHRoaXMuYWN0aXZlSW5kZXgsIGUsIHQsIHMpIH0sIHNsaWRlVG9DbG9zZXN0OiBmdW5jdGlvbihlLCB0LCBzLCBhKSB7IHZvaWQgMCA9PT0gZSAmJiAoZSA9IHRoaXMucGFyYW1zLnNwZWVkKSwgdm9pZCAwID09PSB0ICYmICh0ID0gITApLCB2b2lkIDAgPT09IGEgJiYgKGEgPSAuNSk7IGNvbnN0IGkgPSB0aGlzOyBsZXQgciA9IGkuYWN0aXZlSW5kZXg7IGNvbnN0IG4gPSBNYXRoLm1pbihpLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIHIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gbiArIE1hdGguZmxvb3IoKHIgLSBuKSAvIGkucGFyYW1zLnNsaWRlc1Blckdyb3VwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IGkucnRsVHJhbnNsYXRlID8gaS50cmFuc2xhdGUgOiAtaS50cmFuc2xhdGU7IGlmIChvID49IGkuc25hcEdyaWRbbF0pIHsgY29uc3QgZSA9IGkuc25hcEdyaWRbbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gLSBlID4gKGkuc25hcEdyaWRbbCArIDFdIC0gZSkgKiBhICYmIChyICs9IGkucGFyYW1zLnNsaWRlc1Blckdyb3VwKSB9IGVsc2UgeyBjb25zdCBlID0gaS5zbmFwR3JpZFtsIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gLSBlIDw9IChpLnNuYXBHcmlkW2xdIC0gZSkgKiBhICYmIChyIC09IGkucGFyYW1zLnNsaWRlc1Blckdyb3VwKSB9IHJldHVybiByID0gTWF0aC5tYXgociwgMCksIHIgPSBNYXRoLm1pbihyLCBpLnNsaWRlc0dyaWQubGVuZ3RoIC0gMSksIGkuc2xpZGVUbyhyLCBlLCB0LCBzKSB9LCBzbGlkZVRvQ2xpY2tlZFNsaWRlOiBmdW5jdGlvbigpIHsgY29uc3QgZSA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcGFyYW1zOiB0LCAkd3JhcHBlckVsOiBzIH0gPSBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gXCJhdXRvXCIgPT09IHQuc2xpZGVzUGVyVmlldyA/IGUuc2xpZGVzUGVyVmlld0R5bmFtaWMoKSA6IHQuc2xpZGVzUGVyVmlldzsgbGV0IGksIHIgPSBlLmNsaWNrZWRJbmRleDsgaWYgKHQubG9vcCkgeyBpZiAoZS5hbmltYXRpbmcpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHBhcnNlSW50KGQoZS5jbGlja2VkU2xpZGUpLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSwgMTApLCB0LmNlbnRlcmVkU2xpZGVzID8gciA8IGUubG9vcGVkU2xpZGVzIC0gYSAvIDIgfHwgciA+IGUuc2xpZGVzLmxlbmd0aCAtIGUubG9vcGVkU2xpZGVzICsgYSAvIDIgPyAoZS5sb29wRml4KCksIHIgPSBzLmNoaWxkcmVuKGAuJHt0LnNsaWRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtpfVwiXTpub3QoLiR7dC5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlgKS5lcSgwKS5pbmRleCgpLCBwKCgoKSA9PiB7IGUuc2xpZGVUbyhyKSB9KSkpIDogZS5zbGlkZVRvKHIpIDogciA+IGUuc2xpZGVzLmxlbmd0aCAtIGEgPyAoZS5sb29wRml4KCksIHIgPSBzLmNoaWxkcmVuKGAuJHt0LnNsaWRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtpfVwiXTpub3QoLiR7dC5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlgKS5lcSgwKS5pbmRleCgpLCBwKCgoKSA9PiB7IGUuc2xpZGVUbyhyKSB9KSkpIDogZS5zbGlkZVRvKHIpIH0gZWxzZSBlLnNsaWRlVG8ocikgfSB9OyB2YXIgeiA9IHsgbG9vcENyZWF0ZTogZnVuY3Rpb24oKSB7IGNvbnN0IGUgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gYSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHBhcmFtczogcywgJHdyYXBwZXJFbDogaSB9ID0gZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IGkuY2hpbGRyZW4oKS5sZW5ndGggPiAwID8gZChpLmNoaWxkcmVuKClbMF0ucGFyZW50Tm9kZSkgOiBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHIuY2hpbGRyZW4oYC4ke3Muc2xpZGVDbGFzc30uJHtzLnNsaWRlRHVwbGljYXRlQ2xhc3N9YCkucmVtb3ZlKCk7IGxldCBuID0gci5jaGlsZHJlbihgLiR7cy5zbGlkZUNsYXNzfWApOyBpZiAocy5sb29wRmlsbEdyb3VwV2l0aEJsYW5rKSB7IGNvbnN0IGUgPSBzLnNsaWRlc1Blckdyb3VwIC0gbi5sZW5ndGggJSBzLnNsaWRlc1Blckdyb3VwOyBpZiAoZSAhPT0gcy5zbGlkZXNQZXJHcm91cCkgeyBmb3IgKGxldCBhID0gMDsgYSA8IGU7IGEgKz0gMSkgeyBjb25zdCBlID0gZCh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLmFkZENsYXNzKGAke3Muc2xpZGVDbGFzc30gJHtzLnNsaWRlQmxhbmtDbGFzc31gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmFwcGVuZChlKSB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gci5jaGlsZHJlbihgLiR7cy5zbGlkZUNsYXNzfWApIH0gfSBcImF1dG9cIiAhPT0gcy5zbGlkZXNQZXJWaWV3IHx8IHMubG9vcGVkU2xpZGVzIHx8IChzLmxvb3BlZFNsaWRlcyA9IG4ubGVuZ3RoKSwgZS5sb29wZWRTbGlkZXMgPSBNYXRoLmNlaWwocGFyc2VGbG9hdChzLmxvb3BlZFNsaWRlcyB8fCBzLnNsaWRlc1BlclZpZXcsIDEwKSksIGUubG9vcGVkU2xpZGVzICs9IHMubG9vcEFkZGl0aW9uYWxTbGlkZXMsIGUubG9vcGVkU2xpZGVzID4gbi5sZW5ndGggJiYgKGUubG9vcGVkU2xpZGVzID0gbi5sZW5ndGgpOyBjb25zdCBsID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBuLmVhY2goKCh0LCBzKSA9PiB7IGNvbnN0IGEgPSBkKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzIDwgZS5sb29wZWRTbGlkZXMgJiYgby5wdXNoKHQpLCBzIDwgbi5sZW5ndGggJiYgcyA+PSBuLmxlbmd0aCAtIGUubG9vcGVkU2xpZGVzICYmIGwucHVzaCh0KSwgYS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiwgcykgfSkpOyBmb3IgKGxldCBlID0gMDsgZSA8IG8ubGVuZ3RoOyBlICs9IDEpIHIuYXBwZW5kKGQob1tlXS5jbG9uZU5vZGUoITApKS5hZGRDbGFzcyhzLnNsaWRlRHVwbGljYXRlQ2xhc3MpKTsgZm9yIChsZXQgZSA9IGwubGVuZ3RoIC0gMTsgZSA+PSAwOyBlIC09IDEpIHIucHJlcGVuZChkKGxbZV0uY2xvbmVOb2RlKCEwKSkuYWRkQ2xhc3Mocy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkgfSwgbG9vcEZpeDogZnVuY3Rpb24oKSB7IGNvbnN0IGUgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuZW1pdChcImJlZm9yZUxvb3BGaXhcIik7IGNvbnN0IHsgYWN0aXZlSW5kZXg6IHQsIHNsaWRlczogcywgbG9vcGVkU2xpZGVzOiBhLCBhbGxvd1NsaWRlUHJldjogaSwgYWxsb3dTbGlkZU5leHQ6IHIsIHNuYXBHcmlkOiBuLCBydGxUcmFuc2xhdGU6IGwgfSA9IGU7IGxldCBvO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuYWxsb3dTbGlkZVByZXYgPSAhMCwgZS5hbGxvd1NsaWRlTmV4dCA9ICEwOyBjb25zdCBkID0gLW5bdF0gLSBlLmdldFRyYW5zbGF0ZSgpOyBpZiAodCA8IGEpIHsgbyA9IHMubGVuZ3RoIC0gMyAqIGEgKyB0LCBvICs9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2xpZGVUbyhvLCAwLCAhMSwgITApICYmIDAgIT09IGQgJiYgZS5zZXRUcmFuc2xhdGUoKGwgPyAtZS50cmFuc2xhdGUgOiBlLnRyYW5zbGF0ZSkgLSBkKSB9IGVsc2UgaWYgKHQgPj0gcy5sZW5ndGggLSBhKSB7IG8gPSAtcy5sZW5ndGggKyB0ICsgYSwgbyArPSBhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNsaWRlVG8obywgMCwgITEsICEwKSAmJiAwICE9PSBkICYmIGUuc2V0VHJhbnNsYXRlKChsID8gLWUudHJhbnNsYXRlIDogZS50cmFuc2xhdGUpIC0gZCkgfVxyXG4gICAgICAgICAgICAgICAgICAgIGUuYWxsb3dTbGlkZVByZXYgPSBpLCBlLmFsbG93U2xpZGVOZXh0ID0gciwgZS5lbWl0KFwibG9vcEZpeFwiKSB9LCBsb29wRGVzdHJveTogZnVuY3Rpb24oKSB7IGNvbnN0IHsgJHdyYXBwZXJFbDogZSwgcGFyYW1zOiB0LCBzbGlkZXM6IHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5jaGlsZHJlbihgLiR7dC5zbGlkZUNsYXNzfS4ke3Quc2xpZGVEdXBsaWNhdGVDbGFzc30sLiR7dC5zbGlkZUNsYXNzfS4ke3Quc2xpZGVCbGFua0NsYXNzfWApLnJlbW92ZSgpLCBzLnJlbW92ZUF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSB9IH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBMKGUpIHsgY29uc3QgdCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IGEoKSxcclxuICAgICAgICAgICAgICAgICAgICBpID0gcigpLFxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSB0LnRvdWNoRXZlbnRzRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICB7IHBhcmFtczogbCwgdG91Y2hlczogbywgZW5hYmxlZDogYyB9ID0gdDsgaWYgKCFjKSByZXR1cm47IGlmICh0LmFuaW1hdGluZyAmJiBsLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikgcmV0dXJuOyF0LmFuaW1hdGluZyAmJiBsLmNzc01vZGUgJiYgbC5sb29wICYmIHQubG9vcEZpeCgpOyBsZXQgcCA9IGU7XHJcbiAgICAgICAgICAgICAgICBwLm9yaWdpbmFsRXZlbnQgJiYgKHAgPSBwLm9yaWdpbmFsRXZlbnQpOyBsZXQgaCA9IGQocC50YXJnZXQpOyBpZiAoXCJ3cmFwcGVyXCIgPT09IGwudG91Y2hFdmVudHNUYXJnZXQgJiYgIWguY2xvc2VzdCh0LndyYXBwZXJFbCkubGVuZ3RoKSByZXR1cm47IGlmIChuLmlzVG91Y2hFdmVudCA9IFwidG91Y2hzdGFydFwiID09PSBwLnR5cGUsICFuLmlzVG91Y2hFdmVudCAmJiBcIndoaWNoXCIgaW4gcCAmJiAzID09PSBwLndoaWNoKSByZXR1cm47IGlmICghbi5pc1RvdWNoRXZlbnQgJiYgXCJidXR0b25cIiBpbiBwICYmIHAuYnV0dG9uID4gMCkgcmV0dXJuOyBpZiAobi5pc1RvdWNoZWQgJiYgbi5pc01vdmVkKSByZXR1cm47ISFsLm5vU3dpcGluZ0NsYXNzICYmIFwiXCIgIT09IGwubm9Td2lwaW5nQ2xhc3MgJiYgcC50YXJnZXQgJiYgcC50YXJnZXQuc2hhZG93Um9vdCAmJiBlLnBhdGggJiYgZS5wYXRoWzBdICYmIChoID0gZChlLnBhdGhbMF0pKTsgY29uc3QgbSA9IGwubm9Td2lwaW5nU2VsZWN0b3IgPyBsLm5vU3dpcGluZ1NlbGVjdG9yIDogYC4ke2wubm9Td2lwaW5nQ2xhc3N9YCxcclxuICAgICAgICAgICAgICAgICAgICBmID0gISghcC50YXJnZXQgfHwgIXAudGFyZ2V0LnNoYWRvd1Jvb3QpOyBpZiAobC5ub1N3aXBpbmcgJiYgKGYgPyBmdW5jdGlvbihlLCB0KSB7IHJldHVybiB2b2lkIDAgPT09IHQgJiYgKHQgPSB0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHQocykgeyBpZiAoIXMgfHwgcyA9PT0gYSgpIHx8IHMgPT09IHIoKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5hc3NpZ25lZFNsb3QgJiYgKHMgPSBzLmFzc2lnbmVkU2xvdCk7IGNvbnN0IGkgPSBzLmNsb3Nlc3QoZSk7IHJldHVybiBpIHx8IHMuZ2V0Um9vdE5vZGUgPyBpIHx8IHQocy5nZXRSb290Tm9kZSgpLmhvc3QpIDogbnVsbCB9KHQpIH0obSwgaFswXSkgOiBoLmNsb3Nlc3QobSlbMF0pKSByZXR1cm4gdm9pZCh0LmFsbG93Q2xpY2sgPSAhMCk7IGlmIChsLnN3aXBlSGFuZGxlciAmJiAhaC5jbG9zZXN0KGwuc3dpcGVIYW5kbGVyKVswXSkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgby5jdXJyZW50WCA9IFwidG91Y2hzdGFydFwiID09PSBwLnR5cGUgPyBwLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBwLnBhZ2VYLCBvLmN1cnJlbnRZID0gXCJ0b3VjaHN0YXJ0XCIgPT09IHAudHlwZSA/IHAudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IHAucGFnZVk7IGNvbnN0IGcgPSBvLmN1cnJlbnRYLFxyXG4gICAgICAgICAgICAgICAgICAgIHYgPSBvLmN1cnJlbnRZLFxyXG4gICAgICAgICAgICAgICAgICAgIHcgPSBsLmVkZ2VTd2lwZURldGVjdGlvbiB8fCBsLmlPU0VkZ2VTd2lwZURldGVjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBiID0gbC5lZGdlU3dpcGVUaHJlc2hvbGQgfHwgbC5pT1NFZGdlU3dpcGVUaHJlc2hvbGQ7IGlmICh3ICYmIChnIDw9IGIgfHwgZyA+PSBpLmlubmVyV2lkdGggLSBiKSkgeyBpZiAoXCJwcmV2ZW50XCIgIT09IHcpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCkgfSBpZiAoT2JqZWN0LmFzc2lnbihuLCB7IGlzVG91Y2hlZDogITAsIGlzTW92ZWQ6ICExLCBhbGxvd1RvdWNoQ2FsbGJhY2tzOiAhMCwgaXNTY3JvbGxpbmc6IHZvaWQgMCwgc3RhcnRNb3Zpbmc6IHZvaWQgMCB9KSwgby5zdGFydFggPSBnLCBvLnN0YXJ0WSA9IHYsIG4udG91Y2hTdGFydFRpbWUgPSB1KCksIHQuYWxsb3dDbGljayA9ICEwLCB0LnVwZGF0ZVNpemUoKSwgdC5zd2lwZURpcmVjdGlvbiA9IHZvaWQgMCwgbC50aHJlc2hvbGQgPiAwICYmIChuLmFsbG93VGhyZXNob2xkTW92ZSA9ICExKSwgXCJ0b3VjaHN0YXJ0XCIgIT09IHAudHlwZSkgeyBsZXQgZSA9ICEwO1xyXG4gICAgICAgICAgICAgICAgICAgIGguaXMobi5mb2N1c2FibGVFbGVtZW50cykgJiYgKGUgPSAhMSwgXCJTRUxFQ1RcIiA9PT0gaFswXS5ub2RlTmFtZSAmJiAobi5pc1RvdWNoZWQgPSAhMSkpLCBzLmFjdGl2ZUVsZW1lbnQgJiYgZChzLmFjdGl2ZUVsZW1lbnQpLmlzKG4uZm9jdXNhYmxlRWxlbWVudHMpICYmIHMuYWN0aXZlRWxlbWVudCAhPT0gaFswXSAmJiBzLmFjdGl2ZUVsZW1lbnQuYmx1cigpOyBjb25zdCBhID0gZSAmJiB0LmFsbG93VG91Y2hNb3ZlICYmIGwudG91Y2hTdGFydFByZXZlbnREZWZhdWx0OyFsLnRvdWNoU3RhcnRGb3JjZVByZXZlbnREZWZhdWx0ICYmICFhIHx8IGhbMF0uaXNDb250ZW50RWRpdGFibGUgfHwgcC5wcmV2ZW50RGVmYXVsdCgpIH1cclxuICAgICAgICAgICAgICAgIHQucGFyYW1zLmZyZWVNb2RlICYmIHQucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgdC5mcmVlTW9kZSAmJiB0LmFuaW1hdGluZyAmJiAhbC5jc3NNb2RlICYmIHQuZnJlZU1vZGUub25Ub3VjaFN0YXJ0KCksIHQuZW1pdChcInRvdWNoU3RhcnRcIiwgcCkgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gTyhlKSB7IGNvbnN0IHQgPSBhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IHMudG91Y2hFdmVudHNEYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgcGFyYW1zOiByLCB0b3VjaGVzOiBuLCBydGxUcmFuc2xhdGU6IGwsIGVuYWJsZWQ6IG8gfSA9IHM7IGlmICghbykgcmV0dXJuOyBsZXQgYyA9IGU7IGlmIChjLm9yaWdpbmFsRXZlbnQgJiYgKGMgPSBjLm9yaWdpbmFsRXZlbnQpLCAhaS5pc1RvdWNoZWQpIHJldHVybiB2b2lkKGkuc3RhcnRNb3ZpbmcgJiYgaS5pc1Njcm9sbGluZyAmJiBzLmVtaXQoXCJ0b3VjaE1vdmVPcHBvc2l0ZVwiLCBjKSk7IGlmIChpLmlzVG91Y2hFdmVudCAmJiBcInRvdWNobW92ZVwiICE9PSBjLnR5cGUpIHJldHVybjsgY29uc3QgcCA9IFwidG91Y2htb3ZlXCIgPT09IGMudHlwZSAmJiBjLnRhcmdldFRvdWNoZXMgJiYgKGMudGFyZ2V0VG91Y2hlc1swXSB8fCBjLmNoYW5nZWRUb3VjaGVzWzBdKSxcclxuICAgICAgICAgICAgICAgICAgICBoID0gXCJ0b3VjaG1vdmVcIiA9PT0gYy50eXBlID8gcC5wYWdlWCA6IGMucGFnZVgsXHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IFwidG91Y2htb3ZlXCIgPT09IGMudHlwZSA/IHAucGFnZVkgOiBjLnBhZ2VZOyBpZiAoYy5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlcikgcmV0dXJuIG4uc3RhcnRYID0gaCwgdm9pZChuLnN0YXJ0WSA9IG0pOyBpZiAoIXMuYWxsb3dUb3VjaE1vdmUpIHJldHVybiBkKGMudGFyZ2V0KS5pcyhpLmZvY3VzYWJsZUVsZW1lbnRzKSB8fCAocy5hbGxvd0NsaWNrID0gITEpLCB2b2lkKGkuaXNUb3VjaGVkICYmIChPYmplY3QuYXNzaWduKG4sIHsgc3RhcnRYOiBoLCBzdGFydFk6IG0sIGN1cnJlbnRYOiBoLCBjdXJyZW50WTogbSB9KSwgaS50b3VjaFN0YXJ0VGltZSA9IHUoKSkpOyBpZiAoaS5pc1RvdWNoRXZlbnQgJiYgci50b3VjaFJlbGVhc2VPbkVkZ2VzICYmICFyLmxvb3ApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuaXNWZXJ0aWNhbCgpKSB7IGlmIChtIDwgbi5zdGFydFkgJiYgcy50cmFuc2xhdGUgPD0gcy5tYXhUcmFuc2xhdGUoKSB8fCBtID4gbi5zdGFydFkgJiYgcy50cmFuc2xhdGUgPj0gcy5taW5UcmFuc2xhdGUoKSkgcmV0dXJuIGkuaXNUb3VjaGVkID0gITEsIHZvaWQoaS5pc01vdmVkID0gITEpIH0gZWxzZSBpZiAoaCA8IG4uc3RhcnRYICYmIHMudHJhbnNsYXRlIDw9IHMubWF4VHJhbnNsYXRlKCkgfHwgaCA+IG4uc3RhcnRYICYmIHMudHJhbnNsYXRlID49IHMubWluVHJhbnNsYXRlKCkpIHJldHVybjsgaWYgKGkuaXNUb3VjaEV2ZW50ICYmIHQuYWN0aXZlRWxlbWVudCAmJiBjLnRhcmdldCA9PT0gdC5hY3RpdmVFbGVtZW50ICYmIGQoYy50YXJnZXQpLmlzKGkuZm9jdXNhYmxlRWxlbWVudHMpKSByZXR1cm4gaS5pc01vdmVkID0gITAsIHZvaWQocy5hbGxvd0NsaWNrID0gITEpOyBpZiAoaS5hbGxvd1RvdWNoQ2FsbGJhY2tzICYmIHMuZW1pdChcInRvdWNoTW92ZVwiLCBjKSwgYy50YXJnZXRUb3VjaGVzICYmIGMudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAxKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBuLmN1cnJlbnRYID0gaCwgbi5jdXJyZW50WSA9IG07IGNvbnN0IGYgPSBuLmN1cnJlbnRYIC0gbi5zdGFydFgsXHJcbiAgICAgICAgICAgICAgICAgICAgZyA9IG4uY3VycmVudFkgLSBuLnN0YXJ0WTsgaWYgKHMucGFyYW1zLnRocmVzaG9sZCAmJiBNYXRoLnNxcnQoZiAqKiAyICsgZyAqKiAyKSA8IHMucGFyYW1zLnRocmVzaG9sZCkgcmV0dXJuOyBpZiAodm9pZCAwID09PSBpLmlzU2Nyb2xsaW5nKSB7IGxldCBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHMuaXNIb3Jpem9udGFsKCkgJiYgbi5jdXJyZW50WSA9PT0gbi5zdGFydFkgfHwgcy5pc1ZlcnRpY2FsKCkgJiYgbi5jdXJyZW50WCA9PT0gbi5zdGFydFggPyBpLmlzU2Nyb2xsaW5nID0gITEgOiBmICogZiArIGcgKiBnID49IDI1ICYmIChlID0gMTgwICogTWF0aC5hdGFuMihNYXRoLmFicyhnKSwgTWF0aC5hYnMoZikpIC8gTWF0aC5QSSwgaS5pc1Njcm9sbGluZyA9IHMuaXNIb3Jpem9udGFsKCkgPyBlID4gci50b3VjaEFuZ2xlIDogOTAgLSBlID4gci50b3VjaEFuZ2xlKSB9IGlmIChpLmlzU2Nyb2xsaW5nICYmIHMuZW1pdChcInRvdWNoTW92ZU9wcG9zaXRlXCIsIGMpLCB2b2lkIDAgPT09IGkuc3RhcnRNb3ZpbmcgJiYgKG4uY3VycmVudFggPT09IG4uc3RhcnRYICYmIG4uY3VycmVudFkgPT09IG4uc3RhcnRZIHx8IChpLnN0YXJ0TW92aW5nID0gITApKSwgaS5pc1Njcm9sbGluZykgcmV0dXJuIHZvaWQoaS5pc1RvdWNoZWQgPSAhMSk7IGlmICghaS5zdGFydE1vdmluZykgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgcy5hbGxvd0NsaWNrID0gITEsICFyLmNzc01vZGUgJiYgYy5jYW5jZWxhYmxlICYmIGMucHJldmVudERlZmF1bHQoKSwgci50b3VjaE1vdmVTdG9wUHJvcGFnYXRpb24gJiYgIXIubmVzdGVkICYmIGMuc3RvcFByb3BhZ2F0aW9uKCksIGkuaXNNb3ZlZCB8fCAoci5sb29wICYmICFyLmNzc01vZGUgJiYgcy5sb29wRml4KCksIGkuc3RhcnRUcmFuc2xhdGUgPSBzLmdldFRyYW5zbGF0ZSgpLCBzLnNldFRyYW5zaXRpb24oMCksIHMuYW5pbWF0aW5nICYmIHMuJHdyYXBwZXJFbC50cmlnZ2VyKFwid2Via2l0VHJhbnNpdGlvbkVuZCB0cmFuc2l0aW9uZW5kXCIpLCBpLmFsbG93TW9tZW50dW1Cb3VuY2UgPSAhMSwgIXIuZ3JhYkN1cnNvciB8fCAhMCAhPT0gcy5hbGxvd1NsaWRlTmV4dCAmJiAhMCAhPT0gcy5hbGxvd1NsaWRlUHJldiB8fCBzLnNldEdyYWJDdXJzb3IoITApLCBzLmVtaXQoXCJzbGlkZXJGaXJzdE1vdmVcIiwgYykpLCBzLmVtaXQoXCJzbGlkZXJNb3ZlXCIsIGMpLCBpLmlzTW92ZWQgPSAhMDsgbGV0IHYgPSBzLmlzSG9yaXpvbnRhbCgpID8gZiA6IGc7XHJcbiAgICAgICAgICAgICAgICBuLmRpZmYgPSB2LCB2ICo9IHIudG91Y2hSYXRpbywgbCAmJiAodiA9IC12KSwgcy5zd2lwZURpcmVjdGlvbiA9IHYgPiAwID8gXCJwcmV2XCIgOiBcIm5leHRcIiwgaS5jdXJyZW50VHJhbnNsYXRlID0gdiArIGkuc3RhcnRUcmFuc2xhdGU7IGxldCB3ID0gITAsXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHIucmVzaXN0YW5jZVJhdGlvOyBpZiAoci50b3VjaFJlbGVhc2VPbkVkZ2VzICYmIChiID0gMCksIHYgPiAwICYmIGkuY3VycmVudFRyYW5zbGF0ZSA+IHMubWluVHJhbnNsYXRlKCkgPyAodyA9ICExLCByLnJlc2lzdGFuY2UgJiYgKGkuY3VycmVudFRyYW5zbGF0ZSA9IHMubWluVHJhbnNsYXRlKCkgLSAxICsgKC1zLm1pblRyYW5zbGF0ZSgpICsgaS5zdGFydFRyYW5zbGF0ZSArIHYpICoqIGIpKSA6IHYgPCAwICYmIGkuY3VycmVudFRyYW5zbGF0ZSA8IHMubWF4VHJhbnNsYXRlKCkgJiYgKHcgPSAhMSwgci5yZXNpc3RhbmNlICYmIChpLmN1cnJlbnRUcmFuc2xhdGUgPSBzLm1heFRyYW5zbGF0ZSgpICsgMSAtIChzLm1heFRyYW5zbGF0ZSgpIC0gaS5zdGFydFRyYW5zbGF0ZSAtIHYpICoqIGIpKSwgdyAmJiAoYy5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlciA9ICEwKSwgIXMuYWxsb3dTbGlkZU5leHQgJiYgXCJuZXh0XCIgPT09IHMuc3dpcGVEaXJlY3Rpb24gJiYgaS5jdXJyZW50VHJhbnNsYXRlIDwgaS5zdGFydFRyYW5zbGF0ZSAmJiAoaS5jdXJyZW50VHJhbnNsYXRlID0gaS5zdGFydFRyYW5zbGF0ZSksICFzLmFsbG93U2xpZGVQcmV2ICYmIFwicHJldlwiID09PSBzLnN3aXBlRGlyZWN0aW9uICYmIGkuY3VycmVudFRyYW5zbGF0ZSA+IGkuc3RhcnRUcmFuc2xhdGUgJiYgKGkuY3VycmVudFRyYW5zbGF0ZSA9IGkuc3RhcnRUcmFuc2xhdGUpLCBzLmFsbG93U2xpZGVQcmV2IHx8IHMuYWxsb3dTbGlkZU5leHQgfHwgKGkuY3VycmVudFRyYW5zbGF0ZSA9IGkuc3RhcnRUcmFuc2xhdGUpLCByLnRocmVzaG9sZCA+IDApIHsgaWYgKCEoTWF0aC5hYnModikgPiByLnRocmVzaG9sZCB8fCBpLmFsbG93VGhyZXNob2xkTW92ZSkpIHJldHVybiB2b2lkKGkuY3VycmVudFRyYW5zbGF0ZSA9IGkuc3RhcnRUcmFuc2xhdGUpOyBpZiAoIWkuYWxsb3dUaHJlc2hvbGRNb3ZlKSByZXR1cm4gaS5hbGxvd1RocmVzaG9sZE1vdmUgPSAhMCwgbi5zdGFydFggPSBuLmN1cnJlbnRYLCBuLnN0YXJ0WSA9IG4uY3VycmVudFksIGkuY3VycmVudFRyYW5zbGF0ZSA9IGkuc3RhcnRUcmFuc2xhdGUsIHZvaWQobi5kaWZmID0gcy5pc0hvcml6b250YWwoKSA/IG4uY3VycmVudFggLSBuLnN0YXJ0WCA6IG4uY3VycmVudFkgLSBuLnN0YXJ0WSkgfVxyXG4gICAgICAgICAgICAgICAgci5mb2xsb3dGaW5nZXIgJiYgIXIuY3NzTW9kZSAmJiAoKHIuZnJlZU1vZGUgJiYgci5mcmVlTW9kZS5lbmFibGVkICYmIHMuZnJlZU1vZGUgfHwgci53YXRjaFNsaWRlc1Byb2dyZXNzKSAmJiAocy51cGRhdGVBY3RpdmVJbmRleCgpLCBzLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSksIHMucGFyYW1zLmZyZWVNb2RlICYmIHIuZnJlZU1vZGUuZW5hYmxlZCAmJiBzLmZyZWVNb2RlICYmIHMuZnJlZU1vZGUub25Ub3VjaE1vdmUoKSwgcy51cGRhdGVQcm9ncmVzcyhpLmN1cnJlbnRUcmFuc2xhdGUpLCBzLnNldFRyYW5zbGF0ZShpLmN1cnJlbnRUcmFuc2xhdGUpKSB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBJKGUpIHsgY29uc3QgdCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IHQudG91Y2hFdmVudHNEYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgcGFyYW1zOiBhLCB0b3VjaGVzOiBpLCBydGxUcmFuc2xhdGU6IHIsIHNsaWRlc0dyaWQ6IG4sIGVuYWJsZWQ6IGwgfSA9IHQ7IGlmICghbCkgcmV0dXJuOyBsZXQgbyA9IGU7IGlmIChvLm9yaWdpbmFsRXZlbnQgJiYgKG8gPSBvLm9yaWdpbmFsRXZlbnQpLCBzLmFsbG93VG91Y2hDYWxsYmFja3MgJiYgdC5lbWl0KFwidG91Y2hFbmRcIiwgbyksIHMuYWxsb3dUb3VjaENhbGxiYWNrcyA9ICExLCAhcy5pc1RvdWNoZWQpIHJldHVybiBzLmlzTW92ZWQgJiYgYS5ncmFiQ3Vyc29yICYmIHQuc2V0R3JhYkN1cnNvcighMSksIHMuaXNNb3ZlZCA9ICExLCB2b2lkKHMuc3RhcnRNb3ZpbmcgPSAhMSk7XHJcbiAgICAgICAgICAgICAgICBhLmdyYWJDdXJzb3IgJiYgcy5pc01vdmVkICYmIHMuaXNUb3VjaGVkICYmICghMCA9PT0gdC5hbGxvd1NsaWRlTmV4dCB8fCAhMCA9PT0gdC5hbGxvd1NsaWRlUHJldikgJiYgdC5zZXRHcmFiQ3Vyc29yKCExKTsgY29uc3QgZCA9IHUoKSxcclxuICAgICAgICAgICAgICAgICAgICBjID0gZCAtIHMudG91Y2hTdGFydFRpbWU7IGlmICh0LmFsbG93Q2xpY2spIHsgY29uc3QgZSA9IG8ucGF0aCB8fCBvLmNvbXBvc2VkUGF0aCAmJiBvLmNvbXBvc2VkUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHQudXBkYXRlQ2xpY2tlZFNsaWRlKGUgJiYgZVswXSB8fCBvLnRhcmdldCksIHQuZW1pdChcInRhcCBjbGlja1wiLCBvKSwgYyA8IDMwMCAmJiBkIC0gcy5sYXN0Q2xpY2tUaW1lIDwgMzAwICYmIHQuZW1pdChcImRvdWJsZVRhcCBkb3VibGVDbGlja1wiLCBvKSB9IGlmIChzLmxhc3RDbGlja1RpbWUgPSB1KCksIHAoKCgpID0+IHsgdC5kZXN0cm95ZWQgfHwgKHQuYWxsb3dDbGljayA9ICEwKSB9KSksICFzLmlzVG91Y2hlZCB8fCAhcy5pc01vdmVkIHx8ICF0LnN3aXBlRGlyZWN0aW9uIHx8IDAgPT09IGkuZGlmZiB8fCBzLmN1cnJlbnRUcmFuc2xhdGUgPT09IHMuc3RhcnRUcmFuc2xhdGUpIHJldHVybiBzLmlzVG91Y2hlZCA9ICExLCBzLmlzTW92ZWQgPSAhMSwgdm9pZChzLnN0YXJ0TW92aW5nID0gITEpOyBsZXQgaDsgaWYgKHMuaXNUb3VjaGVkID0gITEsIHMuaXNNb3ZlZCA9ICExLCBzLnN0YXJ0TW92aW5nID0gITEsIGggPSBhLmZvbGxvd0ZpbmdlciA/IHIgPyB0LnRyYW5zbGF0ZSA6IC10LnRyYW5zbGF0ZSA6IC1zLmN1cnJlbnRUcmFuc2xhdGUsIGEuY3NzTW9kZSkgcmV0dXJuOyBpZiAodC5wYXJhbXMuZnJlZU1vZGUgJiYgYS5mcmVlTW9kZS5lbmFibGVkKSByZXR1cm4gdm9pZCB0LmZyZWVNb2RlLm9uVG91Y2hFbmQoeyBjdXJyZW50UG9zOiBoIH0pOyBsZXQgbSA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IHQuc2xpZGVzU2l6ZXNHcmlkWzBdOyBmb3IgKGxldCBlID0gMDsgZSA8IG4ubGVuZ3RoOyBlICs9IGUgPCBhLnNsaWRlc1Blckdyb3VwU2tpcCA/IDEgOiBhLnNsaWRlc1Blckdyb3VwKSB7IGNvbnN0IHQgPSBlIDwgYS5zbGlkZXNQZXJHcm91cFNraXAgLSAxID8gMSA6IGEuc2xpZGVzUGVyR3JvdXA7XHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBuW2UgKyB0XSA/IGggPj0gbltlXSAmJiBoIDwgbltlICsgdF0gJiYgKG0gPSBlLCBmID0gbltlICsgdF0gLSBuW2VdKSA6IGggPj0gbltlXSAmJiAobSA9IGUsIGYgPSBuW24ubGVuZ3RoIC0gMV0gLSBuW24ubGVuZ3RoIC0gMl0pIH0gbGV0IGcgPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgYS5yZXdpbmQgJiYgKHQuaXNCZWdpbm5pbmcgPyB2ID0gdC5wYXJhbXMudmlydHVhbCAmJiB0LnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgdC52aXJ0dWFsID8gdC52aXJ0dWFsLnNsaWRlcy5sZW5ndGggLSAxIDogdC5zbGlkZXMubGVuZ3RoIC0gMSA6IHQuaXNFbmQgJiYgKGcgPSAwKSk7IGNvbnN0IHcgPSAoaCAtIG5bbV0pIC8gZixcclxuICAgICAgICAgICAgICAgICAgICBiID0gbSA8IGEuc2xpZGVzUGVyR3JvdXBTa2lwIC0gMSA/IDEgOiBhLnNsaWRlc1Blckdyb3VwOyBpZiAoYyA+IGEubG9uZ1N3aXBlc01zKSB7IGlmICghYS5sb25nU3dpcGVzKSByZXR1cm4gdm9pZCB0LnNsaWRlVG8odC5hY3RpdmVJbmRleCk7IFwibmV4dFwiID09PSB0LnN3aXBlRGlyZWN0aW9uICYmICh3ID49IGEubG9uZ1N3aXBlc1JhdGlvID8gdC5zbGlkZVRvKGEucmV3aW5kICYmIHQuaXNFbmQgPyBnIDogbSArIGIpIDogdC5zbGlkZVRvKG0pKSwgXCJwcmV2XCIgPT09IHQuc3dpcGVEaXJlY3Rpb24gJiYgKHcgPiAxIC0gYS5sb25nU3dpcGVzUmF0aW8gPyB0LnNsaWRlVG8obSArIGIpIDogbnVsbCAhPT0gdiAmJiB3IDwgMCAmJiBNYXRoLmFicyh3KSA+IGEubG9uZ1N3aXBlc1JhdGlvID8gdC5zbGlkZVRvKHYpIDogdC5zbGlkZVRvKG0pKSB9IGVsc2UgeyBpZiAoIWEuc2hvcnRTd2lwZXMpIHJldHVybiB2b2lkIHQuc2xpZGVUbyh0LmFjdGl2ZUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB0Lm5hdmlnYXRpb24gJiYgKG8udGFyZ2V0ID09PSB0Lm5hdmlnYXRpb24ubmV4dEVsIHx8IG8udGFyZ2V0ID09PSB0Lm5hdmlnYXRpb24ucHJldkVsKSA/IG8udGFyZ2V0ID09PSB0Lm5hdmlnYXRpb24ubmV4dEVsID8gdC5zbGlkZVRvKG0gKyBiKSA6IHQuc2xpZGVUbyhtKSA6IChcIm5leHRcIiA9PT0gdC5zd2lwZURpcmVjdGlvbiAmJiB0LnNsaWRlVG8obnVsbCAhPT0gZyA/IGcgOiBtICsgYiksIFwicHJldlwiID09PSB0LnN3aXBlRGlyZWN0aW9uICYmIHQuc2xpZGVUbyhudWxsICE9PSB2ID8gdiA6IG0pKSB9IH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEEoKSB7IGNvbnN0IGUgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgcGFyYW1zOiB0LCBlbDogcyB9ID0gZTsgaWYgKHMgJiYgMCA9PT0gcy5vZmZzZXRXaWR0aCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdC5icmVha3BvaW50cyAmJiBlLnNldEJyZWFrcG9pbnQoKTsgY29uc3QgeyBhbGxvd1NsaWRlTmV4dDogYSwgYWxsb3dTbGlkZVByZXY6IGksIHNuYXBHcmlkOiByIH0gPSBlO1xyXG4gICAgICAgICAgICAgICAgZS5hbGxvd1NsaWRlTmV4dCA9ICEwLCBlLmFsbG93U2xpZGVQcmV2ID0gITAsIGUudXBkYXRlU2l6ZSgpLCBlLnVwZGF0ZVNsaWRlcygpLCBlLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSwgKFwiYXV0b1wiID09PSB0LnNsaWRlc1BlclZpZXcgfHwgdC5zbGlkZXNQZXJWaWV3ID4gMSkgJiYgZS5pc0VuZCAmJiAhZS5pc0JlZ2lubmluZyAmJiAhZS5wYXJhbXMuY2VudGVyZWRTbGlkZXMgPyBlLnNsaWRlVG8oZS5zbGlkZXMubGVuZ3RoIC0gMSwgMCwgITEsICEwKSA6IGUuc2xpZGVUbyhlLmFjdGl2ZUluZGV4LCAwLCAhMSwgITApLCBlLmF1dG9wbGF5ICYmIGUuYXV0b3BsYXkucnVubmluZyAmJiBlLmF1dG9wbGF5LnBhdXNlZCAmJiBlLmF1dG9wbGF5LnJ1bigpLCBlLmFsbG93U2xpZGVQcmV2ID0gaSwgZS5hbGxvd1NsaWRlTmV4dCA9IGEsIGUucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgciAhPT0gZS5zbmFwR3JpZCAmJiBlLmNoZWNrT3ZlcmZsb3coKSB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBEKGUpIHsgY29uc3QgdCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0LmVuYWJsZWQgJiYgKHQuYWxsb3dDbGljayB8fCAodC5wYXJhbXMucHJldmVudENsaWNrcyAmJiBlLnByZXZlbnREZWZhdWx0KCksIHQucGFyYW1zLnByZXZlbnRDbGlja3NQcm9wYWdhdGlvbiAmJiB0LmFuaW1hdGluZyAmJiAoZS5zdG9wUHJvcGFnYXRpb24oKSwgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSkpKSB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBHKCkgeyBjb25zdCBlID0gdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICB7IHdyYXBwZXJFbDogdCwgcnRsVHJhbnNsYXRlOiBzLCBlbmFibGVkOiBhIH0gPSBlOyBpZiAoIWEpIHJldHVybjsgbGV0IGk7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZpb3VzVHJhbnNsYXRlID0gZS50cmFuc2xhdGUsIGUuaXNIb3Jpem9udGFsKCkgPyBlLnRyYW5zbGF0ZSA9IC10LnNjcm9sbExlZnQgOiBlLnRyYW5zbGF0ZSA9IC10LnNjcm9sbFRvcCwgMCA9PT0gZS50cmFuc2xhdGUgJiYgKGUudHJhbnNsYXRlID0gMCksIGUudXBkYXRlQWN0aXZlSW5kZXgoKSwgZS51cGRhdGVTbGlkZXNDbGFzc2VzKCk7IGNvbnN0IHIgPSBlLm1heFRyYW5zbGF0ZSgpIC0gZS5taW5UcmFuc2xhdGUoKTtcclxuICAgICAgICAgICAgICAgIGkgPSAwID09PSByID8gMCA6IChlLnRyYW5zbGF0ZSAtIGUubWluVHJhbnNsYXRlKCkpIC8gciwgaSAhPT0gZS5wcm9ncmVzcyAmJiBlLnVwZGF0ZVByb2dyZXNzKHMgPyAtZS50cmFuc2xhdGUgOiBlLnRyYW5zbGF0ZSksIGUuZW1pdChcInNldFRyYW5zbGF0ZVwiLCBlLnRyYW5zbGF0ZSwgITEpIH0gbGV0IE4gPSAhMTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEIoKSB7fSBjb25zdCBIID0gKGUsIHQpID0+IHsgY29uc3QgcyA9IGEoKSxcclxuICAgICAgICAgICAgICAgICAgICB7IHBhcmFtczogaSwgdG91Y2hFdmVudHM6IHIsIGVsOiBuLCB3cmFwcGVyRWw6IGwsIGRldmljZTogbywgc3VwcG9ydDogZCB9ID0gZSxcclxuICAgICAgICAgICAgICAgICAgICBjID0gISFpLm5lc3RlZCxcclxuICAgICAgICAgICAgICAgICAgICBwID0gXCJvblwiID09PSB0ID8gXCJhZGRFdmVudExpc3RlbmVyXCIgOiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcclxuICAgICAgICAgICAgICAgICAgICB1ID0gdDsgaWYgKGQudG91Y2gpIHsgY29uc3QgdCA9ICEoXCJ0b3VjaHN0YXJ0XCIgIT09IHIuc3RhcnQgfHwgIWQucGFzc2l2ZUxpc3RlbmVyIHx8ICFpLnBhc3NpdmVMaXN0ZW5lcnMpICYmIHsgcGFzc2l2ZTogITAsIGNhcHR1cmU6ICExIH07XHJcbiAgICAgICAgICAgICAgICAgICAgbltwXShyLnN0YXJ0LCBlLm9uVG91Y2hTdGFydCwgdCksIG5bcF0oci5tb3ZlLCBlLm9uVG91Y2hNb3ZlLCBkLnBhc3NpdmVMaXN0ZW5lciA/IHsgcGFzc2l2ZTogITEsIGNhcHR1cmU6IGMgfSA6IGMpLCBuW3BdKHIuZW5kLCBlLm9uVG91Y2hFbmQsIHQpLCByLmNhbmNlbCAmJiBuW3BdKHIuY2FuY2VsLCBlLm9uVG91Y2hFbmQsIHQpIH0gZWxzZSBuW3BdKHIuc3RhcnQsIGUub25Ub3VjaFN0YXJ0LCAhMSksIHNbcF0oci5tb3ZlLCBlLm9uVG91Y2hNb3ZlLCBjKSwgc1twXShyLmVuZCwgZS5vblRvdWNoRW5kLCAhMSk7XHJcbiAgICAgICAgICAgICAgICAoaS5wcmV2ZW50Q2xpY2tzIHx8IGkucHJldmVudENsaWNrc1Byb3BhZ2F0aW9uKSAmJiBuW3BdKFwiY2xpY2tcIiwgZS5vbkNsaWNrLCAhMCksIGkuY3NzTW9kZSAmJiBsW3BdKFwic2Nyb2xsXCIsIGUub25TY3JvbGwpLCBpLnVwZGF0ZU9uV2luZG93UmVzaXplID8gZVt1XShvLmlvcyB8fCBvLmFuZHJvaWQgPyBcInJlc2l6ZSBvcmllbnRhdGlvbmNoYW5nZSBvYnNlcnZlclVwZGF0ZVwiIDogXCJyZXNpemUgb2JzZXJ2ZXJVcGRhdGVcIiwgQSwgITApIDogZVt1XShcIm9ic2VydmVyVXBkYXRlXCIsIEEsICEwKSB9OyB2YXIgWCA9IHsgYXR0YWNoRXZlbnRzOiBmdW5jdGlvbigpIHsgY29uc3QgZSA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcGFyYW1zOiBzLCBzdXBwb3J0OiBpIH0gPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGUub25Ub3VjaFN0YXJ0ID0gTC5iaW5kKGUpLCBlLm9uVG91Y2hNb3ZlID0gTy5iaW5kKGUpLCBlLm9uVG91Y2hFbmQgPSBJLmJpbmQoZSksIHMuY3NzTW9kZSAmJiAoZS5vblNjcm9sbCA9IEcuYmluZChlKSksIGUub25DbGljayA9IEQuYmluZChlKSwgaS50b3VjaCAmJiAhTiAmJiAodC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBCKSwgTiA9ICEwKSwgSChlLCBcIm9uXCIpIH0sIGRldGFjaEV2ZW50czogZnVuY3Rpb24oKSB7IEgodGhpcywgXCJvZmZcIikgfSB9OyBjb25zdCBZID0gKGUsIHQpID0+IGUuZ3JpZCAmJiB0LmdyaWQgJiYgdC5ncmlkLnJvd3MgPiAxOyB2YXIgUiA9IHsgYWRkQ2xhc3NlczogZnVuY3Rpb24oKSB7IGNvbnN0IGUgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZXM6IHQsIHBhcmFtczogcywgcnRsOiBhLCAkZWw6IGksIGRldmljZTogciwgc3VwcG9ydDogbiB9ID0gZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IGZ1bmN0aW9uKGUsIHQpIHsgY29uc3QgcyA9IFtdOyByZXR1cm4gZS5mb3JFYWNoKChlID0+IHsgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSA/IE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGEgPT4geyBlW2FdICYmIHMucHVzaCh0ICsgYSkgfSkpIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiBzLnB1c2godCArIGUpIH0pKSwgcyB9KFtcImluaXRpYWxpemVkXCIsIHMuZGlyZWN0aW9uLCB7IFwicG9pbnRlci1ldmVudHNcIjogIW4udG91Y2ggfSwgeyBcImZyZWUtbW9kZVwiOiBlLnBhcmFtcy5mcmVlTW9kZSAmJiBzLmZyZWVNb2RlLmVuYWJsZWQgfSwgeyBhdXRvaGVpZ2h0OiBzLmF1dG9IZWlnaHQgfSwgeyBydGw6IGEgfSwgeyBncmlkOiBzLmdyaWQgJiYgcy5ncmlkLnJvd3MgPiAxIH0sIHsgXCJncmlkLWNvbHVtblwiOiBzLmdyaWQgJiYgcy5ncmlkLnJvd3MgPiAxICYmIFwiY29sdW1uXCIgPT09IHMuZ3JpZC5maWxsIH0sIHsgYW5kcm9pZDogci5hbmRyb2lkIH0sIHsgaW9zOiByLmlvcyB9LCB7IFwiY3NzLW1vZGVcIjogcy5jc3NNb2RlIH0sIHsgY2VudGVyZWQ6IHMuY3NzTW9kZSAmJiBzLmNlbnRlcmVkU2xpZGVzIH0sIHsgXCJ3YXRjaC1wcm9ncmVzc1wiOiBzLndhdGNoU2xpZGVzUHJvZ3Jlc3MgfV0sIHMuY29udGFpbmVyTW9kaWZpZXJDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5wdXNoKC4uLmwpLCBpLmFkZENsYXNzKFsuLi50XS5qb2luKFwiIFwiKSksIGUuZW1pdENvbnRhaW5lckNsYXNzZXMoKSB9LCByZW1vdmVDbGFzc2VzOiBmdW5jdGlvbigpIHsgY29uc3QgeyAkZWw6IGUsIGNsYXNzTmFtZXM6IHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVDbGFzcyh0LmpvaW4oXCIgXCIpKSwgdGhpcy5lbWl0Q29udGFpbmVyQ2xhc3NlcygpIH0gfTsgdmFyIFcgPSB7IGluaXQ6ICEwLCBkaXJlY3Rpb246IFwiaG9yaXpvbnRhbFwiLCB0b3VjaEV2ZW50c1RhcmdldDogXCJ3cmFwcGVyXCIsIGluaXRpYWxTbGlkZTogMCwgc3BlZWQ6IDMwMCwgY3NzTW9kZTogITEsIHVwZGF0ZU9uV2luZG93UmVzaXplOiAhMCwgcmVzaXplT2JzZXJ2ZXI6ICEwLCBuZXN0ZWQ6ICExLCBjcmVhdGVFbGVtZW50czogITEsIGVuYWJsZWQ6ICEwLCBmb2N1c2FibGVFbGVtZW50czogXCJpbnB1dCwgc2VsZWN0LCBvcHRpb24sIHRleHRhcmVhLCBidXR0b24sIHZpZGVvLCBsYWJlbFwiLCB3aWR0aDogbnVsbCwgaGVpZ2h0OiBudWxsLCBwcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb246ICExLCB1c2VyQWdlbnQ6IG51bGwsIHVybDogbnVsbCwgZWRnZVN3aXBlRGV0ZWN0aW9uOiAhMSwgZWRnZVN3aXBlVGhyZXNob2xkOiAyMCwgYXV0b0hlaWdodDogITEsIHNldFdyYXBwZXJTaXplOiAhMSwgdmlydHVhbFRyYW5zbGF0ZTogITEsIGVmZmVjdDogXCJzbGlkZVwiLCBicmVha3BvaW50czogdm9pZCAwLCBicmVha3BvaW50c0Jhc2U6IFwid2luZG93XCIsIHNwYWNlQmV0d2VlbjogMCwgc2xpZGVzUGVyVmlldzogMSwgc2xpZGVzUGVyR3JvdXA6IDEsIHNsaWRlc1Blckdyb3VwU2tpcDogMCwgc2xpZGVzUGVyR3JvdXBBdXRvOiAhMSwgY2VudGVyZWRTbGlkZXM6ICExLCBjZW50ZXJlZFNsaWRlc0JvdW5kczogITEsIHNsaWRlc09mZnNldEJlZm9yZTogMCwgc2xpZGVzT2Zmc2V0QWZ0ZXI6IDAsIG5vcm1hbGl6ZVNsaWRlSW5kZXg6ICEwLCBjZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXM6ICExLCB3YXRjaE92ZXJmbG93OiAhMCwgcm91bmRMZW5ndGhzOiAhMSwgdG91Y2hSYXRpbzogMSwgdG91Y2hBbmdsZTogNDUsIHNpbXVsYXRlVG91Y2g6ICEwLCBzaG9ydFN3aXBlczogITAsIGxvbmdTd2lwZXM6ICEwLCBsb25nU3dpcGVzUmF0aW86IC41LCBsb25nU3dpcGVzTXM6IDMwMCwgZm9sbG93RmluZ2VyOiAhMCwgYWxsb3dUb3VjaE1vdmU6ICEwLCB0aHJlc2hvbGQ6IDAsIHRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbjogITEsIHRvdWNoU3RhcnRQcmV2ZW50RGVmYXVsdDogITAsIHRvdWNoU3RhcnRGb3JjZVByZXZlbnREZWZhdWx0OiAhMSwgdG91Y2hSZWxlYXNlT25FZGdlczogITEsIHVuaXF1ZU5hdkVsZW1lbnRzOiAhMCwgcmVzaXN0YW5jZTogITAsIHJlc2lzdGFuY2VSYXRpbzogLjg1LCB3YXRjaFNsaWRlc1Byb2dyZXNzOiAhMSwgZ3JhYkN1cnNvcjogITEsIHByZXZlbnRDbGlja3M6ICEwLCBwcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb246ICEwLCBzbGlkZVRvQ2xpY2tlZFNsaWRlOiAhMSwgcHJlbG9hZEltYWdlczogITAsIHVwZGF0ZU9uSW1hZ2VzUmVhZHk6ICEwLCBsb29wOiAhMSwgbG9vcEFkZGl0aW9uYWxTbGlkZXM6IDAsIGxvb3BlZFNsaWRlczogbnVsbCwgbG9vcEZpbGxHcm91cFdpdGhCbGFuazogITEsIGxvb3BQcmV2ZW50c1NsaWRlOiAhMCwgcmV3aW5kOiAhMSwgYWxsb3dTbGlkZVByZXY6ICEwLCBhbGxvd1NsaWRlTmV4dDogITAsIHN3aXBlSGFuZGxlcjogbnVsbCwgbm9Td2lwaW5nOiAhMCwgbm9Td2lwaW5nQ2xhc3M6IFwic3dpcGVyLW5vLXN3aXBpbmdcIiwgbm9Td2lwaW5nU2VsZWN0b3I6IG51bGwsIHBhc3NpdmVMaXN0ZW5lcnM6ICEwLCBtYXhCYWNrZmFjZUhpZGRlblNsaWRlczogMTAsIGNvbnRhaW5lck1vZGlmaWVyQ2xhc3M6IFwic3dpcGVyLVwiLCBzbGlkZUNsYXNzOiBcInN3aXBlci1zbGlkZVwiLCBzbGlkZUJsYW5rQ2xhc3M6IFwic3dpcGVyLXNsaWRlLWludmlzaWJsZS1ibGFua1wiLCBzbGlkZUFjdGl2ZUNsYXNzOiBcInN3aXBlci1zbGlkZS1hY3RpdmVcIiwgc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzczogXCJzd2lwZXItc2xpZGUtZHVwbGljYXRlLWFjdGl2ZVwiLCBzbGlkZVZpc2libGVDbGFzczogXCJzd2lwZXItc2xpZGUtdmlzaWJsZVwiLCBzbGlkZUR1cGxpY2F0ZUNsYXNzOiBcInN3aXBlci1zbGlkZS1kdXBsaWNhdGVcIiwgc2xpZGVOZXh0Q2xhc3M6IFwic3dpcGVyLXNsaWRlLW5leHRcIiwgc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3M6IFwic3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1uZXh0XCIsIHNsaWRlUHJldkNsYXNzOiBcInN3aXBlci1zbGlkZS1wcmV2XCIsIHNsaWRlRHVwbGljYXRlUHJldkNsYXNzOiBcInN3aXBlci1zbGlkZS1kdXBsaWNhdGUtcHJldlwiLCB3cmFwcGVyQ2xhc3M6IFwic3dpcGVyLXdyYXBwZXJcIiwgcnVuQ2FsbGJhY2tzT25Jbml0OiAhMCwgX2VtaXRDbGFzc2VzOiAhMSB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaihlLCB0KSB7IHJldHVybiBmdW5jdGlvbihzKSB7IHZvaWQgMCA9PT0gcyAmJiAocyA9IHt9KTsgY29uc3QgYSA9IE9iamVjdC5rZXlzKHMpWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gc1thXTsgXCJvYmplY3RcIiA9PSB0eXBlb2YgaSAmJiBudWxsICE9PSBpID8gKFtcIm5hdmlnYXRpb25cIiwgXCJwYWdpbmF0aW9uXCIsIFwic2Nyb2xsYmFyXCJdLmluZGV4T2YoYSkgPj0gMCAmJiAhMCA9PT0gZVthXSAmJiAoZVthXSA9IHsgYXV0bzogITAgfSksIGEgaW4gZSAmJiBcImVuYWJsZWRcIiBpbiBpID8gKCEwID09PSBlW2FdICYmIChlW2FdID0geyBlbmFibGVkOiAhMCB9KSwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZVthXSB8fCBcImVuYWJsZWRcIiBpbiBlW2FdIHx8IChlW2FdLmVuYWJsZWQgPSAhMCksIGVbYV0gfHwgKGVbYV0gPSB7IGVuYWJsZWQ6ICExIH0pLCBnKHQsIHMpKSA6IGcodCwgcykpIDogZyh0LCBzKSB9IH0gY29uc3QgXyA9IHsgZXZlbnRzRW1pdHRlcjogJCwgdXBkYXRlOiBTLCB0cmFuc2xhdGU6IE0sIHRyYW5zaXRpb246IHsgc2V0VHJhbnNpdGlvbjogZnVuY3Rpb24oZSwgdCkgeyBjb25zdCBzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMucGFyYW1zLmNzc01vZGUgfHwgcy4kd3JhcHBlckVsLnRyYW5zaXRpb24oZSksIHMuZW1pdChcInNldFRyYW5zaXRpb25cIiwgZSwgdCkgfSwgdHJhbnNpdGlvblN0YXJ0OiBmdW5jdGlvbihlLCB0KSB7IHZvaWQgMCA9PT0gZSAmJiAoZSA9ICEwKTsgY29uc3QgcyA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwYXJhbXM6IGEgfSA9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmNzc01vZGUgfHwgKGEuYXV0b0hlaWdodCAmJiBzLnVwZGF0ZUF1dG9IZWlnaHQoKSwgUCh7IHN3aXBlcjogcywgcnVuQ2FsbGJhY2tzOiBlLCBkaXJlY3Rpb246IHQsIHN0ZXA6IFwiU3RhcnRcIiB9KSkgfSwgdHJhbnNpdGlvbkVuZDogZnVuY3Rpb24oZSwgdCkgeyB2b2lkIDAgPT09IGUgJiYgKGUgPSAhMCk7IGNvbnN0IHMgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcGFyYW1zOiBhIH0gPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5hbmltYXRpbmcgPSAhMSwgYS5jc3NNb2RlIHx8IChzLnNldFRyYW5zaXRpb24oMCksIFAoeyBzd2lwZXI6IHMsIHJ1bkNhbGxiYWNrczogZSwgZGlyZWN0aW9uOiB0LCBzdGVwOiBcIkVuZFwiIH0pKSB9IH0sIHNsaWRlOiBrLCBsb29wOiB6LCBncmFiQ3Vyc29yOiB7IHNldEdyYWJDdXJzb3I6IGZ1bmN0aW9uKGUpIHsgY29uc3QgdCA9IHRoaXM7IGlmICh0LnN1cHBvcnQudG91Y2ggfHwgIXQucGFyYW1zLnNpbXVsYXRlVG91Y2ggfHwgdC5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiB0LmlzTG9ja2VkIHx8IHQucGFyYW1zLmNzc01vZGUpIHJldHVybjsgY29uc3QgcyA9IFwiY29udGFpbmVyXCIgPT09IHQucGFyYW1zLnRvdWNoRXZlbnRzVGFyZ2V0ID8gdC5lbCA6IHQud3JhcHBlckVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdHlsZS5jdXJzb3IgPSBcIm1vdmVcIiwgcy5zdHlsZS5jdXJzb3IgPSBlID8gXCJncmFiYmluZ1wiIDogXCJncmFiXCIgfSwgdW5zZXRHcmFiQ3Vyc29yOiBmdW5jdGlvbigpIHsgY29uc3QgZSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN1cHBvcnQudG91Y2ggfHwgZS5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBlLmlzTG9ja2VkIHx8IGUucGFyYW1zLmNzc01vZGUgfHwgKGVbXCJjb250YWluZXJcIiA9PT0gZS5wYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPyBcImVsXCIgOiBcIndyYXBwZXJFbFwiXS5zdHlsZS5jdXJzb3IgPSBcIlwiKSB9IH0sIGV2ZW50czogWCwgYnJlYWtwb2ludHM6IHsgc2V0QnJlYWtwb2ludDogZnVuY3Rpb24oKSB7IGNvbnN0IGUgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYWN0aXZlSW5kZXg6IHQsIGluaXRpYWxpemVkOiBzLCBsb29wZWRTbGlkZXM6IGEgPSAwLCBwYXJhbXM6IGksICRlbDogciB9ID0gZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gaS5icmVha3BvaW50czsgaWYgKCFuIHx8IG4gJiYgMCA9PT0gT2JqZWN0LmtleXMobikubGVuZ3RoKSByZXR1cm47IGNvbnN0IGwgPSBlLmdldEJyZWFrcG9pbnQobiwgZS5wYXJhbXMuYnJlYWtwb2ludHNCYXNlLCBlLmVsKTsgaWYgKCFsIHx8IGUuY3VycmVudEJyZWFrcG9pbnQgPT09IGwpIHJldHVybjsgY29uc3QgbyA9IChsIGluIG4gPyBuW2xdIDogdm9pZCAwKSB8fCBlLm9yaWdpbmFsUGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBZKGUsIGkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBZKGUsIG8pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBpLmVuYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkICYmICFjID8gKHIucmVtb3ZlQ2xhc3MoYCR7aS5jb250YWluZXJNb2RpZmllckNsYXNzfWdyaWQgJHtpLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZC1jb2x1bW5gKSwgZS5lbWl0Q29udGFpbmVyQ2xhc3NlcygpKSA6ICFkICYmIGMgJiYgKHIuYWRkQ2xhc3MoYCR7aS5jb250YWluZXJNb2RpZmllckNsYXNzfWdyaWRgKSwgKG8uZ3JpZC5maWxsICYmIFwiY29sdW1uXCIgPT09IG8uZ3JpZC5maWxsIHx8ICFvLmdyaWQuZmlsbCAmJiBcImNvbHVtblwiID09PSBpLmdyaWQuZmlsbCkgJiYgci5hZGRDbGFzcyhgJHtpLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZC1jb2x1bW5gKSwgZS5lbWl0Q29udGFpbmVyQ2xhc3NlcygpKSwgW1wibmF2aWdhdGlvblwiLCBcInBhZ2luYXRpb25cIiwgXCJzY3JvbGxiYXJcIl0uZm9yRWFjaCgodCA9PiB7IGNvbnN0IHMgPSBpW3RdICYmIGlbdF0uZW5hYmxlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IG9bdF0gJiYgb1t0XS5lbmFibGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgJiYgIWEgJiYgZVt0XS5kaXNhYmxlKCksICFzICYmIGEgJiYgZVt0XS5lbmFibGUoKSB9KSk7IGNvbnN0IHUgPSBvLmRpcmVjdGlvbiAmJiBvLmRpcmVjdGlvbiAhPT0gaS5kaXJlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9IGkubG9vcCAmJiAoby5zbGlkZXNQZXJWaWV3ICE9PSBpLnNsaWRlc1BlclZpZXcgfHwgdSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ICYmIHMgJiYgZS5jaGFuZ2VEaXJlY3Rpb24oKSwgZyhlLnBhcmFtcywgbyk7IGNvbnN0IG0gPSBlLnBhcmFtcy5lbmFibGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihlLCB7IGFsbG93VG91Y2hNb3ZlOiBlLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSwgYWxsb3dTbGlkZU5leHQ6IGUucGFyYW1zLmFsbG93U2xpZGVOZXh0LCBhbGxvd1NsaWRlUHJldjogZS5wYXJhbXMuYWxsb3dTbGlkZVByZXYgfSksIHAgJiYgIW0gPyBlLmRpc2FibGUoKSA6ICFwICYmIG0gJiYgZS5lbmFibGUoKSwgZS5jdXJyZW50QnJlYWtwb2ludCA9IGwsIGUuZW1pdChcIl9iZWZvcmVCcmVha3BvaW50XCIsIG8pLCBoICYmIHMgJiYgKGUubG9vcERlc3Ryb3koKSwgZS5sb29wQ3JlYXRlKCksIGUudXBkYXRlU2xpZGVzKCksIGUuc2xpZGVUbyh0IC0gYSArIGUubG9vcGVkU2xpZGVzLCAwLCAhMSkpLCBlLmVtaXQoXCJicmVha3BvaW50XCIsIG8pIH0sIGdldEJyZWFrcG9pbnQ6IGZ1bmN0aW9uKGUsIHQsIHMpIHsgaWYgKHZvaWQgMCA9PT0gdCAmJiAodCA9IFwid2luZG93XCIpLCAhZSB8fCBcImNvbnRhaW5lclwiID09PSB0ICYmICFzKSByZXR1cm47IGxldCBhID0gITE7IGNvbnN0IGkgPSByKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IFwid2luZG93XCIgPT09IHQgPyBpLmlubmVySGVpZ2h0IDogcy5jbGllbnRIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IE9iamVjdC5rZXlzKGUpLm1hcCgoZSA9PiB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlICYmIDAgPT09IGUuaW5kZXhPZihcIkBcIikpIHsgY29uc3QgdCA9IHBhcnNlRmxvYXQoZS5zdWJzdHIoMSkpOyByZXR1cm4geyB2YWx1ZTogbiAqIHQsIHBvaW50OiBlIH0gfSByZXR1cm4geyB2YWx1ZTogZSwgcG9pbnQ6IGUgfSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsLnNvcnQoKChlLCB0KSA9PiBwYXJzZUludChlLnZhbHVlLCAxMCkgLSBwYXJzZUludCh0LnZhbHVlLCAxMCkpKTsgZm9yIChsZXQgZSA9IDA7IGUgPCBsLmxlbmd0aDsgZSArPSAxKSB7IGNvbnN0IHsgcG9pbnQ6IHIsIHZhbHVlOiBuIH0gPSBsW2VdOyBcIndpbmRvd1wiID09PSB0ID8gaS5tYXRjaE1lZGlhKGAobWluLXdpZHRoOiAke259cHgpYCkubWF0Y2hlcyAmJiAoYSA9IHIpIDogbiA8PSBzLmNsaWVudFdpZHRoICYmIChhID0gcikgfSByZXR1cm4gYSB8fCBcIm1heFwiIH0gfSwgY2hlY2tPdmVyZmxvdzogeyBjaGVja092ZXJmbG93OiBmdW5jdGlvbigpIHsgY29uc3QgZSA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpc0xvY2tlZDogdCwgcGFyYW1zOiBzIH0gPSBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc2xpZGVzT2Zmc2V0QmVmb3JlOiBhIH0gPSBzOyBpZiAoYSkgeyBjb25zdCB0ID0gZS5zbGlkZXMubGVuZ3RoIC0gMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IGUuc2xpZGVzR3JpZFt0XSArIGUuc2xpZGVzU2l6ZXNHcmlkW3RdICsgMiAqIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5pc0xvY2tlZCA9IGUuc2l6ZSA+IHMgfSBlbHNlIGUuaXNMb2NrZWQgPSAxID09PSBlLnNuYXBHcmlkLmxlbmd0aDshMCA9PT0gcy5hbGxvd1NsaWRlTmV4dCAmJiAoZS5hbGxvd1NsaWRlTmV4dCA9ICFlLmlzTG9ja2VkKSwgITAgPT09IHMuYWxsb3dTbGlkZVByZXYgJiYgKGUuYWxsb3dTbGlkZVByZXYgPSAhZS5pc0xvY2tlZCksIHQgJiYgdCAhPT0gZS5pc0xvY2tlZCAmJiAoZS5pc0VuZCA9ICExKSwgdCAhPT0gZS5pc0xvY2tlZCAmJiBlLmVtaXQoZS5pc0xvY2tlZCA/IFwibG9ja1wiIDogXCJ1bmxvY2tcIikgfSB9LCBjbGFzc2VzOiBSLCBpbWFnZXM6IHsgbG9hZEltYWdlOiBmdW5jdGlvbihlLCB0LCBzLCBhLCBpLCBuKSB7IGNvbnN0IGwgPSByKCk7IGxldCBvO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoKSB7IG4gJiYgbigpIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQoZSkucGFyZW50KFwicGljdHVyZVwiKVswXSB8fCBlLmNvbXBsZXRlICYmIGkgPyBjKCkgOiB0ID8gKG8gPSBuZXcgbC5JbWFnZSwgby5vbmxvYWQgPSBjLCBvLm9uZXJyb3IgPSBjLCBhICYmIChvLnNpemVzID0gYSksIHMgJiYgKG8uc3Jjc2V0ID0gcyksIHQgJiYgKG8uc3JjID0gdCkpIDogYygpIH0sIHByZWxvYWRJbWFnZXM6IGZ1bmN0aW9uKCkgeyBjb25zdCBlID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0KCkgeyBudWxsICE9IGUgJiYgZSAmJiAhZS5kZXN0cm95ZWQgJiYgKHZvaWQgMCAhPT0gZS5pbWFnZXNMb2FkZWQgJiYgKGUuaW1hZ2VzTG9hZGVkICs9IDEpLCBlLmltYWdlc0xvYWRlZCA9PT0gZS5pbWFnZXNUb0xvYWQubGVuZ3RoICYmIChlLnBhcmFtcy51cGRhdGVPbkltYWdlc1JlYWR5ICYmIGUudXBkYXRlKCksIGUuZW1pdChcImltYWdlc1JlYWR5XCIpKSkgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5pbWFnZXNUb0xvYWQgPSBlLiRlbC5maW5kKFwiaW1nXCIpOyBmb3IgKGxldCBzID0gMDsgcyA8IGUuaW1hZ2VzVG9Mb2FkLmxlbmd0aDsgcyArPSAxKSB7IGNvbnN0IGEgPSBlLmltYWdlc1RvTG9hZFtzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmxvYWRJbWFnZShhLCBhLmN1cnJlbnRTcmMgfHwgYS5nZXRBdHRyaWJ1dGUoXCJzcmNcIiksIGEuc3Jjc2V0IHx8IGEuZ2V0QXR0cmlidXRlKFwic3Jjc2V0XCIpLCBhLnNpemVzIHx8IGEuZ2V0QXR0cmlidXRlKFwic2l6ZXNcIiksICEwLCB0KSB9IH0gfSB9LFxyXG4gICAgICAgICAgICAgICAgcSA9IHt9O1xyXG4gICAgICAgICAgICBjbGFzcyBWIHsgY29uc3RydWN0b3IoKSB7IGxldCBlLCB0OyBmb3IgKHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCwgYSA9IG5ldyBBcnJheShzKSwgaSA9IDA7IGkgPCBzOyBpKyspIGFbaV0gPSBhcmd1bWVudHNbaV07IGlmICgxID09PSBhLmxlbmd0aCAmJiBhWzBdLmNvbnN0cnVjdG9yICYmIFwiT2JqZWN0XCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhWzBdKS5zbGljZSg4LCAtMSkgPyB0ID0gYVswXSA6IFtlLCB0XSA9IGEsIHQgfHwgKHQgPSB7fSksIHQgPSBnKHt9LCB0KSwgZSAmJiAhdC5lbCAmJiAodC5lbCA9IGUpLCB0LmVsICYmIGQodC5lbCkubGVuZ3RoID4gMSkgeyBjb25zdCBlID0gW107IHJldHVybiBkKHQuZWwpLmVhY2goKHMgPT4geyBjb25zdCBhID0gZyh7fSwgdCwgeyBlbDogcyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHVzaChuZXcgVihhKSkgfSkpLCBlIH0gY29uc3QgciA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgci5fX3N3aXBlcl9fID0gITAsIHIuc3VwcG9ydCA9IEUoKSwgci5kZXZpY2UgPSBDKHsgdXNlckFnZW50OiB0LnVzZXJBZ2VudCB9KSwgci5icm93c2VyID0gVCgpLCByLmV2ZW50c0xpc3RlbmVycyA9IHt9LCByLmV2ZW50c0FueUxpc3RlbmVycyA9IFtdLCByLm1vZHVsZXMgPSBbLi4uci5fX21vZHVsZXNfX10sIHQubW9kdWxlcyAmJiBBcnJheS5pc0FycmF5KHQubW9kdWxlcykgJiYgci5tb2R1bGVzLnB1c2goLi4udC5tb2R1bGVzKTsgY29uc3QgbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHIubW9kdWxlcy5mb3JFYWNoKChlID0+IHsgZSh7IHN3aXBlcjogciwgZXh0ZW5kUGFyYW1zOiBqKHQsIG4pLCBvbjogci5vbi5iaW5kKHIpLCBvbmNlOiByLm9uY2UuYmluZChyKSwgb2ZmOiByLm9mZi5iaW5kKHIpLCBlbWl0OiByLmVtaXQuYmluZChyKSB9KSB9KSk7IGNvbnN0IGwgPSBnKHt9LCBXLCBuKTsgcmV0dXJuIHIucGFyYW1zID0gZyh7fSwgbCwgcSwgdCksIHIub3JpZ2luYWxQYXJhbXMgPSBnKHt9LCByLnBhcmFtcyksIHIucGFzc2VkUGFyYW1zID0gZyh7fSwgdCksIHIucGFyYW1zICYmIHIucGFyYW1zLm9uICYmIE9iamVjdC5rZXlzKHIucGFyYW1zLm9uKS5mb3JFYWNoKChlID0+IHsgci5vbihlLCByLnBhcmFtcy5vbltlXSkgfSkpLCByLnBhcmFtcyAmJiByLnBhcmFtcy5vbkFueSAmJiByLm9uQW55KHIucGFyYW1zLm9uQW55KSwgci4kID0gZCwgT2JqZWN0LmFzc2lnbihyLCB7IGVuYWJsZWQ6IHIucGFyYW1zLmVuYWJsZWQsIGVsOiBlLCBjbGFzc05hbWVzOiBbXSwgc2xpZGVzOiBkKCksIHNsaWRlc0dyaWQ6IFtdLCBzbmFwR3JpZDogW10sIHNsaWRlc1NpemVzR3JpZDogW10sIGlzSG9yaXpvbnRhbDogKCkgPT4gXCJob3Jpem9udGFsXCIgPT09IHIucGFyYW1zLmRpcmVjdGlvbiwgaXNWZXJ0aWNhbDogKCkgPT4gXCJ2ZXJ0aWNhbFwiID09PSByLnBhcmFtcy5kaXJlY3Rpb24sIGFjdGl2ZUluZGV4OiAwLCByZWFsSW5kZXg6IDAsIGlzQmVnaW5uaW5nOiAhMCwgaXNFbmQ6ICExLCB0cmFuc2xhdGU6IDAsIHByZXZpb3VzVHJhbnNsYXRlOiAwLCBwcm9ncmVzczogMCwgdmVsb2NpdHk6IDAsIGFuaW1hdGluZzogITEsIGFsbG93U2xpZGVOZXh0OiByLnBhcmFtcy5hbGxvd1NsaWRlTmV4dCwgYWxsb3dTbGlkZVByZXY6IHIucGFyYW1zLmFsbG93U2xpZGVQcmV2LCB0b3VjaEV2ZW50czogZnVuY3Rpb24oKSB7IGNvbnN0IGUgPSBbXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hlbmRcIiwgXCJ0b3VjaGNhbmNlbFwiXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gW1wicG9pbnRlcmRvd25cIiwgXCJwb2ludGVybW92ZVwiLCBcInBvaW50ZXJ1cFwiXTsgcmV0dXJuIHIudG91Y2hFdmVudHNUb3VjaCA9IHsgc3RhcnQ6IGVbMF0sIG1vdmU6IGVbMV0sIGVuZDogZVsyXSwgY2FuY2VsOiBlWzNdIH0sIHIudG91Y2hFdmVudHNEZXNrdG9wID0geyBzdGFydDogdFswXSwgbW92ZTogdFsxXSwgZW5kOiB0WzJdIH0sIHIuc3VwcG9ydC50b3VjaCB8fCAhci5wYXJhbXMuc2ltdWxhdGVUb3VjaCA/IHIudG91Y2hFdmVudHNUb3VjaCA6IHIudG91Y2hFdmVudHNEZXNrdG9wIH0oKSwgdG91Y2hFdmVudHNEYXRhOiB7IGlzVG91Y2hlZDogdm9pZCAwLCBpc01vdmVkOiB2b2lkIDAsIGFsbG93VG91Y2hDYWxsYmFja3M6IHZvaWQgMCwgdG91Y2hTdGFydFRpbWU6IHZvaWQgMCwgaXNTY3JvbGxpbmc6IHZvaWQgMCwgY3VycmVudFRyYW5zbGF0ZTogdm9pZCAwLCBzdGFydFRyYW5zbGF0ZTogdm9pZCAwLCBhbGxvd1RocmVzaG9sZE1vdmU6IHZvaWQgMCwgZm9jdXNhYmxlRWxlbWVudHM6IHIucGFyYW1zLmZvY3VzYWJsZUVsZW1lbnRzLCBsYXN0Q2xpY2tUaW1lOiB1KCksIGNsaWNrVGltZW91dDogdm9pZCAwLCB2ZWxvY2l0aWVzOiBbXSwgYWxsb3dNb21lbnR1bUJvdW5jZTogdm9pZCAwLCBpc1RvdWNoRXZlbnQ6IHZvaWQgMCwgc3RhcnRNb3Zpbmc6IHZvaWQgMCB9LCBhbGxvd0NsaWNrOiAhMCwgYWxsb3dUb3VjaE1vdmU6IHIucGFyYW1zLmFsbG93VG91Y2hNb3ZlLCB0b3VjaGVzOiB7IHN0YXJ0WDogMCwgc3RhcnRZOiAwLCBjdXJyZW50WDogMCwgY3VycmVudFk6IDAsIGRpZmY6IDAgfSwgaW1hZ2VzVG9Mb2FkOiBbXSwgaW1hZ2VzTG9hZGVkOiAwIH0pLCByLmVtaXQoXCJfc3dpcGVyXCIpLCByLnBhcmFtcy5pbml0ICYmIHIuaW5pdCgpLCByIH1cclxuICAgICAgICAgICAgICAgIGVuYWJsZSgpIHsgY29uc3QgZSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5lbmFibGVkIHx8IChlLmVuYWJsZWQgPSAhMCwgZS5wYXJhbXMuZ3JhYkN1cnNvciAmJiBlLnNldEdyYWJDdXJzb3IoKSwgZS5lbWl0KFwiZW5hYmxlXCIpKSB9XHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlKCkgeyBjb25zdCBlID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBlLmVuYWJsZWQgJiYgKGUuZW5hYmxlZCA9ICExLCBlLnBhcmFtcy5ncmFiQ3Vyc29yICYmIGUudW5zZXRHcmFiQ3Vyc29yKCksIGUuZW1pdChcImRpc2FibGVcIikpIH1cclxuICAgICAgICAgICAgICAgIHNldFByb2dyZXNzKGUsIHQpIHsgY29uc3QgcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IE1hdGgubWluKE1hdGgubWF4KGUsIDApLCAxKTsgY29uc3QgYSA9IHMubWluVHJhbnNsYXRlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAocy5tYXhUcmFuc2xhdGUoKSAtIGEpICogZSArIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgcy50cmFuc2xhdGVUbyhpLCB2b2lkIDAgPT09IHQgPyAwIDogdCksIHMudXBkYXRlQWN0aXZlSW5kZXgoKSwgcy51cGRhdGVTbGlkZXNDbGFzc2VzKCkgfVxyXG4gICAgICAgICAgICAgICAgZW1pdENvbnRhaW5lckNsYXNzZXMoKSB7IGNvbnN0IGUgPSB0aGlzOyBpZiAoIWUucGFyYW1zLl9lbWl0Q2xhc3NlcyB8fCAhZS5lbCkgcmV0dXJuOyBjb25zdCB0ID0gZS5lbC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpLmZpbHRlcigodCA9PiAwID09PSB0LmluZGV4T2YoXCJzd2lwZXJcIikgfHwgMCA9PT0gdC5pbmRleE9mKGUucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5lbWl0KFwiX2NvbnRhaW5lckNsYXNzZXNcIiwgdC5qb2luKFwiIFwiKSkgfVxyXG4gICAgICAgICAgICAgICAgZ2V0U2xpZGVDbGFzc2VzKGUpIHsgY29uc3QgdCA9IHRoaXM7IHJldHVybiB0LmRlc3Ryb3llZCA/IFwiXCIgOiBlLmNsYXNzTmFtZS5zcGxpdChcIiBcIikuZmlsdGVyKChlID0+IDAgPT09IGUuaW5kZXhPZihcInN3aXBlci1zbGlkZVwiKSB8fCAwID09PSBlLmluZGV4T2YodC5wYXJhbXMuc2xpZGVDbGFzcykpKS5qb2luKFwiIFwiKSB9XHJcbiAgICAgICAgICAgICAgICBlbWl0U2xpZGVzQ2xhc3NlcygpIHsgY29uc3QgZSA9IHRoaXM7IGlmICghZS5wYXJhbXMuX2VtaXRDbGFzc2VzIHx8ICFlLmVsKSByZXR1cm47IGNvbnN0IHQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBlLnNsaWRlcy5lYWNoKChzID0+IHsgY29uc3QgYSA9IGUuZ2V0U2xpZGVDbGFzc2VzKHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0LnB1c2goeyBzbGlkZUVsOiBzLCBjbGFzc05hbWVzOiBhIH0pLCBlLmVtaXQoXCJfc2xpZGVDbGFzc1wiLCBzLCBhKSB9KSksIGUuZW1pdChcIl9zbGlkZUNsYXNzZXNcIiwgdCkgfVxyXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyVmlld0R5bmFtaWMoZSwgdCkgeyB2b2lkIDAgPT09IGUgJiYgKGUgPSBcImN1cnJlbnRcIiksIHZvaWQgMCA9PT0gdCAmJiAodCA9ICExKTsgY29uc3QgeyBwYXJhbXM6IHMsIHNsaWRlczogYSwgc2xpZGVzR3JpZDogaSwgc2xpZGVzU2l6ZXNHcmlkOiByLCBzaXplOiBuLCBhY3RpdmVJbmRleDogbCB9ID0gdGhpczsgbGV0IG8gPSAxOyBpZiAocy5jZW50ZXJlZFNsaWRlcykgeyBsZXQgZSwgdCA9IGFbbF0uc3dpcGVyU2xpZGVTaXplOyBmb3IgKGxldCBzID0gbCArIDE7IHMgPCBhLmxlbmd0aDsgcyArPSAxKSBhW3NdICYmICFlICYmICh0ICs9IGFbc10uc3dpcGVyU2xpZGVTaXplLCBvICs9IDEsIHQgPiBuICYmIChlID0gITApKTsgZm9yIChsZXQgcyA9IGwgLSAxOyBzID49IDA7IHMgLT0gMSkgYVtzXSAmJiAhZSAmJiAodCArPSBhW3NdLnN3aXBlclNsaWRlU2l6ZSwgbyArPSAxLCB0ID4gbiAmJiAoZSA9ICEwKSkgfSBlbHNlIGlmIChcImN1cnJlbnRcIiA9PT0gZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IGwgKyAxOyBlIDwgYS5sZW5ndGg7IGUgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHQgPyBpW2VdICsgcltlXSAtIGlbbF0gPCBuIDogaVtlXSAtIGlbbF0gPCBuKSAmJiAobyArPSAxKSB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGUgPSBsIC0gMTsgZSA+PSAwOyBlIC09IDEpIHsgaVtsXSAtIGlbZV0gPCBuICYmIChvICs9IDEpIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbyB9XHJcbiAgICAgICAgICAgICAgICB1cGRhdGUoKSB7IGNvbnN0IGUgPSB0aGlzOyBpZiAoIWUgfHwgZS5kZXN0cm95ZWQpIHJldHVybjsgY29uc3QgeyBzbmFwR3JpZDogdCwgcGFyYW1zOiBzIH0gPSBlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhKCkgeyBjb25zdCB0ID0gZS5ydGxUcmFuc2xhdGUgPyAtMSAqIGUudHJhbnNsYXRlIDogZS50cmFuc2xhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gTWF0aC5taW4oTWF0aC5tYXgodCwgZS5tYXhUcmFuc2xhdGUoKSksIGUubWluVHJhbnNsYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNldFRyYW5zbGF0ZShzKSwgZS51cGRhdGVBY3RpdmVJbmRleCgpLCBlLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSB9IGxldCBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHMuYnJlYWtwb2ludHMgJiYgZS5zZXRCcmVha3BvaW50KCksIGUudXBkYXRlU2l6ZSgpLCBlLnVwZGF0ZVNsaWRlcygpLCBlLnVwZGF0ZVByb2dyZXNzKCksIGUudXBkYXRlU2xpZGVzQ2xhc3NlcygpLCBlLnBhcmFtcy5mcmVlTW9kZSAmJiBlLnBhcmFtcy5mcmVlTW9kZS5lbmFibGVkID8gKGEoKSwgZS5wYXJhbXMuYXV0b0hlaWdodCAmJiBlLnVwZGF0ZUF1dG9IZWlnaHQoKSkgOiAoaSA9IChcImF1dG9cIiA9PT0gZS5wYXJhbXMuc2xpZGVzUGVyVmlldyB8fCBlLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkgJiYgZS5pc0VuZCAmJiAhZS5wYXJhbXMuY2VudGVyZWRTbGlkZXMgPyBlLnNsaWRlVG8oZS5zbGlkZXMubGVuZ3RoIC0gMSwgMCwgITEsICEwKSA6IGUuc2xpZGVUbyhlLmFjdGl2ZUluZGV4LCAwLCAhMSwgITApLCBpIHx8IGEoKSksIHMud2F0Y2hPdmVyZmxvdyAmJiB0ICE9PSBlLnNuYXBHcmlkICYmIGUuY2hlY2tPdmVyZmxvdygpLCBlLmVtaXQoXCJ1cGRhdGVcIikgfVxyXG4gICAgICAgICAgICAgICAgY2hhbmdlRGlyZWN0aW9uKGUsIHQpIHsgdm9pZCAwID09PSB0ICYmICh0ID0gITApOyBjb25zdCBzID0gdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHMucGFyYW1zLmRpcmVjdGlvbjsgcmV0dXJuIGUgfHwgKGUgPSBcImhvcml6b250YWxcIiA9PT0gYSA/IFwidmVydGljYWxcIiA6IFwiaG9yaXpvbnRhbFwiKSwgZSA9PT0gYSB8fCBcImhvcml6b250YWxcIiAhPT0gZSAmJiBcInZlcnRpY2FsXCIgIT09IGUgfHwgKHMuJGVsLnJlbW92ZUNsYXNzKGAke3MucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9JHthfWApLmFkZENsYXNzKGAke3MucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9JHtlfWApLCBzLmVtaXRDb250YWluZXJDbGFzc2VzKCksIHMucGFyYW1zLmRpcmVjdGlvbiA9IGUsIHMuc2xpZGVzLmVhY2goKHQgPT4geyBcInZlcnRpY2FsXCIgPT09IGUgPyB0LnN0eWxlLndpZHRoID0gXCJcIiA6IHQuc3R5bGUuaGVpZ2h0ID0gXCJcIiB9KSksIHMuZW1pdChcImNoYW5nZURpcmVjdGlvblwiKSwgdCAmJiBzLnVwZGF0ZSgpKSwgcyB9XHJcbiAgICAgICAgICAgICAgICBtb3VudChlKSB7IGNvbnN0IHQgPSB0aGlzOyBpZiAodC5tb3VudGVkKSByZXR1cm4gITA7IGNvbnN0IHMgPSBkKGUgfHwgdC5wYXJhbXMuZWwpOyBpZiAoIShlID0gc1swXSkpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgICAgICAgICBlLnN3aXBlciA9IHQ7IGNvbnN0IGkgPSAoKSA9PiBgLiR7KHQucGFyYW1zLndyYXBwZXJDbGFzc3x8XCJcIikudHJpbSgpLnNwbGl0KFwiIFwiKS5qb2luKFwiLlwiKX1gOyBsZXQgciA9ICgoKSA9PiB7IGlmIChlICYmIGUuc2hhZG93Um9vdCAmJiBlLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcikgeyBjb25zdCB0ID0gZChlLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihpKCkpKTsgcmV0dXJuIHQuY2hpbGRyZW4gPSBlID0+IHMuY2hpbGRyZW4oZSksIHQgfSByZXR1cm4gcy5jaGlsZHJlbiA/IHMuY2hpbGRyZW4oaSgpKSA6IGQocykuY2hpbGRyZW4oaSgpKSB9KSgpOyBpZiAoMCA9PT0gci5sZW5ndGggJiYgdC5wYXJhbXMuY3JlYXRlRWxlbWVudHMpIHsgY29uc3QgZSA9IGEoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gZChlKSwgZS5jbGFzc05hbWUgPSB0LnBhcmFtcy53cmFwcGVyQ2xhc3MsIHMuYXBwZW5kKGUpLCBzLmNoaWxkcmVuKGAuJHt0LnBhcmFtcy5zbGlkZUNsYXNzfWApLmVhY2goKGUgPT4geyByLmFwcGVuZChlKSB9KSkgfSByZXR1cm4gT2JqZWN0LmFzc2lnbih0LCB7ICRlbDogcywgZWw6IGUsICR3cmFwcGVyRWw6IHIsIHdyYXBwZXJFbDogclswXSwgbW91bnRlZDogITAsIHJ0bDogXCJydGxcIiA9PT0gZS5kaXIudG9Mb3dlckNhc2UoKSB8fCBcInJ0bFwiID09PSBzLmNzcyhcImRpcmVjdGlvblwiKSwgcnRsVHJhbnNsYXRlOiBcImhvcml6b250YWxcIiA9PT0gdC5wYXJhbXMuZGlyZWN0aW9uICYmIChcInJ0bFwiID09PSBlLmRpci50b0xvd2VyQ2FzZSgpIHx8IFwicnRsXCIgPT09IHMuY3NzKFwiZGlyZWN0aW9uXCIpKSwgd3JvbmdSVEw6IFwiLXdlYmtpdC1ib3hcIiA9PT0gci5jc3MoXCJkaXNwbGF5XCIpIH0pLCAhMCB9XHJcbiAgICAgICAgICAgICAgICBpbml0KGUpIHsgY29uc3QgdCA9IHRoaXM7IGlmICh0LmluaXRpYWxpemVkKSByZXR1cm4gdDsgcmV0dXJuICExID09PSB0Lm1vdW50KGUpIHx8ICh0LmVtaXQoXCJiZWZvcmVJbml0XCIpLCB0LnBhcmFtcy5icmVha3BvaW50cyAmJiB0LnNldEJyZWFrcG9pbnQoKSwgdC5hZGRDbGFzc2VzKCksIHQucGFyYW1zLmxvb3AgJiYgdC5sb29wQ3JlYXRlKCksIHQudXBkYXRlU2l6ZSgpLCB0LnVwZGF0ZVNsaWRlcygpLCB0LnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHQuY2hlY2tPdmVyZmxvdygpLCB0LnBhcmFtcy5ncmFiQ3Vyc29yICYmIHQuZW5hYmxlZCAmJiB0LnNldEdyYWJDdXJzb3IoKSwgdC5wYXJhbXMucHJlbG9hZEltYWdlcyAmJiB0LnByZWxvYWRJbWFnZXMoKSwgdC5wYXJhbXMubG9vcCA/IHQuc2xpZGVUbyh0LnBhcmFtcy5pbml0aWFsU2xpZGUgKyB0Lmxvb3BlZFNsaWRlcywgMCwgdC5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0LCAhMSwgITApIDogdC5zbGlkZVRvKHQucGFyYW1zLmluaXRpYWxTbGlkZSwgMCwgdC5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0LCAhMSwgITApLCB0LmF0dGFjaEV2ZW50cygpLCB0LmluaXRpYWxpemVkID0gITAsIHQuZW1pdChcImluaXRcIiksIHQuZW1pdChcImFmdGVySW5pdFwiKSksIHQgfVxyXG4gICAgICAgICAgICAgICAgZGVzdHJveShlLCB0KSB7IHZvaWQgMCA9PT0gZSAmJiAoZSA9ICEwKSwgdm9pZCAwID09PSB0ICYmICh0ID0gITApOyBjb25zdCBzID0gdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwYXJhbXM6IGEsICRlbDogaSwgJHdyYXBwZXJFbDogciwgc2xpZGVzOiBuIH0gPSBzOyByZXR1cm4gdm9pZCAwID09PSBzLnBhcmFtcyB8fCBzLmRlc3Ryb3llZCB8fCAocy5lbWl0KFwiYmVmb3JlRGVzdHJveVwiKSwgcy5pbml0aWFsaXplZCA9ICExLCBzLmRldGFjaEV2ZW50cygpLCBhLmxvb3AgJiYgcy5sb29wRGVzdHJveSgpLCB0ICYmIChzLnJlbW92ZUNsYXNzZXMoKSwgaS5yZW1vdmVBdHRyKFwic3R5bGVcIiksIHIucmVtb3ZlQXR0cihcInN0eWxlXCIpLCBuICYmIG4ubGVuZ3RoICYmIG4ucmVtb3ZlQ2xhc3MoW2Euc2xpZGVWaXNpYmxlQ2xhc3MsIGEuc2xpZGVBY3RpdmVDbGFzcywgYS5zbGlkZU5leHRDbGFzcywgYS5zbGlkZVByZXZDbGFzc10uam9pbihcIiBcIikpLnJlbW92ZUF0dHIoXCJzdHlsZVwiKS5yZW1vdmVBdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikpLCBzLmVtaXQoXCJkZXN0cm95XCIpLCBPYmplY3Qua2V5cyhzLmV2ZW50c0xpc3RlbmVycykuZm9yRWFjaCgoZSA9PiB7IHMub2ZmKGUpIH0pKSwgITEgIT09IGUgJiYgKHMuJGVsWzBdLnN3aXBlciA9IG51bGwsIGZ1bmN0aW9uKGUpIHsgY29uc3QgdCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHQpLmZvckVhY2goKGUgPT4geyB0cnkgeyB0W2VdID0gbnVsbCB9IGNhdGNoIChlKSB7fSB0cnkgeyBkZWxldGUgdFtlXSB9IGNhdGNoIChlKSB7fSB9KSkgfShzKSksIHMuZGVzdHJveWVkID0gITApLCBudWxsIH1cclxuICAgICAgICAgICAgICAgIHN0YXRpYyBleHRlbmREZWZhdWx0cyhlKSB7IGcocSwgZSkgfVxyXG4gICAgICAgICAgICAgICAgc3RhdGljIGdldCBleHRlbmRlZERlZmF1bHRzKCkgeyByZXR1cm4gcSB9XHJcbiAgICAgICAgICAgICAgICBzdGF0aWMgZ2V0IGRlZmF1bHRzKCkgeyByZXR1cm4gVyB9XHJcbiAgICAgICAgICAgICAgICBzdGF0aWMgaW5zdGFsbE1vZHVsZShlKSB7IFYucHJvdG90eXBlLl9fbW9kdWxlc19fIHx8IChWLnByb3RvdHlwZS5fX21vZHVsZXNfXyA9IFtdKTsgY29uc3QgdCA9IFYucHJvdG90eXBlLl9fbW9kdWxlc19fOyBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgJiYgdC5pbmRleE9mKGUpIDwgMCAmJiB0LnB1c2goZSkgfVxyXG4gICAgICAgICAgICAgICAgc3RhdGljIHVzZShlKSB7IHJldHVybiBBcnJheS5pc0FycmF5KGUpID8gKGUuZm9yRWFjaCgoZSA9PiBWLmluc3RhbGxNb2R1bGUoZSkpKSwgVikgOiAoVi5pbnN0YWxsTW9kdWxlKGUpLCBWKSB9IH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEYoZSwgdCwgcywgaSkgeyBjb25zdCByID0gYSgpOyByZXR1cm4gZS5wYXJhbXMuY3JlYXRlRWxlbWVudHMgJiYgT2JqZWN0LmtleXMoaSkuZm9yRWFjaCgoYSA9PiB7IGlmICghc1thXSAmJiAhMCA9PT0gcy5hdXRvKSB7IGxldCBuID0gZS4kZWwuY2hpbGRyZW4oYC4ke2lbYV19YClbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gfHwgKG4gPSByLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIG4uY2xhc3NOYW1lID0gaVthXSwgZS4kZWwuYXBwZW5kKG4pKSwgc1thXSA9IG4sIHRbYV0gPSBuIH0gfSkpLCBzIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFUoZSkgeyByZXR1cm4gdm9pZCAwID09PSBlICYmIChlID0gXCJcIiksIGAuJHtlLnRyaW0oKS5yZXBsYWNlKC8oW1xcLjohXFwvXSkvZyxcIlxcXFwkMVwiKS5yZXBsYWNlKC8gL2csXCIuXCIpfWAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gSyhlKSB7IGNvbnN0IHQgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgJHdyYXBwZXJFbDogcywgcGFyYW1zOiBhIH0gPSB0OyBpZiAoYS5sb29wICYmIHQubG9vcERlc3Ryb3koKSwgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiBcImxlbmd0aFwiIGluIGUpXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCArPSAxKSBlW3RdICYmIHMuYXBwZW5kKGVbdF0pO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBzLmFwcGVuZChlKTtcclxuICAgICAgICAgICAgICAgIGEubG9vcCAmJiB0Lmxvb3BDcmVhdGUoKSwgYS5vYnNlcnZlciB8fCB0LnVwZGF0ZSgpIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFooZSkgeyBjb25zdCB0ID0gdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICB7IHBhcmFtczogcywgJHdyYXBwZXJFbDogYSwgYWN0aXZlSW5kZXg6IGkgfSA9IHQ7XHJcbiAgICAgICAgICAgICAgICBzLmxvb3AgJiYgdC5sb29wRGVzdHJveSgpOyBsZXQgciA9IGkgKyAxOyBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiBcImxlbmd0aFwiIGluIGUpIHsgZm9yIChsZXQgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCArPSAxKSBlW3RdICYmIGEucHJlcGVuZChlW3RdKTtcclxuICAgICAgICAgICAgICAgICAgICByID0gaSArIGUubGVuZ3RoIH0gZWxzZSBhLnByZXBlbmQoZSk7XHJcbiAgICAgICAgICAgICAgICBzLmxvb3AgJiYgdC5sb29wQ3JlYXRlKCksIHMub2JzZXJ2ZXIgfHwgdC51cGRhdGUoKSwgdC5zbGlkZVRvKHIsIDAsICExKSB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBRKGUsIHQpIHsgY29uc3QgcyA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgeyAkd3JhcHBlckVsOiBhLCBwYXJhbXM6IGksIGFjdGl2ZUluZGV4OiByIH0gPSBzOyBsZXQgbiA9IHI7XHJcbiAgICAgICAgICAgICAgICBpLmxvb3AgJiYgKG4gLT0gcy5sb29wZWRTbGlkZXMsIHMubG9vcERlc3Ryb3koKSwgcy5zbGlkZXMgPSBhLmNoaWxkcmVuKGAuJHtpLnNsaWRlQ2xhc3N9YCkpOyBjb25zdCBsID0gcy5zbGlkZXMubGVuZ3RoOyBpZiAoZSA8PSAwKSByZXR1cm4gdm9pZCBzLnByZXBlbmRTbGlkZSh0KTsgaWYgKGUgPj0gbCkgcmV0dXJuIHZvaWQgcy5hcHBlbmRTbGlkZSh0KTsgbGV0IG8gPSBuID4gZSA/IG4gKyAxIDogbjsgY29uc3QgZCA9IFtdOyBmb3IgKGxldCB0ID0gbCAtIDE7IHQgPj0gZTsgdCAtPSAxKSB7IGNvbnN0IGUgPSBzLnNsaWRlcy5lcSh0KTtcclxuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZSgpLCBkLnVuc2hpZnQoZSkgfSBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiBcImxlbmd0aFwiIGluIHQpIHsgZm9yIChsZXQgZSA9IDA7IGUgPCB0Lmxlbmd0aDsgZSArPSAxKSB0W2VdICYmIGEuYXBwZW5kKHRbZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG8gPSBuID4gZSA/IG4gKyB0Lmxlbmd0aCA6IG4gfSBlbHNlIGEuYXBwZW5kKHQpOyBmb3IgKGxldCBlID0gMDsgZSA8IGQubGVuZ3RoOyBlICs9IDEpIGEuYXBwZW5kKGRbZV0pO1xyXG4gICAgICAgICAgICAgICAgaS5sb29wICYmIHMubG9vcENyZWF0ZSgpLCBpLm9ic2VydmVyIHx8IHMudXBkYXRlKCksIGkubG9vcCA/IHMuc2xpZGVUbyhvICsgcy5sb29wZWRTbGlkZXMsIDAsICExKSA6IHMuc2xpZGVUbyhvLCAwLCAhMSkgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gSihlKSB7IGNvbnN0IHQgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgcGFyYW1zOiBzLCAkd3JhcHBlckVsOiBhLCBhY3RpdmVJbmRleDogaSB9ID0gdDsgbGV0IHIgPSBpO1xyXG4gICAgICAgICAgICAgICAgcy5sb29wICYmIChyIC09IHQubG9vcGVkU2xpZGVzLCB0Lmxvb3BEZXN0cm95KCksIHQuc2xpZGVzID0gYS5jaGlsZHJlbihgLiR7cy5zbGlkZUNsYXNzfWApKTsgbGV0IG4sIGwgPSByOyBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiBcImxlbmd0aFwiIGluIGUpIHsgZm9yIChsZXQgcyA9IDA7IHMgPCBlLmxlbmd0aDsgcyArPSAxKSBuID0gZVtzXSwgdC5zbGlkZXNbbl0gJiYgdC5zbGlkZXMuZXEobikucmVtb3ZlKCksIG4gPCBsICYmIChsIC09IDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGwgPSBNYXRoLm1heChsLCAwKSB9IGVsc2UgbiA9IGUsIHQuc2xpZGVzW25dICYmIHQuc2xpZGVzLmVxKG4pLnJlbW92ZSgpLCBuIDwgbCAmJiAobCAtPSAxKSwgbCA9IE1hdGgubWF4KGwsIDApO1xyXG4gICAgICAgICAgICAgICAgcy5sb29wICYmIHQubG9vcENyZWF0ZSgpLCBzLm9ic2VydmVyIHx8IHQudXBkYXRlKCksIHMubG9vcCA/IHQuc2xpZGVUbyhsICsgdC5sb29wZWRTbGlkZXMsIDAsICExKSA6IHQuc2xpZGVUbyhsLCAwLCAhMSkgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZWUoKSB7IGNvbnN0IGUgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSBbXTsgZm9yIChsZXQgcyA9IDA7IHMgPCBlLnNsaWRlcy5sZW5ndGg7IHMgKz0gMSkgdC5wdXNoKHMpO1xyXG4gICAgICAgICAgICAgICAgZS5yZW1vdmVTbGlkZSh0KSB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiB0ZShlKSB7IGNvbnN0IHsgZWZmZWN0OiB0LCBzd2lwZXI6IHMsIG9uOiBhLCBzZXRUcmFuc2xhdGU6IGksIHNldFRyYW5zaXRpb246IHIsIG92ZXJ3cml0ZVBhcmFtczogbiwgcGVyc3BlY3RpdmU6IGwsIHJlY3JlYXRlU2hhZG93czogbywgZ2V0RWZmZWN0UGFyYW1zOiBkIH0gPSBlOyBsZXQgYztcclxuICAgICAgICAgICAgICAgIGEoXCJiZWZvcmVJbml0XCIsICgoKSA9PiB7IGlmIChzLnBhcmFtcy5lZmZlY3QgIT09IHQpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBzLmNsYXNzTmFtZXMucHVzaChgJHtzLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfSR7dH1gKSwgbCAmJiBsKCkgJiYgcy5jbGFzc05hbWVzLnB1c2goYCR7cy5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc30zZGApOyBjb25zdCBlID0gbiA/IG4oKSA6IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocy5wYXJhbXMsIGUpLCBPYmplY3QuYXNzaWduKHMub3JpZ2luYWxQYXJhbXMsIGUpIH0pKSwgYShcInNldFRyYW5zbGF0ZVwiLCAoKCkgPT4geyBzLnBhcmFtcy5lZmZlY3QgPT09IHQgJiYgaSgpIH0pKSwgYShcInNldFRyYW5zaXRpb25cIiwgKChlLCBhKSA9PiB7IHMucGFyYW1zLmVmZmVjdCA9PT0gdCAmJiByKGEpIH0pKSwgYShcInRyYW5zaXRpb25FbmRcIiwgKCgpID0+IHsgaWYgKHMucGFyYW1zLmVmZmVjdCA9PT0gdCAmJiBvKSB7IGlmICghZCB8fCAhZCgpLnNsaWRlU2hhZG93cykgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzLnNsaWRlcy5lYWNoKChlID0+IHsgcy4kKGUpLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AsIC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0LCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20sIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnRcIikucmVtb3ZlKCkgfSkpLCBvKCkgfSB9KSksIGEoXCJ2aXJ0dWFsVXBkYXRlXCIsICgoKSA9PiB7IHMucGFyYW1zLmVmZmVjdCA9PT0gdCAmJiAocy5zbGlkZXMubGVuZ3RoIHx8IChjID0gITApLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCgpID0+IHsgYyAmJiBzLnNsaWRlcyAmJiBzLnNsaWRlcy5sZW5ndGggJiYgKGkoKSwgYyA9ICExKSB9KSkpIH0pKSB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzZShlLCB0KSB7IHJldHVybiBlLnRyYW5zZm9ybUVsID8gdC5maW5kKGUudHJhbnNmb3JtRWwpLmNzcyh7IFwiYmFja2ZhY2UtdmlzaWJpbGl0eVwiOiBcImhpZGRlblwiLCBcIi13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eVwiOiBcImhpZGRlblwiIH0pIDogdCB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBhZShlKSB7IGxldCB7IHN3aXBlcjogdCwgZHVyYXRpb246IHMsIHRyYW5zZm9ybUVsOiBhLCBhbGxTbGlkZXM6IGkgfSA9IGU7IGNvbnN0IHsgc2xpZGVzOiByLCBhY3RpdmVJbmRleDogbiwgJHdyYXBwZXJFbDogbCB9ID0gdDsgaWYgKHQucGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUgJiYgMCAhPT0gcykgeyBsZXQgZSwgcyA9ICExO1xyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBpID8gYSA/IHIuZmluZChhKSA6IHIgOiBhID8gci5lcShuKS5maW5kKGEpIDogci5lcShuKSwgZS50cmFuc2l0aW9uRW5kKCgoKSA9PiB7IGlmIChzKSByZXR1cm47IGlmICghdCB8fCB0LmRlc3Ryb3llZCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gITAsIHQuYW5pbWF0aW5nID0gITE7IGNvbnN0IGUgPSBbXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsIFwidHJhbnNpdGlvbmVuZFwiXTsgZm9yIChsZXQgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCArPSAxKSBsLnRyaWdnZXIoZVt0XSkgfSkpIH0gfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaWUoZSwgdCwgcykgeyBjb25zdCBhID0gXCJzd2lwZXItc2xpZGUtc2hhZG93XCIgKyAocyA/IGAtJHtzfWAgOiBcIlwiKSxcclxuICAgICAgICAgICAgICAgICAgICBpID0gZS50cmFuc2Zvcm1FbCA/IHQuZmluZChlLnRyYW5zZm9ybUVsKSA6IHQ7IGxldCByID0gaS5jaGlsZHJlbihgLiR7YX1gKTsgcmV0dXJuIHIubGVuZ3RoIHx8IChyID0gZChgPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3cke3M/YC0ke3N9YDpcIlwifVwiPjwvZGl2PmApLGkuYXBwZW5kKHIpKSxyfU9iamVjdC5rZXlzKF8pLmZvckVhY2goKGU9PntPYmplY3Qua2V5cyhfW2VdKS5mb3JFYWNoKCh0PT57Vi5wcm90b3R5cGVbdF09X1tlXVt0XX0pKX0pKSxWLnVzZShbZnVuY3Rpb24oZSl7bGV0e3N3aXBlcjp0LG9uOnMsZW1pdDphfT1lO2NvbnN0IGk9cigpO2xldCBuPW51bGwsbD1udWxsO2NvbnN0IG89KCk9Pnt0JiYhdC5kZXN0cm95ZWQmJnQuaW5pdGlhbGl6ZWQmJihhKFwiYmVmb3JlUmVzaXplXCIpLGEoXCJyZXNpemVcIikpfSxkPSgpPT57dCYmIXQuZGVzdHJveWVkJiZ0LmluaXRpYWxpemVkJiZhKFwib3JpZW50YXRpb25jaGFuZ2VcIil9O3MoXCJpbml0XCIsKCgpPT57dC5wYXJhbXMucmVzaXplT2JzZXJ2ZXImJnZvaWQgMCE9PWkuUmVzaXplT2JzZXJ2ZXI/dCYmIXQuZGVzdHJveWVkJiZ0LmluaXRpYWxpemVkJiYobj1uZXcgUmVzaXplT2JzZXJ2ZXIoKGU9PntsPWkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgoKT0+e2NvbnN0e3dpZHRoOnMsaGVpZ2h0OmF9PXQ7bGV0IGk9cyxyPWE7ZS5mb3JFYWNoKChlPT57bGV0e2NvbnRlbnRCb3hTaXplOnMsY29udGVudFJlY3Q6YSx0YXJnZXQ6bn09ZTtuJiZuIT09dC5lbHx8KGk9YT9hLndpZHRoOihzWzBdfHxzKS5pbmxpbmVTaXplLHI9YT9hLmhlaWdodDooc1swXXx8cykuYmxvY2tTaXplKX0pKSxpPT09cyYmcj09PWF8fG8oKX0pKX0pKSxuLm9ic2VydmUodC5lbCkpOihpLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIixvKSxpLmFkZEV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLGQpKX0pKSxzKFwiZGVzdHJveVwiLCgoKT0+e2wmJmkuY2FuY2VsQW5pbWF0aW9uRnJhbWUobCksbiYmbi51bm9ic2VydmUmJnQuZWwmJihuLnVub2JzZXJ2ZSh0LmVsKSxuPW51bGwpLGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLG8pLGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsZCl9KSl9LGZ1bmN0aW9uKGUpe2xldHtzd2lwZXI6dCxleHRlbmRQYXJhbXM6cyxvbjphLGVtaXQ6aX09ZTtjb25zdCBuPVtdLGw9cigpLG89ZnVuY3Rpb24oZSx0KXt2b2lkIDA9PT10JiYodD17fSk7Y29uc3Qgcz1uZXcobC5NdXRhdGlvbk9ic2VydmVyfHxsLldlYmtpdE11dGF0aW9uT2JzZXJ2ZXIpKChlPT57aWYoMT09PWUubGVuZ3RoKXJldHVybiB2b2lkIGkoXCJvYnNlcnZlclVwZGF0ZVwiLGVbMF0pO2NvbnN0IHQ9ZnVuY3Rpb24oKXtpKFwib2JzZXJ2ZXJVcGRhdGVcIixlWzBdKX07bC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU/bC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodCk6bC5zZXRUaW1lb3V0KHQsMCl9KSk7cy5vYnNlcnZlKGUse2F0dHJpYnV0ZXM6dm9pZCAwPT09dC5hdHRyaWJ1dGVzfHx0LmF0dHJpYnV0ZXMsY2hpbGRMaXN0OnZvaWQgMD09PXQuY2hpbGRMaXN0fHx0LmNoaWxkTGlzdCxjaGFyYWN0ZXJEYXRhOnZvaWQgMD09PXQuY2hhcmFjdGVyRGF0YXx8dC5jaGFyYWN0ZXJEYXRhfSksbi5wdXNoKHMpfTtzKHtvYnNlcnZlcjohMSxvYnNlcnZlUGFyZW50czohMSxvYnNlcnZlU2xpZGVDaGlsZHJlbjohMX0pLGEoXCJpbml0XCIsKCgpPT57aWYodC5wYXJhbXMub2JzZXJ2ZXIpe2lmKHQucGFyYW1zLm9ic2VydmVQYXJlbnRzKXtjb25zdCBlPXQuJGVsLnBhcmVudHMoKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrPTEpbyhlW3RdKX1vKHQuJGVsWzBdLHtjaGlsZExpc3Q6dC5wYXJhbXMub2JzZXJ2ZVNsaWRlQ2hpbGRyZW59KSxvKHQuJHdyYXBwZXJFbFswXSx7YXR0cmlidXRlczohMX0pfX0pKSxhKFwiZGVzdHJveVwiLCgoKT0+e24uZm9yRWFjaCgoZT0+e2UuZGlzY29ubmVjdCgpfSkpLG4uc3BsaWNlKDAsbi5sZW5ndGgpfSkpfV0pO2NvbnN0IHJlPVtmdW5jdGlvbihlKXtsZXQgdCx7c3dpcGVyOnMsZXh0ZW5kUGFyYW1zOmEsb246aSxlbWl0OnJ9PWU7ZnVuY3Rpb24gbihlLHQpe2NvbnN0IGE9cy5wYXJhbXMudmlydHVhbDtpZihhLmNhY2hlJiZzLnZpcnR1YWwuY2FjaGVbdF0pcmV0dXJuIHMudmlydHVhbC5jYWNoZVt0XTtjb25zdCBpPWEucmVuZGVyU2xpZGU/ZChhLnJlbmRlclNsaWRlLmNhbGwocyxlLHQpKTpkKGA8ZGl2IGNsYXNzPVwiJHtzLnBhcmFtcy5zbGlkZUNsYXNzfVwiIGRhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHt0fVwiPiR7ZX08L2Rpdj5gKTtyZXR1cm4gaS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIil8fGkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIsdCksYS5jYWNoZSYmKHMudmlydHVhbC5jYWNoZVt0XT1pKSxpfWZ1bmN0aW9uIGwoZSl7Y29uc3R7c2xpZGVzUGVyVmlldzp0LHNsaWRlc1Blckdyb3VwOmEsY2VudGVyZWRTbGlkZXM6aX09cy5wYXJhbXMse2FkZFNsaWRlc0JlZm9yZTpsLGFkZFNsaWRlc0FmdGVyOm99PXMucGFyYW1zLnZpcnR1YWwse2Zyb206ZCx0bzpjLHNsaWRlczpwLHNsaWRlc0dyaWQ6dSxvZmZzZXQ6aH09cy52aXJ0dWFsO3MucGFyYW1zLmNzc01vZGV8fHMudXBkYXRlQWN0aXZlSW5kZXgoKTtjb25zdCBtPXMuYWN0aXZlSW5kZXh8fDA7bGV0IGYsZyx2O2Y9cy5ydGxUcmFuc2xhdGU/XCJyaWdodFwiOnMuaXNIb3Jpem9udGFsKCk/XCJsZWZ0XCI6XCJ0b3BcIixpPyhnPU1hdGguZmxvb3IodC8yKSthK28sdj1NYXRoLmZsb29yKHQvMikrYStsKTooZz10KyhhLTEpK28sdj1hK2wpO2NvbnN0IHc9TWF0aC5tYXgoKG18fDApLXYsMCksYj1NYXRoLm1pbigobXx8MCkrZyxwLmxlbmd0aC0xKSx4PShzLnNsaWRlc0dyaWRbd118fDApLShzLnNsaWRlc0dyaWRbMF18fDApO2Z1bmN0aW9uIHkoKXtzLnVwZGF0ZVNsaWRlcygpLHMudXBkYXRlUHJvZ3Jlc3MoKSxzLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSxzLmxhenkmJnMucGFyYW1zLmxhenkuZW5hYmxlZCYmcy5sYXp5LmxvYWQoKSxyKFwidmlydHVhbFVwZGF0ZVwiKX1pZihPYmplY3QuYXNzaWduKHMudmlydHVhbCx7ZnJvbTp3LHRvOmIsb2Zmc2V0Ongsc2xpZGVzR3JpZDpzLnNsaWRlc0dyaWR9KSxkPT09dyYmYz09PWImJiFlKXJldHVybiBzLnNsaWRlc0dyaWQhPT11JiZ4IT09aCYmcy5zbGlkZXMuY3NzKGYsYCR7eH1weGApLHMudXBkYXRlUHJvZ3Jlc3MoKSx2b2lkIHIoXCJ2aXJ0dWFsVXBkYXRlXCIpO2lmKHMucGFyYW1zLnZpcnR1YWwucmVuZGVyRXh0ZXJuYWwpcmV0dXJuIHMucGFyYW1zLnZpcnR1YWwucmVuZGVyRXh0ZXJuYWwuY2FsbChzLHtvZmZzZXQ6eCxmcm9tOncsdG86YixzbGlkZXM6ZnVuY3Rpb24oKXtjb25zdCBlPVtdO2ZvcihsZXQgdD13O3Q8PWI7dCs9MSllLnB1c2gocFt0XSk7cmV0dXJuIGV9KCl9KSx2b2lkKHMucGFyYW1zLnZpcnR1YWwucmVuZGVyRXh0ZXJuYWxVcGRhdGU/eSgpOnIoXCJ2aXJ0dWFsVXBkYXRlXCIpKTtjb25zdCBFPVtdLEM9W107aWYoZSlzLiR3cmFwcGVyRWwuZmluZChgLiR7cy5wYXJhbXMuc2xpZGVDbGFzc31gKS5yZW1vdmUoKTtlbHNlIGZvcihsZXQgZT1kO2U8PWM7ZSs9MSkoZTx3fHxlPmIpJiZzLiR3cmFwcGVyRWwuZmluZChgLiR7cy5wYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2V9XCJdYCkucmVtb3ZlKCk7Zm9yKGxldCB0PTA7dDxwLmxlbmd0aDt0Kz0xKXQ+PXcmJnQ8PWImJih2b2lkIDA9PT1jfHxlP0MucHVzaCh0KToodD5jJiZDLnB1c2godCksdDxkJiZFLnB1c2godCkpKTtDLmZvckVhY2goKGU9PntzLiR3cmFwcGVyRWwuYXBwZW5kKG4ocFtlXSxlKSl9KSksRS5zb3J0KCgoZSx0KT0+dC1lKSkuZm9yRWFjaCgoZT0+e3MuJHdyYXBwZXJFbC5wcmVwZW5kKG4ocFtlXSxlKSl9KSkscy4kd3JhcHBlckVsLmNoaWxkcmVuKFwiLnN3aXBlci1zbGlkZVwiKS5jc3MoZixgJHt4fXB4YCkseSgpfWEoe3ZpcnR1YWw6e2VuYWJsZWQ6ITEsc2xpZGVzOltdLGNhY2hlOiEwLHJlbmRlclNsaWRlOm51bGwscmVuZGVyRXh0ZXJuYWw6bnVsbCxyZW5kZXJFeHRlcm5hbFVwZGF0ZTohMCxhZGRTbGlkZXNCZWZvcmU6MCxhZGRTbGlkZXNBZnRlcjowfX0pLHMudmlydHVhbD17Y2FjaGU6e30sZnJvbTp2b2lkIDAsdG86dm9pZCAwLHNsaWRlczpbXSxvZmZzZXQ6MCxzbGlkZXNHcmlkOltdfSxpKFwiYmVmb3JlSW5pdFwiLCgoKT0+e3MucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCYmKHMudmlydHVhbC5zbGlkZXM9cy5wYXJhbXMudmlydHVhbC5zbGlkZXMscy5jbGFzc05hbWVzLnB1c2goYCR7cy5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc312aXJ0dWFsYCkscy5wYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcz0hMCxzLm9yaWdpbmFsUGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3M9ITAscy5wYXJhbXMuaW5pdGlhbFNsaWRlfHxsKCkpfSkpLGkoXCJzZXRUcmFuc2xhdGVcIiwoKCk9PntzLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQmJihzLnBhcmFtcy5jc3NNb2RlJiYhcy5faW1tZWRpYXRlVmlydHVhbD8oY2xlYXJUaW1lb3V0KHQpLHQ9c2V0VGltZW91dCgoKCk9PntsKCl9KSwxMDApKTpsKCkpfSkpLGkoXCJpbml0IHVwZGF0ZSByZXNpemVcIiwoKCk9PntzLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQmJnMucGFyYW1zLmNzc01vZGUmJnYocy53cmFwcGVyRWwsXCItLXN3aXBlci12aXJ0dWFsLXNpemVcIixgJHtzLnZpcnR1YWxTaXplfXB4YCl9KSksT2JqZWN0LmFzc2lnbihzLnZpcnR1YWwse2FwcGVuZFNsaWRlOmZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBlJiZcImxlbmd0aFwiaW4gZSlmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrPTEpZVt0XSYmcy52aXJ0dWFsLnNsaWRlcy5wdXNoKGVbdF0pO2Vsc2Ugcy52aXJ0dWFsLnNsaWRlcy5wdXNoKGUpO2woITApfSxwcmVwZW5kU2xpZGU6ZnVuY3Rpb24oZSl7Y29uc3QgdD1zLmFjdGl2ZUluZGV4O2xldCBhPXQrMSxpPTE7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kz0xKWVbdF0mJnMudmlydHVhbC5zbGlkZXMudW5zaGlmdChlW3RdKTthPXQrZS5sZW5ndGgsaT1lLmxlbmd0aH1lbHNlIHMudmlydHVhbC5zbGlkZXMudW5zaGlmdChlKTtpZihzLnBhcmFtcy52aXJ0dWFsLmNhY2hlKXtjb25zdCBlPXMudmlydHVhbC5jYWNoZSx0PXt9O09iamVjdC5rZXlzKGUpLmZvckVhY2goKHM9Pntjb25zdCBhPWVbc10scj1hLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKTtyJiZhLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiLHBhcnNlSW50KHIsMTApK2kpLHRbcGFyc2VJbnQocywxMCkraV09YX0pKSxzLnZpcnR1YWwuY2FjaGU9dH1sKCEwKSxzLnNsaWRlVG8oYSwwKX0scmVtb3ZlU2xpZGU6ZnVuY3Rpb24oZSl7aWYobnVsbD09ZSlyZXR1cm47bGV0IHQ9cy5hY3RpdmVJbmRleDtpZihBcnJheS5pc0FycmF5KGUpKWZvcihsZXQgYT1lLmxlbmd0aC0xO2E+PTA7YS09MSlzLnZpcnR1YWwuc2xpZGVzLnNwbGljZShlW2FdLDEpLHMucGFyYW1zLnZpcnR1YWwuY2FjaGUmJmRlbGV0ZSBzLnZpcnR1YWwuY2FjaGVbZVthXV0sZVthXTx0JiYodC09MSksdD1NYXRoLm1heCh0LDApO2Vsc2Ugcy52aXJ0dWFsLnNsaWRlcy5zcGxpY2UoZSwxKSxzLnBhcmFtcy52aXJ0dWFsLmNhY2hlJiZkZWxldGUgcy52aXJ0dWFsLmNhY2hlW2VdLGU8dCYmKHQtPTEpLHQ9TWF0aC5tYXgodCwwKTtsKCEwKSxzLnNsaWRlVG8odCwwKX0scmVtb3ZlQWxsU2xpZGVzOmZ1bmN0aW9uKCl7cy52aXJ0dWFsLnNsaWRlcz1bXSxzLnBhcmFtcy52aXJ0dWFsLmNhY2hlJiYocy52aXJ0dWFsLmNhY2hlPXt9KSxsKCEwKSxzLnNsaWRlVG8oMCwwKX0sdXBkYXRlOmx9KX0sZnVuY3Rpb24oZSl7bGV0e3N3aXBlcjp0LGV4dGVuZFBhcmFtczpzLG9uOmksZW1pdDpufT1lO2NvbnN0IGw9YSgpLG89cigpO2Z1bmN0aW9uIGMoZSl7aWYoIXQuZW5hYmxlZClyZXR1cm47Y29uc3R7cnRsVHJhbnNsYXRlOnN9PXQ7bGV0IGE9ZTthLm9yaWdpbmFsRXZlbnQmJihhPWEub3JpZ2luYWxFdmVudCk7Y29uc3QgaT1hLmtleUNvZGV8fGEuY2hhckNvZGUscj10LnBhcmFtcy5rZXlib2FyZC5wYWdlVXBEb3duLGQ9ciYmMzM9PT1pLGM9ciYmMzQ9PT1pLHA9Mzc9PT1pLHU9Mzk9PT1pLGg9Mzg9PT1pLG09NDA9PT1pO2lmKCF0LmFsbG93U2xpZGVOZXh0JiYodC5pc0hvcml6b250YWwoKSYmdXx8dC5pc1ZlcnRpY2FsKCkmJm18fGMpKXJldHVybiExO2lmKCF0LmFsbG93U2xpZGVQcmV2JiYodC5pc0hvcml6b250YWwoKSYmcHx8dC5pc1ZlcnRpY2FsKCkmJmh8fGQpKXJldHVybiExO2lmKCEoYS5zaGlmdEtleXx8YS5hbHRLZXl8fGEuY3RybEtleXx8YS5tZXRhS2V5fHxsLmFjdGl2ZUVsZW1lbnQmJmwuYWN0aXZlRWxlbWVudC5ub2RlTmFtZSYmKFwiaW5wdXRcIj09PWwuYWN0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpfHxcInRleHRhcmVhXCI9PT1sLmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpKXtpZih0LnBhcmFtcy5rZXlib2FyZC5vbmx5SW5WaWV3cG9ydCYmKGR8fGN8fHB8fHV8fGh8fG0pKXtsZXQgZT0hMTtpZih0LiRlbC5wYXJlbnRzKGAuJHt0LnBhcmFtcy5zbGlkZUNsYXNzfWApLmxlbmd0aD4wJiYwPT09dC4kZWwucGFyZW50cyhgLiR7dC5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzc31gKS5sZW5ndGgpcmV0dXJuO2NvbnN0IGE9dC4kZWwsaT1hWzBdLmNsaWVudFdpZHRoLHI9YVswXS5jbGllbnRIZWlnaHQsbj1vLmlubmVyV2lkdGgsbD1vLmlubmVySGVpZ2h0LGQ9dC4kZWwub2Zmc2V0KCk7cyYmKGQubGVmdC09dC4kZWxbMF0uc2Nyb2xsTGVmdCk7Y29uc3QgYz1bW2QubGVmdCxkLnRvcF0sW2QubGVmdCtpLGQudG9wXSxbZC5sZWZ0LGQudG9wK3JdLFtkLmxlZnQraSxkLnRvcCtyXV07Zm9yKGxldCB0PTA7dDxjLmxlbmd0aDt0Kz0xKXtjb25zdCBzPWNbdF07aWYoc1swXT49MCYmc1swXTw9biYmc1sxXT49MCYmc1sxXTw9bCl7aWYoMD09PXNbMF0mJjA9PT1zWzFdKWNvbnRpbnVlO2U9ITB9fWlmKCFlKXJldHVybn10LmlzSG9yaXpvbnRhbCgpPygoZHx8Y3x8cHx8dSkmJihhLnByZXZlbnREZWZhdWx0P2EucHJldmVudERlZmF1bHQoKTphLnJldHVyblZhbHVlPSExKSwoKGN8fHUpJiYhc3x8KGR8fHApJiZzKSYmdC5zbGlkZU5leHQoKSwoKGR8fHApJiYhc3x8KGN8fHUpJiZzKSYmdC5zbGlkZVByZXYoKSk6KChkfHxjfHxofHxtKSYmKGEucHJldmVudERlZmF1bHQ/YS5wcmV2ZW50RGVmYXVsdCgpOmEucmV0dXJuVmFsdWU9ITEpLChjfHxtKSYmdC5zbGlkZU5leHQoKSwoZHx8aCkmJnQuc2xpZGVQcmV2KCkpLG4oXCJrZXlQcmVzc1wiLGkpfX1mdW5jdGlvbiBwKCl7dC5rZXlib2FyZC5lbmFibGVkfHwoZChsKS5vbihcImtleWRvd25cIixjKSx0LmtleWJvYXJkLmVuYWJsZWQ9ITApfWZ1bmN0aW9uIHUoKXt0LmtleWJvYXJkLmVuYWJsZWQmJihkKGwpLm9mZihcImtleWRvd25cIixjKSx0LmtleWJvYXJkLmVuYWJsZWQ9ITEpfXQua2V5Ym9hcmQ9e2VuYWJsZWQ6ITF9LHMoe2tleWJvYXJkOntlbmFibGVkOiExLG9ubHlJblZpZXdwb3J0OiEwLHBhZ2VVcERvd246ITB9fSksaShcImluaXRcIiwoKCk9Pnt0LnBhcmFtcy5rZXlib2FyZC5lbmFibGVkJiZwKCl9KSksaShcImRlc3Ryb3lcIiwoKCk9Pnt0LmtleWJvYXJkLmVuYWJsZWQmJnUoKX0pKSxPYmplY3QuYXNzaWduKHQua2V5Ym9hcmQse2VuYWJsZTpwLGRpc2FibGU6dX0pfSxmdW5jdGlvbihlKXtsZXR7c3dpcGVyOnQsZXh0ZW5kUGFyYW1zOnMsb246YSxlbWl0Oml9PWU7Y29uc3Qgbj1yKCk7bGV0IGw7cyh7bW91c2V3aGVlbDp7ZW5hYmxlZDohMSxyZWxlYXNlT25FZGdlczohMSxpbnZlcnQ6ITEsZm9yY2VUb0F4aXM6ITEsc2Vuc2l0aXZpdHk6MSxldmVudHNUYXJnZXQ6XCJjb250YWluZXJcIix0aHJlc2hvbGREZWx0YTpudWxsLHRocmVzaG9sZFRpbWU6bnVsbH19KSx0Lm1vdXNld2hlZWw9e2VuYWJsZWQ6ITF9O2xldCBvLGM9dSgpO2NvbnN0IGg9W107ZnVuY3Rpb24gbSgpe3QuZW5hYmxlZCYmKHQubW91c2VFbnRlcmVkPSEwKX1mdW5jdGlvbiBmKCl7dC5lbmFibGVkJiYodC5tb3VzZUVudGVyZWQ9ITEpfWZ1bmN0aW9uIGcoZSl7cmV0dXJuISh0LnBhcmFtcy5tb3VzZXdoZWVsLnRocmVzaG9sZERlbHRhJiZlLmRlbHRhPHQucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkRGVsdGEpJiYoISh0LnBhcmFtcy5tb3VzZXdoZWVsLnRocmVzaG9sZFRpbWUmJnUoKS1jPHQucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkVGltZSkmJihlLmRlbHRhPj02JiZ1KCktYzw2MHx8KGUuZGlyZWN0aW9uPDA/dC5pc0VuZCYmIXQucGFyYW1zLmxvb3B8fHQuYW5pbWF0aW5nfHwodC5zbGlkZU5leHQoKSxpKFwic2Nyb2xsXCIsZS5yYXcpKTp0LmlzQmVnaW5uaW5nJiYhdC5wYXJhbXMubG9vcHx8dC5hbmltYXRpbmd8fCh0LnNsaWRlUHJldigpLGkoXCJzY3JvbGxcIixlLnJhdykpLGM9KG5ldyBuLkRhdGUpLmdldFRpbWUoKSwhMSkpKX1mdW5jdGlvbiB2KGUpe2xldCBzPWUsYT0hMDtpZighdC5lbmFibGVkKXJldHVybjtjb25zdCByPXQucGFyYW1zLm1vdXNld2hlZWw7dC5wYXJhbXMuY3NzTW9kZSYmcy5wcmV2ZW50RGVmYXVsdCgpO2xldCBuPXQuJGVsO2lmKFwiY29udGFpbmVyXCIhPT10LnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdldCYmKG49ZCh0LnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdldCkpLCF0Lm1vdXNlRW50ZXJlZCYmIW5bMF0uY29udGFpbnMocy50YXJnZXQpJiYhci5yZWxlYXNlT25FZGdlcylyZXR1cm4hMDtzLm9yaWdpbmFsRXZlbnQmJihzPXMub3JpZ2luYWxFdmVudCk7bGV0IGM9MDtjb25zdCBtPXQucnRsVHJhbnNsYXRlPy0xOjEsZj1mdW5jdGlvbihlKXtsZXQgdD0wLHM9MCxhPTAsaT0wO3JldHVyblwiZGV0YWlsXCJpbiBlJiYocz1lLmRldGFpbCksXCJ3aGVlbERlbHRhXCJpbiBlJiYocz0tZS53aGVlbERlbHRhLzEyMCksXCJ3aGVlbERlbHRhWVwiaW4gZSYmKHM9LWUud2hlZWxEZWx0YVkvMTIwKSxcIndoZWVsRGVsdGFYXCJpbiBlJiYodD0tZS53aGVlbERlbHRhWC8xMjApLFwiYXhpc1wiaW4gZSYmZS5heGlzPT09ZS5IT1JJWk9OVEFMX0FYSVMmJih0PXMscz0wKSxhPTEwKnQsaT0xMCpzLFwiZGVsdGFZXCJpbiBlJiYoaT1lLmRlbHRhWSksXCJkZWx0YVhcImluIGUmJihhPWUuZGVsdGFYKSxlLnNoaWZ0S2V5JiYhYSYmKGE9aSxpPTApLChhfHxpKSYmZS5kZWx0YU1vZGUmJigxPT09ZS5kZWx0YU1vZGU/KGEqPTQwLGkqPTQwKTooYSo9ODAwLGkqPTgwMCkpLGEmJiF0JiYodD1hPDE/LTE6MSksaSYmIXMmJihzPWk8MT8tMToxKSx7c3Bpblg6dCxzcGluWTpzLHBpeGVsWDphLHBpeGVsWTppfX0ocyk7aWYoci5mb3JjZVRvQXhpcylpZih0LmlzSG9yaXpvbnRhbCgpKXtpZighKE1hdGguYWJzKGYucGl4ZWxYKT5NYXRoLmFicyhmLnBpeGVsWSkpKXJldHVybiEwO2M9LWYucGl4ZWxYKm19ZWxzZXtpZighKE1hdGguYWJzKGYucGl4ZWxZKT5NYXRoLmFicyhmLnBpeGVsWCkpKXJldHVybiEwO2M9LWYucGl4ZWxZfWVsc2UgYz1NYXRoLmFicyhmLnBpeGVsWCk+TWF0aC5hYnMoZi5waXhlbFkpPy1mLnBpeGVsWCptOi1mLnBpeGVsWTtpZigwPT09YylyZXR1cm4hMDtyLmludmVydCYmKGM9LWMpO2xldCB2PXQuZ2V0VHJhbnNsYXRlKCkrYypyLnNlbnNpdGl2aXR5O2lmKHY+PXQubWluVHJhbnNsYXRlKCkmJih2PXQubWluVHJhbnNsYXRlKCkpLHY8PXQubWF4VHJhbnNsYXRlKCkmJih2PXQubWF4VHJhbnNsYXRlKCkpLGE9ISF0LnBhcmFtcy5sb29wfHwhKHY9PT10Lm1pblRyYW5zbGF0ZSgpfHx2PT09dC5tYXhUcmFuc2xhdGUoKSksYSYmdC5wYXJhbXMubmVzdGVkJiZzLnN0b3BQcm9wYWdhdGlvbigpLHQucGFyYW1zLmZyZWVNb2RlJiZ0LnBhcmFtcy5mcmVlTW9kZS5lbmFibGVkKXtjb25zdCBlPXt0aW1lOnUoKSxkZWx0YTpNYXRoLmFicyhjKSxkaXJlY3Rpb246TWF0aC5zaWduKGMpfSxhPW8mJmUudGltZTxvLnRpbWUrNTAwJiZlLmRlbHRhPD1vLmRlbHRhJiZlLmRpcmVjdGlvbj09PW8uZGlyZWN0aW9uO2lmKCFhKXtvPXZvaWQgMCx0LnBhcmFtcy5sb29wJiZ0Lmxvb3BGaXgoKTtsZXQgbj10LmdldFRyYW5zbGF0ZSgpK2Mqci5zZW5zaXRpdml0eTtjb25zdCBkPXQuaXNCZWdpbm5pbmcsdT10LmlzRW5kO2lmKG4+PXQubWluVHJhbnNsYXRlKCkmJihuPXQubWluVHJhbnNsYXRlKCkpLG48PXQubWF4VHJhbnNsYXRlKCkmJihuPXQubWF4VHJhbnNsYXRlKCkpLHQuc2V0VHJhbnNpdGlvbigwKSx0LnNldFRyYW5zbGF0ZShuKSx0LnVwZGF0ZVByb2dyZXNzKCksdC51cGRhdGVBY3RpdmVJbmRleCgpLHQudXBkYXRlU2xpZGVzQ2xhc3NlcygpLCghZCYmdC5pc0JlZ2lubmluZ3x8IXUmJnQuaXNFbmQpJiZ0LnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSx0LnBhcmFtcy5mcmVlTW9kZS5zdGlja3kpe2NsZWFyVGltZW91dChsKSxsPXZvaWQgMCxoLmxlbmd0aD49MTUmJmguc2hpZnQoKTtjb25zdCBzPWgubGVuZ3RoP2hbaC5sZW5ndGgtMV06dm9pZCAwLGE9aFswXTtpZihoLnB1c2goZSkscyYmKGUuZGVsdGE+cy5kZWx0YXx8ZS5kaXJlY3Rpb24hPT1zLmRpcmVjdGlvbikpaC5zcGxpY2UoMCk7ZWxzZSBpZihoLmxlbmd0aD49MTUmJmUudGltZS1hLnRpbWU8NTAwJiZhLmRlbHRhLWUuZGVsdGE+PTEmJmUuZGVsdGE8PTYpe2NvbnN0IHM9Yz4wPy44Oi4yO289ZSxoLnNwbGljZSgwKSxsPXAoKCgpPT57dC5zbGlkZVRvQ2xvc2VzdCh0LnBhcmFtcy5zcGVlZCwhMCx2b2lkIDAscyl9KSwwKX1sfHwobD1wKCgoKT0+e289ZSxoLnNwbGljZSgwKSx0LnNsaWRlVG9DbG9zZXN0KHQucGFyYW1zLnNwZWVkLCEwLHZvaWQgMCwuNSl9KSw1MDApKX1pZihhfHxpKFwic2Nyb2xsXCIscyksdC5wYXJhbXMuYXV0b3BsYXkmJnQucGFyYW1zLmF1dG9wbGF5RGlzYWJsZU9uSW50ZXJhY3Rpb24mJnQuYXV0b3BsYXkuc3RvcCgpLG49PT10Lm1pblRyYW5zbGF0ZSgpfHxuPT09dC5tYXhUcmFuc2xhdGUoKSlyZXR1cm4hMH19ZWxzZXtjb25zdCBzPXt0aW1lOnUoKSxkZWx0YTpNYXRoLmFicyhjKSxkaXJlY3Rpb246TWF0aC5zaWduKGMpLHJhdzplfTtoLmxlbmd0aD49MiYmaC5zaGlmdCgpO2NvbnN0IGE9aC5sZW5ndGg/aFtoLmxlbmd0aC0xXTp2b2lkIDA7aWYoaC5wdXNoKHMpLGE/KHMuZGlyZWN0aW9uIT09YS5kaXJlY3Rpb258fHMuZGVsdGE+YS5kZWx0YXx8cy50aW1lPmEudGltZSsxNTApJiZnKHMpOmcocyksZnVuY3Rpb24oZSl7Y29uc3Qgcz10LnBhcmFtcy5tb3VzZXdoZWVsO2lmKGUuZGlyZWN0aW9uPDApe2lmKHQuaXNFbmQmJiF0LnBhcmFtcy5sb29wJiZzLnJlbGVhc2VPbkVkZ2VzKXJldHVybiEwfWVsc2UgaWYodC5pc0JlZ2lubmluZyYmIXQucGFyYW1zLmxvb3AmJnMucmVsZWFzZU9uRWRnZXMpcmV0dXJuITA7cmV0dXJuITF9KHMpKXJldHVybiEwfXJldHVybiBzLnByZXZlbnREZWZhdWx0P3MucHJldmVudERlZmF1bHQoKTpzLnJldHVyblZhbHVlPSExLCExfWZ1bmN0aW9uIHcoZSl7bGV0IHM9dC4kZWw7XCJjb250YWluZXJcIiE9PXQucGFyYW1zLm1vdXNld2hlZWwuZXZlbnRzVGFyZ2V0JiYocz1kKHQucGFyYW1zLm1vdXNld2hlZWwuZXZlbnRzVGFyZ2V0KSksc1tlXShcIm1vdXNlZW50ZXJcIixtKSxzW2VdKFwibW91c2VsZWF2ZVwiLGYpLHNbZV0oXCJ3aGVlbFwiLHYpfWZ1bmN0aW9uIGIoKXtyZXR1cm4gdC5wYXJhbXMuY3NzTW9kZT8odC53cmFwcGVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsdiksITApOiF0Lm1vdXNld2hlZWwuZW5hYmxlZCYmKHcoXCJvblwiKSx0Lm1vdXNld2hlZWwuZW5hYmxlZD0hMCwhMCl9ZnVuY3Rpb24geCgpe3JldHVybiB0LnBhcmFtcy5jc3NNb2RlPyh0LndyYXBwZXJFbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LHYpLCEwKTohIXQubW91c2V3aGVlbC5lbmFibGVkJiYodyhcIm9mZlwiKSx0Lm1vdXNld2hlZWwuZW5hYmxlZD0hMSwhMCl9YShcImluaXRcIiwoKCk9PnshdC5wYXJhbXMubW91c2V3aGVlbC5lbmFibGVkJiZ0LnBhcmFtcy5jc3NNb2RlJiZ4KCksdC5wYXJhbXMubW91c2V3aGVlbC5lbmFibGVkJiZiKCl9KSksYShcImRlc3Ryb3lcIiwoKCk9Pnt0LnBhcmFtcy5jc3NNb2RlJiZiKCksdC5tb3VzZXdoZWVsLmVuYWJsZWQmJngoKX0pKSxPYmplY3QuYXNzaWduKHQubW91c2V3aGVlbCx7ZW5hYmxlOmIsZGlzYWJsZTp4fSl9LGZ1bmN0aW9uKGUpe2xldHtzd2lwZXI6dCxleHRlbmRQYXJhbXM6cyxvbjphLGVtaXQ6aX09ZTtmdW5jdGlvbiByKGUpe2xldCBzO3JldHVybiBlJiYocz1kKGUpLHQucGFyYW1zLnVuaXF1ZU5hdkVsZW1lbnRzJiZcInN0cmluZ1wiPT10eXBlb2YgZSYmcy5sZW5ndGg+MSYmMT09PXQuJGVsLmZpbmQoZSkubGVuZ3RoJiYocz10LiRlbC5maW5kKGUpKSksc31mdW5jdGlvbiBuKGUscyl7Y29uc3QgYT10LnBhcmFtcy5uYXZpZ2F0aW9uO2UmJmUubGVuZ3RoPjAmJihlW3M/XCJhZGRDbGFzc1wiOlwicmVtb3ZlQ2xhc3NcIl0oYS5kaXNhYmxlZENsYXNzKSxlWzBdJiZcIkJVVFRPTlwiPT09ZVswXS50YWdOYW1lJiYoZVswXS5kaXNhYmxlZD1zKSx0LnBhcmFtcy53YXRjaE92ZXJmbG93JiZ0LmVuYWJsZWQmJmVbdC5pc0xvY2tlZD9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiXShhLmxvY2tDbGFzcykpfWZ1bmN0aW9uIGwoKXtpZih0LnBhcmFtcy5sb29wKXJldHVybjtjb25zdHskbmV4dEVsOmUsJHByZXZFbDpzfT10Lm5hdmlnYXRpb247bihzLHQuaXNCZWdpbm5pbmcmJiF0LnBhcmFtcy5yZXdpbmQpLG4oZSx0LmlzRW5kJiYhdC5wYXJhbXMucmV3aW5kKX1mdW5jdGlvbiBvKGUpe2UucHJldmVudERlZmF1bHQoKSwoIXQuaXNCZWdpbm5pbmd8fHQucGFyYW1zLmxvb3B8fHQucGFyYW1zLnJld2luZCkmJnQuc2xpZGVQcmV2KCl9ZnVuY3Rpb24gYyhlKXtlLnByZXZlbnREZWZhdWx0KCksKCF0LmlzRW5kfHx0LnBhcmFtcy5sb29wfHx0LnBhcmFtcy5yZXdpbmQpJiZ0LnNsaWRlTmV4dCgpfWZ1bmN0aW9uIHAoKXtjb25zdCBlPXQucGFyYW1zLm5hdmlnYXRpb247aWYodC5wYXJhbXMubmF2aWdhdGlvbj1GKHQsdC5vcmlnaW5hbFBhcmFtcy5uYXZpZ2F0aW9uLHQucGFyYW1zLm5hdmlnYXRpb24se25leHRFbDpcInN3aXBlci1idXR0b24tbmV4dFwiLHByZXZFbDpcInN3aXBlci1idXR0b24tcHJldlwifSksIWUubmV4dEVsJiYhZS5wcmV2RWwpcmV0dXJuO2NvbnN0IHM9cihlLm5leHRFbCksYT1yKGUucHJldkVsKTtzJiZzLmxlbmd0aD4wJiZzLm9uKFwiY2xpY2tcIixjKSxhJiZhLmxlbmd0aD4wJiZhLm9uKFwiY2xpY2tcIixvKSxPYmplY3QuYXNzaWduKHQubmF2aWdhdGlvbix7JG5leHRFbDpzLG5leHRFbDpzJiZzWzBdLCRwcmV2RWw6YSxwcmV2RWw6YSYmYVswXX0pLHQuZW5hYmxlZHx8KHMmJnMuYWRkQ2xhc3MoZS5sb2NrQ2xhc3MpLGEmJmEuYWRkQ2xhc3MoZS5sb2NrQ2xhc3MpKX1mdW5jdGlvbiB1KCl7Y29uc3R7JG5leHRFbDplLCRwcmV2RWw6c309dC5uYXZpZ2F0aW9uO2UmJmUubGVuZ3RoJiYoZS5vZmYoXCJjbGlja1wiLGMpLGUucmVtb3ZlQ2xhc3ModC5wYXJhbXMubmF2aWdhdGlvbi5kaXNhYmxlZENsYXNzKSkscyYmcy5sZW5ndGgmJihzLm9mZihcImNsaWNrXCIsbykscy5yZW1vdmVDbGFzcyh0LnBhcmFtcy5uYXZpZ2F0aW9uLmRpc2FibGVkQ2xhc3MpKX1zKHtuYXZpZ2F0aW9uOntuZXh0RWw6bnVsbCxwcmV2RWw6bnVsbCxoaWRlT25DbGljazohMSxkaXNhYmxlZENsYXNzOlwic3dpcGVyLWJ1dHRvbi1kaXNhYmxlZFwiLGhpZGRlbkNsYXNzOlwic3dpcGVyLWJ1dHRvbi1oaWRkZW5cIixsb2NrQ2xhc3M6XCJzd2lwZXItYnV0dG9uLWxvY2tcIixuYXZpZ2F0aW9uRGlzYWJsZWRDbGFzczpcInN3aXBlci1uYXZpZ2F0aW9uLWRpc2FibGVkXCJ9fSksdC5uYXZpZ2F0aW9uPXtuZXh0RWw6bnVsbCwkbmV4dEVsOm51bGwscHJldkVsOm51bGwsJHByZXZFbDpudWxsfSxhKFwiaW5pdFwiLCgoKT0+eyExPT09dC5wYXJhbXMubmF2aWdhdGlvbi5lbmFibGVkP2goKToocCgpLGwoKSl9KSksYShcInRvRWRnZSBmcm9tRWRnZSBsb2NrIHVubG9ja1wiLCgoKT0+e2woKX0pKSxhKFwiZGVzdHJveVwiLCgoKT0+e3UoKX0pKSxhKFwiZW5hYmxlIGRpc2FibGVcIiwoKCk9Pntjb25zdHskbmV4dEVsOmUsJHByZXZFbDpzfT10Lm5hdmlnYXRpb247ZSYmZVt0LmVuYWJsZWQ/XCJyZW1vdmVDbGFzc1wiOlwiYWRkQ2xhc3NcIl0odC5wYXJhbXMubmF2aWdhdGlvbi5sb2NrQ2xhc3MpLHMmJnNbdC5lbmFibGVkP1wicmVtb3ZlQ2xhc3NcIjpcImFkZENsYXNzXCJdKHQucGFyYW1zLm5hdmlnYXRpb24ubG9ja0NsYXNzKX0pKSxhKFwiY2xpY2tcIiwoKGUscyk9Pntjb25zdHskbmV4dEVsOmEsJHByZXZFbDpyfT10Lm5hdmlnYXRpb24sbj1zLnRhcmdldDtpZih0LnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGVPbkNsaWNrJiYhZChuKS5pcyhyKSYmIWQobikuaXMoYSkpe2lmKHQucGFnaW5hdGlvbiYmdC5wYXJhbXMucGFnaW5hdGlvbiYmdC5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUmJih0LnBhZ2luYXRpb24uZWw9PT1ufHx0LnBhZ2luYXRpb24uZWwuY29udGFpbnMobikpKXJldHVybjtsZXQgZTthP2U9YS5oYXNDbGFzcyh0LnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTpyJiYoZT1yLmhhc0NsYXNzKHQucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpKSxpKCEwPT09ZT9cIm5hdmlnYXRpb25TaG93XCI6XCJuYXZpZ2F0aW9uSGlkZVwiKSxhJiZhLnRvZ2dsZUNsYXNzKHQucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpLHImJnIudG9nZ2xlQ2xhc3ModC5wYXJhbXMubmF2aWdhdGlvbi5oaWRkZW5DbGFzcyl9fSkpO2NvbnN0IGg9KCk9Pnt0LiRlbC5hZGRDbGFzcyh0LnBhcmFtcy5uYXZpZ2F0aW9uLm5hdmlnYXRpb25EaXNhYmxlZENsYXNzKSx1KCl9O09iamVjdC5hc3NpZ24odC5uYXZpZ2F0aW9uLHtlbmFibGU6KCk9Pnt0LiRlbC5yZW1vdmVDbGFzcyh0LnBhcmFtcy5uYXZpZ2F0aW9uLm5hdmlnYXRpb25EaXNhYmxlZENsYXNzKSxwKCksbCgpfSxkaXNhYmxlOmgsdXBkYXRlOmwsaW5pdDpwLGRlc3Ryb3k6dX0pfSxmdW5jdGlvbihlKXtsZXR7c3dpcGVyOnQsZXh0ZW5kUGFyYW1zOnMsb246YSxlbWl0Oml9PWU7Y29uc3Qgcj1cInN3aXBlci1wYWdpbmF0aW9uXCI7bGV0IG47cyh7cGFnaW5hdGlvbjp7ZWw6bnVsbCxidWxsZXRFbGVtZW50Olwic3BhblwiLGNsaWNrYWJsZTohMSxoaWRlT25DbGljazohMSxyZW5kZXJCdWxsZXQ6bnVsbCxyZW5kZXJQcm9ncmVzc2JhcjpudWxsLHJlbmRlckZyYWN0aW9uOm51bGwscmVuZGVyQ3VzdG9tOm51bGwscHJvZ3Jlc3NiYXJPcHBvc2l0ZTohMSx0eXBlOlwiYnVsbGV0c1wiLGR5bmFtaWNCdWxsZXRzOiExLGR5bmFtaWNNYWluQnVsbGV0czoxLGZvcm1hdEZyYWN0aW9uQ3VycmVudDplPT5lLGZvcm1hdEZyYWN0aW9uVG90YWw6ZT0+ZSxidWxsZXRDbGFzczpgJHtyfS1idWxsZXRgLGJ1bGxldEFjdGl2ZUNsYXNzOmAke3J9LWJ1bGxldC1hY3RpdmVgLG1vZGlmaWVyQ2xhc3M6YCR7cn0tYCxjdXJyZW50Q2xhc3M6YCR7cn0tY3VycmVudGAsdG90YWxDbGFzczpgJHtyfS10b3RhbGAsaGlkZGVuQ2xhc3M6YCR7cn0taGlkZGVuYCxwcm9ncmVzc2JhckZpbGxDbGFzczpgJHtyfS1wcm9ncmVzc2Jhci1maWxsYCxwcm9ncmVzc2Jhck9wcG9zaXRlQ2xhc3M6YCR7cn0tcHJvZ3Jlc3NiYXItb3Bwb3NpdGVgLGNsaWNrYWJsZUNsYXNzOmAke3J9LWNsaWNrYWJsZWAsbG9ja0NsYXNzOmAke3J9LWxvY2tgLGhvcml6b250YWxDbGFzczpgJHtyfS1ob3Jpem9udGFsYCx2ZXJ0aWNhbENsYXNzOmAke3J9LXZlcnRpY2FsYCxwYWdpbmF0aW9uRGlzYWJsZWRDbGFzczpgJHtyfS1kaXNhYmxlZGB9fSksdC5wYWdpbmF0aW9uPXtlbDpudWxsLCRlbDpudWxsLGJ1bGxldHM6W119O2xldCBsPTA7ZnVuY3Rpb24gbygpe3JldHVybiF0LnBhcmFtcy5wYWdpbmF0aW9uLmVsfHwhdC5wYWdpbmF0aW9uLmVsfHwhdC5wYWdpbmF0aW9uLiRlbHx8MD09PXQucGFnaW5hdGlvbi4kZWwubGVuZ3RofWZ1bmN0aW9uIGMoZSxzKXtjb25zdHtidWxsZXRBY3RpdmVDbGFzczphfT10LnBhcmFtcy5wYWdpbmF0aW9uO2Vbc10oKS5hZGRDbGFzcyhgJHthfS0ke3N9YClbc10oKS5hZGRDbGFzcyhgJHthfS0ke3N9LSR7c31gKX1mdW5jdGlvbiBwKCl7Y29uc3QgZT10LnJ0bCxzPXQucGFyYW1zLnBhZ2luYXRpb247aWYobygpKXJldHVybjtjb25zdCBhPXQudmlydHVhbCYmdC5wYXJhbXMudmlydHVhbC5lbmFibGVkP3QudmlydHVhbC5zbGlkZXMubGVuZ3RoOnQuc2xpZGVzLmxlbmd0aCxyPXQucGFnaW5hdGlvbi4kZWw7bGV0IHA7Y29uc3QgdT10LnBhcmFtcy5sb29wP01hdGguY2VpbCgoYS0yKnQubG9vcGVkU2xpZGVzKS90LnBhcmFtcy5zbGlkZXNQZXJHcm91cCk6dC5zbmFwR3JpZC5sZW5ndGg7aWYodC5wYXJhbXMubG9vcD8ocD1NYXRoLmNlaWwoKHQuYWN0aXZlSW5kZXgtdC5sb29wZWRTbGlkZXMpL3QucGFyYW1zLnNsaWRlc1Blckdyb3VwKSxwPmEtMS0yKnQubG9vcGVkU2xpZGVzJiYocC09YS0yKnQubG9vcGVkU2xpZGVzKSxwPnUtMSYmKHAtPXUpLHA8MCYmXCJidWxsZXRzXCIhPT10LnBhcmFtcy5wYWdpbmF0aW9uVHlwZSYmKHA9dStwKSk6cD12b2lkIDAhPT10LnNuYXBJbmRleD90LnNuYXBJbmRleDp0LmFjdGl2ZUluZGV4fHwwLFwiYnVsbGV0c1wiPT09cy50eXBlJiZ0LnBhZ2luYXRpb24uYnVsbGV0cyYmdC5wYWdpbmF0aW9uLmJ1bGxldHMubGVuZ3RoPjApe2NvbnN0IGE9dC5wYWdpbmF0aW9uLmJ1bGxldHM7bGV0IGksbyx1O2lmKHMuZHluYW1pY0J1bGxldHMmJihuPWEuZXEoMClbdC5pc0hvcml6b250YWwoKT9cIm91dGVyV2lkdGhcIjpcIm91dGVySGVpZ2h0XCJdKCEwKSxyLmNzcyh0LmlzSG9yaXpvbnRhbCgpP1wid2lkdGhcIjpcImhlaWdodFwiLG4qKHMuZHluYW1pY01haW5CdWxsZXRzKzQpK1wicHhcIikscy5keW5hbWljTWFpbkJ1bGxldHM+MSYmdm9pZCAwIT09dC5wcmV2aW91c0luZGV4JiYobCs9cC0odC5wcmV2aW91c0luZGV4LXQubG9vcGVkU2xpZGVzfHwwKSxsPnMuZHluYW1pY01haW5CdWxsZXRzLTE/bD1zLmR5bmFtaWNNYWluQnVsbGV0cy0xOmw8MCYmKGw9MCkpLGk9TWF0aC5tYXgocC1sLDApLG89aSsoTWF0aC5taW4oYS5sZW5ndGgscy5keW5hbWljTWFpbkJ1bGxldHMpLTEpLHU9KG8raSkvMiksYS5yZW1vdmVDbGFzcyhbXCJcIixcIi1uZXh0XCIsXCItbmV4dC1uZXh0XCIsXCItcHJldlwiLFwiLXByZXYtcHJldlwiLFwiLW1haW5cIl0ubWFwKChlPT5gJHtzLmJ1bGxldEFjdGl2ZUNsYXNzfSR7ZX1gKSkuam9pbihcIiBcIikpLHIubGVuZ3RoPjEpYS5lYWNoKChlPT57Y29uc3QgdD1kKGUpLGE9dC5pbmRleCgpO2E9PT1wJiZ0LmFkZENsYXNzKHMuYnVsbGV0QWN0aXZlQ2xhc3MpLHMuZHluYW1pY0J1bGxldHMmJihhPj1pJiZhPD1vJiZ0LmFkZENsYXNzKGAke3MuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gKSxhPT09aSYmYyh0LFwicHJldlwiKSxhPT09byYmYyh0LFwibmV4dFwiKSl9KSk7ZWxzZXtjb25zdCBlPWEuZXEocCkscj1lLmluZGV4KCk7aWYoZS5hZGRDbGFzcyhzLmJ1bGxldEFjdGl2ZUNsYXNzKSxzLmR5bmFtaWNCdWxsZXRzKXtjb25zdCBlPWEuZXEoaSksbj1hLmVxKG8pO2ZvcihsZXQgZT1pO2U8PW87ZSs9MSlhLmVxKGUpLmFkZENsYXNzKGAke3MuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gKTtpZih0LnBhcmFtcy5sb29wKWlmKHI+PWEubGVuZ3RoKXtmb3IobGV0IGU9cy5keW5hbWljTWFpbkJ1bGxldHM7ZT49MDtlLT0xKWEuZXEoYS5sZW5ndGgtZSkuYWRkQ2xhc3MoYCR7cy5idWxsZXRBY3RpdmVDbGFzc30tbWFpbmApO2EuZXEoYS5sZW5ndGgtcy5keW5hbWljTWFpbkJ1bGxldHMtMSkuYWRkQ2xhc3MoYCR7cy5idWxsZXRBY3RpdmVDbGFzc30tcHJldmApfWVsc2UgYyhlLFwicHJldlwiKSxjKG4sXCJuZXh0XCIpO2Vsc2UgYyhlLFwicHJldlwiKSxjKG4sXCJuZXh0XCIpfX1pZihzLmR5bmFtaWNCdWxsZXRzKXtjb25zdCBpPU1hdGgubWluKGEubGVuZ3RoLHMuZHluYW1pY01haW5CdWxsZXRzKzQpLHI9KG4qaS1uKS8yLXUqbixsPWU/XCJyaWdodFwiOlwibGVmdFwiO2EuY3NzKHQuaXNIb3Jpem9udGFsKCk/bDpcInRvcFwiLGAke3J9cHhgKX19aWYoXCJmcmFjdGlvblwiPT09cy50eXBlJiYoci5maW5kKFUocy5jdXJyZW50Q2xhc3MpKS50ZXh0KHMuZm9ybWF0RnJhY3Rpb25DdXJyZW50KHArMSkpLHIuZmluZChVKHMudG90YWxDbGFzcykpLnRleHQocy5mb3JtYXRGcmFjdGlvblRvdGFsKHUpKSksXCJwcm9ncmVzc2JhclwiPT09cy50eXBlKXtsZXQgZTtlPXMucHJvZ3Jlc3NiYXJPcHBvc2l0ZT90LmlzSG9yaXpvbnRhbCgpP1widmVydGljYWxcIjpcImhvcml6b250YWxcIjp0LmlzSG9yaXpvbnRhbCgpP1wiaG9yaXpvbnRhbFwiOlwidmVydGljYWxcIjtjb25zdCBhPShwKzEpL3U7bGV0IGk9MSxuPTE7XCJob3Jpem9udGFsXCI9PT1lP2k9YTpuPWEsci5maW5kKFUocy5wcm9ncmVzc2JhckZpbGxDbGFzcykpLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlWCgke2l9KSBzY2FsZVkoJHtufSlgKS50cmFuc2l0aW9uKHQucGFyYW1zLnNwZWVkKX1cImN1c3RvbVwiPT09cy50eXBlJiZzLnJlbmRlckN1c3RvbT8oci5odG1sKHMucmVuZGVyQ3VzdG9tKHQscCsxLHUpKSxpKFwicGFnaW5hdGlvblJlbmRlclwiLHJbMF0pKTppKFwicGFnaW5hdGlvblVwZGF0ZVwiLHJbMF0pLHQucGFyYW1zLndhdGNoT3ZlcmZsb3cmJnQuZW5hYmxlZCYmclt0LmlzTG9ja2VkP1wiYWRkQ2xhc3NcIjpcInJlbW92ZUNsYXNzXCJdKHMubG9ja0NsYXNzKX1mdW5jdGlvbiB1KCl7Y29uc3QgZT10LnBhcmFtcy5wYWdpbmF0aW9uO2lmKG8oKSlyZXR1cm47Y29uc3Qgcz10LnZpcnR1YWwmJnQucGFyYW1zLnZpcnR1YWwuZW5hYmxlZD90LnZpcnR1YWwuc2xpZGVzLmxlbmd0aDp0LnNsaWRlcy5sZW5ndGgsYT10LnBhZ2luYXRpb24uJGVsO2xldCByPVwiXCI7aWYoXCJidWxsZXRzXCI9PT1lLnR5cGUpe2xldCBpPXQucGFyYW1zLmxvb3A/TWF0aC5jZWlsKChzLTIqdC5sb29wZWRTbGlkZXMpL3QucGFyYW1zLnNsaWRlc1Blckdyb3VwKTp0LnNuYXBHcmlkLmxlbmd0aDt0LnBhcmFtcy5mcmVlTW9kZSYmdC5wYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCYmIXQucGFyYW1zLmxvb3AmJmk+cyYmKGk9cyk7Zm9yKGxldCBzPTA7czxpO3MrPTEpZS5yZW5kZXJCdWxsZXQ/cis9ZS5yZW5kZXJCdWxsZXQuY2FsbCh0LHMsZS5idWxsZXRDbGFzcyk6cis9YDwke2UuYnVsbGV0RWxlbWVudH0gY2xhc3M9XCIke2UuYnVsbGV0Q2xhc3N9XCI+PC8ke2UuYnVsbGV0RWxlbWVudH0+YDthLmh0bWwociksdC5wYWdpbmF0aW9uLmJ1bGxldHM9YS5maW5kKFUoZS5idWxsZXRDbGFzcykpfVwiZnJhY3Rpb25cIj09PWUudHlwZSYmKHI9ZS5yZW5kZXJGcmFjdGlvbj9lLnJlbmRlckZyYWN0aW9uLmNhbGwodCxlLmN1cnJlbnRDbGFzcyxlLnRvdGFsQ2xhc3MpOmA8c3BhbiBjbGFzcz1cIiR7ZS5jdXJyZW50Q2xhc3N9XCI+PC9zcGFuPiAvIDxzcGFuIGNsYXNzPVwiJHtlLnRvdGFsQ2xhc3N9XCI+PC9zcGFuPmAsYS5odG1sKHIpKSxcInByb2dyZXNzYmFyXCI9PT1lLnR5cGUmJihyPWUucmVuZGVyUHJvZ3Jlc3NiYXI/ZS5yZW5kZXJQcm9ncmVzc2Jhci5jYWxsKHQsZS5wcm9ncmVzc2JhckZpbGxDbGFzcyk6YDxzcGFuIGNsYXNzPVwiJHtlLnByb2dyZXNzYmFyRmlsbENsYXNzfVwiPjwvc3Bhbj5gLGEuaHRtbChyKSksXCJjdXN0b21cIiE9PWUudHlwZSYmaShcInBhZ2luYXRpb25SZW5kZXJcIix0LnBhZ2luYXRpb24uJGVsWzBdKX1mdW5jdGlvbiBoKCl7dC5wYXJhbXMucGFnaW5hdGlvbj1GKHQsdC5vcmlnaW5hbFBhcmFtcy5wYWdpbmF0aW9uLHQucGFyYW1zLnBhZ2luYXRpb24se2VsOlwic3dpcGVyLXBhZ2luYXRpb25cIn0pO2NvbnN0IGU9dC5wYXJhbXMucGFnaW5hdGlvbjtpZighZS5lbClyZXR1cm47bGV0IHM9ZChlLmVsKTswIT09cy5sZW5ndGgmJih0LnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyYmXCJzdHJpbmdcIj09dHlwZW9mIGUuZWwmJnMubGVuZ3RoPjEmJihzPXQuJGVsLmZpbmQoZS5lbCkscy5sZW5ndGg+MSYmKHM9cy5maWx0ZXIoKGU9PmQoZSkucGFyZW50cyhcIi5zd2lwZXJcIilbMF09PT10LmVsKSkpKSxcImJ1bGxldHNcIj09PWUudHlwZSYmZS5jbGlja2FibGUmJnMuYWRkQ2xhc3MoZS5jbGlja2FibGVDbGFzcykscy5hZGRDbGFzcyhlLm1vZGlmaWVyQ2xhc3MrZS50eXBlKSxzLmFkZENsYXNzKHQuaXNIb3Jpem9udGFsKCk/ZS5ob3Jpem9udGFsQ2xhc3M6ZS52ZXJ0aWNhbENsYXNzKSxcImJ1bGxldHNcIj09PWUudHlwZSYmZS5keW5hbWljQnVsbGV0cyYmKHMuYWRkQ2xhc3MoYCR7ZS5tb2RpZmllckNsYXNzfSR7ZS50eXBlfS1keW5hbWljYCksbD0wLGUuZHluYW1pY01haW5CdWxsZXRzPDEmJihlLmR5bmFtaWNNYWluQnVsbGV0cz0xKSksXCJwcm9ncmVzc2JhclwiPT09ZS50eXBlJiZlLnByb2dyZXNzYmFyT3Bwb3NpdGUmJnMuYWRkQ2xhc3MoZS5wcm9ncmVzc2Jhck9wcG9zaXRlQ2xhc3MpLGUuY2xpY2thYmxlJiZzLm9uKFwiY2xpY2tcIixVKGUuYnVsbGV0Q2xhc3MpLChmdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0KCk7bGV0IHM9ZCh0aGlzKS5pbmRleCgpKnQucGFyYW1zLnNsaWRlc1Blckdyb3VwO3QucGFyYW1zLmxvb3AmJihzKz10Lmxvb3BlZFNsaWRlcyksdC5zbGlkZVRvKHMpfSkpLE9iamVjdC5hc3NpZ24odC5wYWdpbmF0aW9uLHskZWw6cyxlbDpzWzBdfSksdC5lbmFibGVkfHxzLmFkZENsYXNzKGUubG9ja0NsYXNzKSl9ZnVuY3Rpb24gbSgpe2NvbnN0IGU9dC5wYXJhbXMucGFnaW5hdGlvbjtpZihvKCkpcmV0dXJuO2NvbnN0IHM9dC5wYWdpbmF0aW9uLiRlbDtzLnJlbW92ZUNsYXNzKGUuaGlkZGVuQ2xhc3MpLHMucmVtb3ZlQ2xhc3MoZS5tb2RpZmllckNsYXNzK2UudHlwZSkscy5yZW1vdmVDbGFzcyh0LmlzSG9yaXpvbnRhbCgpP2UuaG9yaXpvbnRhbENsYXNzOmUudmVydGljYWxDbGFzcyksdC5wYWdpbmF0aW9uLmJ1bGxldHMmJnQucGFnaW5hdGlvbi5idWxsZXRzLnJlbW92ZUNsYXNzJiZ0LnBhZ2luYXRpb24uYnVsbGV0cy5yZW1vdmVDbGFzcyhlLmJ1bGxldEFjdGl2ZUNsYXNzKSxlLmNsaWNrYWJsZSYmcy5vZmYoXCJjbGlja1wiLFUoZS5idWxsZXRDbGFzcykpfWEoXCJpbml0XCIsKCgpPT57ITE9PT10LnBhcmFtcy5wYWdpbmF0aW9uLmVuYWJsZWQ/ZigpOihoKCksdSgpLHAoKSl9KSksYShcImFjdGl2ZUluZGV4Q2hhbmdlXCIsKCgpPT57KHQucGFyYW1zLmxvb3B8fHZvaWQgMD09PXQuc25hcEluZGV4KSYmcCgpfSkpLGEoXCJzbmFwSW5kZXhDaGFuZ2VcIiwoKCk9Pnt0LnBhcmFtcy5sb29wfHxwKCl9KSksYShcInNsaWRlc0xlbmd0aENoYW5nZVwiLCgoKT0+e3QucGFyYW1zLmxvb3AmJih1KCkscCgpKX0pKSxhKFwic25hcEdyaWRMZW5ndGhDaGFuZ2VcIiwoKCk9Pnt0LnBhcmFtcy5sb29wfHwodSgpLHAoKSl9KSksYShcImRlc3Ryb3lcIiwoKCk9PnttKCl9KSksYShcImVuYWJsZSBkaXNhYmxlXCIsKCgpPT57Y29uc3R7JGVsOmV9PXQucGFnaW5hdGlvbjtlJiZlW3QuZW5hYmxlZD9cInJlbW92ZUNsYXNzXCI6XCJhZGRDbGFzc1wiXSh0LnBhcmFtcy5wYWdpbmF0aW9uLmxvY2tDbGFzcyl9KSksYShcImxvY2sgdW5sb2NrXCIsKCgpPT57cCgpfSkpLGEoXCJjbGlja1wiLCgoZSxzKT0+e2NvbnN0IGE9cy50YXJnZXQseyRlbDpyfT10LnBhZ2luYXRpb247aWYodC5wYXJhbXMucGFnaW5hdGlvbi5lbCYmdC5wYXJhbXMucGFnaW5hdGlvbi5oaWRlT25DbGljayYmci5sZW5ndGg+MCYmIWQoYSkuaGFzQ2xhc3ModC5wYXJhbXMucGFnaW5hdGlvbi5idWxsZXRDbGFzcykpe2lmKHQubmF2aWdhdGlvbiYmKHQubmF2aWdhdGlvbi5uZXh0RWwmJmE9PT10Lm5hdmlnYXRpb24ubmV4dEVsfHx0Lm5hdmlnYXRpb24ucHJldkVsJiZhPT09dC5uYXZpZ2F0aW9uLnByZXZFbCkpcmV0dXJuO2NvbnN0IGU9ci5oYXNDbGFzcyh0LnBhcmFtcy5wYWdpbmF0aW9uLmhpZGRlbkNsYXNzKTtpKCEwPT09ZT9cInBhZ2luYXRpb25TaG93XCI6XCJwYWdpbmF0aW9uSGlkZVwiKSxyLnRvZ2dsZUNsYXNzKHQucGFyYW1zLnBhZ2luYXRpb24uaGlkZGVuQ2xhc3MpfX0pKTtjb25zdCBmPSgpPT57dC4kZWwuYWRkQ2xhc3ModC5wYXJhbXMucGFnaW5hdGlvbi5wYWdpbmF0aW9uRGlzYWJsZWRDbGFzcyksdC5wYWdpbmF0aW9uLiRlbCYmdC5wYWdpbmF0aW9uLiRlbC5hZGRDbGFzcyh0LnBhcmFtcy5wYWdpbmF0aW9uLnBhZ2luYXRpb25EaXNhYmxlZENsYXNzKSxtKCl9O09iamVjdC5hc3NpZ24odC5wYWdpbmF0aW9uLHtlbmFibGU6KCk9Pnt0LiRlbC5yZW1vdmVDbGFzcyh0LnBhcmFtcy5wYWdpbmF0aW9uLnBhZ2luYXRpb25EaXNhYmxlZENsYXNzKSx0LnBhZ2luYXRpb24uJGVsJiZ0LnBhZ2luYXRpb24uJGVsLnJlbW92ZUNsYXNzKHQucGFyYW1zLnBhZ2luYXRpb24ucGFnaW5hdGlvbkRpc2FibGVkQ2xhc3MpLGgoKSx1KCkscCgpfSxkaXNhYmxlOmYscmVuZGVyOnUsdXBkYXRlOnAsaW5pdDpoLGRlc3Ryb3k6bX0pfSxmdW5jdGlvbihlKXtsZXR7c3dpcGVyOnQsZXh0ZW5kUGFyYW1zOnMsb246aSxlbWl0OnJ9PWU7Y29uc3Qgbj1hKCk7bGV0IGwsbyxjLHUsaD0hMSxtPW51bGwsZj1udWxsO2Z1bmN0aW9uIGcoKXtpZighdC5wYXJhbXMuc2Nyb2xsYmFyLmVsfHwhdC5zY3JvbGxiYXIuZWwpcmV0dXJuO2NvbnN0e3Njcm9sbGJhcjplLHJ0bFRyYW5zbGF0ZTpzLHByb2dyZXNzOmF9PXQseyRkcmFnRWw6aSwkZWw6cn09ZSxuPXQucGFyYW1zLnNjcm9sbGJhcjtsZXQgbD1vLGQ9KGMtbykqYTtzPyhkPS1kLGQ+MD8obD1vLWQsZD0wKTotZCtvPmMmJihsPWMrZCkpOmQ8MD8obD1vK2QsZD0wKTpkK28+YyYmKGw9Yy1kKSx0LmlzSG9yaXpvbnRhbCgpPyhpLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtkfXB4LCAwLCAwKWApLGlbMF0uc3R5bGUud2lkdGg9YCR7bH1weGApOihpLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMHB4LCAke2R9cHgsIDApYCksaVswXS5zdHlsZS5oZWlnaHQ9YCR7bH1weGApLG4uaGlkZSYmKGNsZWFyVGltZW91dChtKSxyWzBdLnN0eWxlLm9wYWNpdHk9MSxtPXNldFRpbWVvdXQoKCgpPT57clswXS5zdHlsZS5vcGFjaXR5PTAsci50cmFuc2l0aW9uKDQwMCl9KSwxZTMpKX1mdW5jdGlvbiB2KCl7aWYoIXQucGFyYW1zLnNjcm9sbGJhci5lbHx8IXQuc2Nyb2xsYmFyLmVsKXJldHVybjtjb25zdHtzY3JvbGxiYXI6ZX09dCx7JGRyYWdFbDpzLCRlbDphfT1lO3NbMF0uc3R5bGUud2lkdGg9XCJcIixzWzBdLnN0eWxlLmhlaWdodD1cIlwiLGM9dC5pc0hvcml6b250YWwoKT9hWzBdLm9mZnNldFdpZHRoOmFbMF0ub2Zmc2V0SGVpZ2h0LHU9dC5zaXplLyh0LnZpcnR1YWxTaXplK3QucGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZS0odC5wYXJhbXMuY2VudGVyZWRTbGlkZXM/dC5zbmFwR3JpZFswXTowKSksbz1cImF1dG9cIj09PXQucGFyYW1zLnNjcm9sbGJhci5kcmFnU2l6ZT9jKnU6cGFyc2VJbnQodC5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdTaXplLDEwKSx0LmlzSG9yaXpvbnRhbCgpP3NbMF0uc3R5bGUud2lkdGg9YCR7b31weGA6c1swXS5zdHlsZS5oZWlnaHQ9YCR7b31weGAsYVswXS5zdHlsZS5kaXNwbGF5PXU+PTE/XCJub25lXCI6XCJcIix0LnBhcmFtcy5zY3JvbGxiYXIuaGlkZSYmKGFbMF0uc3R5bGUub3BhY2l0eT0wKSx0LnBhcmFtcy53YXRjaE92ZXJmbG93JiZ0LmVuYWJsZWQmJmUuJGVsW3QuaXNMb2NrZWQ/XCJhZGRDbGFzc1wiOlwicmVtb3ZlQ2xhc3NcIl0odC5wYXJhbXMuc2Nyb2xsYmFyLmxvY2tDbGFzcyl9ZnVuY3Rpb24gdyhlKXtyZXR1cm4gdC5pc0hvcml6b250YWwoKT9cInRvdWNoc3RhcnRcIj09PWUudHlwZXx8XCJ0b3VjaG1vdmVcIj09PWUudHlwZT9lLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WDplLmNsaWVudFg6XCJ0b3VjaHN0YXJ0XCI9PT1lLnR5cGV8fFwidG91Y2htb3ZlXCI9PT1lLnR5cGU/ZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFk6ZS5jbGllbnRZfWZ1bmN0aW9uIGIoZSl7Y29uc3R7c2Nyb2xsYmFyOnMscnRsVHJhbnNsYXRlOmF9PXQseyRlbDppfT1zO2xldCByO3I9KHcoZSktaS5vZmZzZXQoKVt0LmlzSG9yaXpvbnRhbCgpP1wibGVmdFwiOlwidG9wXCJdLShudWxsIT09bD9sOm8vMikpLyhjLW8pLHI9TWF0aC5tYXgoTWF0aC5taW4ociwxKSwwKSxhJiYocj0xLXIpO2NvbnN0IG49dC5taW5UcmFuc2xhdGUoKSsodC5tYXhUcmFuc2xhdGUoKS10Lm1pblRyYW5zbGF0ZSgpKSpyO3QudXBkYXRlUHJvZ3Jlc3MobiksdC5zZXRUcmFuc2xhdGUobiksdC51cGRhdGVBY3RpdmVJbmRleCgpLHQudXBkYXRlU2xpZGVzQ2xhc3NlcygpfWZ1bmN0aW9uIHgoZSl7Y29uc3Qgcz10LnBhcmFtcy5zY3JvbGxiYXIse3Njcm9sbGJhcjphLCR3cmFwcGVyRWw6aX09dCx7JGVsOm4sJGRyYWdFbDpvfT1hO2g9ITAsbD1lLnRhcmdldD09PW9bMF18fGUudGFyZ2V0PT09bz93KGUpLWUudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3QuaXNIb3Jpem9udGFsKCk/XCJsZWZ0XCI6XCJ0b3BcIl06bnVsbCxlLnByZXZlbnREZWZhdWx0KCksZS5zdG9wUHJvcGFnYXRpb24oKSxpLnRyYW5zaXRpb24oMTAwKSxvLnRyYW5zaXRpb24oMTAwKSxiKGUpLGNsZWFyVGltZW91dChmKSxuLnRyYW5zaXRpb24oMCkscy5oaWRlJiZuLmNzcyhcIm9wYWNpdHlcIiwxKSx0LnBhcmFtcy5jc3NNb2RlJiZ0LiR3cmFwcGVyRWwuY3NzKFwic2Nyb2xsLXNuYXAtdHlwZVwiLFwibm9uZVwiKSxyKFwic2Nyb2xsYmFyRHJhZ1N0YXJ0XCIsZSl9ZnVuY3Rpb24geShlKXtjb25zdHtzY3JvbGxiYXI6cywkd3JhcHBlckVsOmF9PXQseyRlbDppLCRkcmFnRWw6bn09cztoJiYoZS5wcmV2ZW50RGVmYXVsdD9lLnByZXZlbnREZWZhdWx0KCk6ZS5yZXR1cm5WYWx1ZT0hMSxiKGUpLGEudHJhbnNpdGlvbigwKSxpLnRyYW5zaXRpb24oMCksbi50cmFuc2l0aW9uKDApLHIoXCJzY3JvbGxiYXJEcmFnTW92ZVwiLGUpKX1mdW5jdGlvbiBFKGUpe2NvbnN0IHM9dC5wYXJhbXMuc2Nyb2xsYmFyLHtzY3JvbGxiYXI6YSwkd3JhcHBlckVsOml9PXQseyRlbDpufT1hO2gmJihoPSExLHQucGFyYW1zLmNzc01vZGUmJih0LiR3cmFwcGVyRWwuY3NzKFwic2Nyb2xsLXNuYXAtdHlwZVwiLFwiXCIpLGkudHJhbnNpdGlvbihcIlwiKSkscy5oaWRlJiYoY2xlYXJUaW1lb3V0KGYpLGY9cCgoKCk9PntuLmNzcyhcIm9wYWNpdHlcIiwwKSxuLnRyYW5zaXRpb24oNDAwKX0pLDFlMykpLHIoXCJzY3JvbGxiYXJEcmFnRW5kXCIsZSkscy5zbmFwT25SZWxlYXNlJiZ0LnNsaWRlVG9DbG9zZXN0KCkpfWZ1bmN0aW9uIEMoZSl7Y29uc3R7c2Nyb2xsYmFyOnMsdG91Y2hFdmVudHNUb3VjaDphLHRvdWNoRXZlbnRzRGVza3RvcDppLHBhcmFtczpyLHN1cHBvcnQ6bH09dCxvPXMuJGVsO2lmKCFvKXJldHVybjtjb25zdCBkPW9bMF0sYz0hKCFsLnBhc3NpdmVMaXN0ZW5lcnx8IXIucGFzc2l2ZUxpc3RlbmVycykmJntwYXNzaXZlOiExLGNhcHR1cmU6ITF9LHA9ISghbC5wYXNzaXZlTGlzdGVuZXJ8fCFyLnBhc3NpdmVMaXN0ZW5lcnMpJiZ7cGFzc2l2ZTohMCxjYXB0dXJlOiExfTtpZighZClyZXR1cm47Y29uc3QgdT1cIm9uXCI9PT1lP1wiYWRkRXZlbnRMaXN0ZW5lclwiOlwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiO2wudG91Y2g/KGRbdV0oYS5zdGFydCx4LGMpLGRbdV0oYS5tb3ZlLHksYyksZFt1XShhLmVuZCxFLHApKTooZFt1XShpLnN0YXJ0LHgsYyksblt1XShpLm1vdmUseSxjKSxuW3VdKGkuZW5kLEUscCkpfWZ1bmN0aW9uIFQoKXtjb25zdHtzY3JvbGxiYXI6ZSwkZWw6c309dDt0LnBhcmFtcy5zY3JvbGxiYXI9Rih0LHQub3JpZ2luYWxQYXJhbXMuc2Nyb2xsYmFyLHQucGFyYW1zLnNjcm9sbGJhcix7ZWw6XCJzd2lwZXItc2Nyb2xsYmFyXCJ9KTtjb25zdCBhPXQucGFyYW1zLnNjcm9sbGJhcjtpZighYS5lbClyZXR1cm47bGV0IGk9ZChhLmVsKTt0LnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyYmXCJzdHJpbmdcIj09dHlwZW9mIGEuZWwmJmkubGVuZ3RoPjEmJjE9PT1zLmZpbmQoYS5lbCkubGVuZ3RoJiYoaT1zLmZpbmQoYS5lbCkpLGkuYWRkQ2xhc3ModC5pc0hvcml6b250YWwoKT9hLmhvcml6b250YWxDbGFzczphLnZlcnRpY2FsQ2xhc3MpO2xldCByPWkuZmluZChgLiR7dC5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdDbGFzc31gKTswPT09ci5sZW5ndGgmJihyPWQoYDxkaXYgY2xhc3M9XCIke3QucGFyYW1zLnNjcm9sbGJhci5kcmFnQ2xhc3N9XCI+PC9kaXY+YCksaS5hcHBlbmQocikpLE9iamVjdC5hc3NpZ24oZSx7JGVsOmksZWw6aVswXSwkZHJhZ0VsOnIsZHJhZ0VsOnJbMF19KSxhLmRyYWdnYWJsZSYmdC5wYXJhbXMuc2Nyb2xsYmFyLmVsJiZ0LnNjcm9sbGJhci5lbCYmQyhcIm9uXCIpLGkmJmlbdC5lbmFibGVkP1wicmVtb3ZlQ2xhc3NcIjpcImFkZENsYXNzXCJdKHQucGFyYW1zLnNjcm9sbGJhci5sb2NrQ2xhc3MpfWZ1bmN0aW9uICQoKXtjb25zdCBlPXQucGFyYW1zLnNjcm9sbGJhcixzPXQuc2Nyb2xsYmFyLiRlbDtzJiZzLnJlbW92ZUNsYXNzKHQuaXNIb3Jpem9udGFsKCk/ZS5ob3Jpem9udGFsQ2xhc3M6ZS52ZXJ0aWNhbENsYXNzKSx0LnBhcmFtcy5zY3JvbGxiYXIuZWwmJnQuc2Nyb2xsYmFyLmVsJiZDKFwib2ZmXCIpfXMoe3Njcm9sbGJhcjp7ZWw6bnVsbCxkcmFnU2l6ZTpcImF1dG9cIixoaWRlOiExLGRyYWdnYWJsZTohMSxzbmFwT25SZWxlYXNlOiEwLGxvY2tDbGFzczpcInN3aXBlci1zY3JvbGxiYXItbG9ja1wiLGRyYWdDbGFzczpcInN3aXBlci1zY3JvbGxiYXItZHJhZ1wiLHNjcm9sbGJhckRpc2FibGVkQ2xhc3M6XCJzd2lwZXItc2Nyb2xsYmFyLWRpc2FibGVkXCIsaG9yaXpvbnRhbENsYXNzOlwic3dpcGVyLXNjcm9sbGJhci1ob3Jpem9udGFsXCIsdmVydGljYWxDbGFzczpcInN3aXBlci1zY3JvbGxiYXItdmVydGljYWxcIn19KSx0LnNjcm9sbGJhcj17ZWw6bnVsbCxkcmFnRWw6bnVsbCwkZWw6bnVsbCwkZHJhZ0VsOm51bGx9LGkoXCJpbml0XCIsKCgpPT57ITE9PT10LnBhcmFtcy5zY3JvbGxiYXIuZW5hYmxlZD9TKCk6KFQoKSx2KCksZygpKX0pKSxpKFwidXBkYXRlIHJlc2l6ZSBvYnNlcnZlclVwZGF0ZSBsb2NrIHVubG9ja1wiLCgoKT0+e3YoKX0pKSxpKFwic2V0VHJhbnNsYXRlXCIsKCgpPT57ZygpfSkpLGkoXCJzZXRUcmFuc2l0aW9uXCIsKChlLHMpPT57IWZ1bmN0aW9uKGUpe3QucGFyYW1zLnNjcm9sbGJhci5lbCYmdC5zY3JvbGxiYXIuZWwmJnQuc2Nyb2xsYmFyLiRkcmFnRWwudHJhbnNpdGlvbihlKX0ocyl9KSksaShcImVuYWJsZSBkaXNhYmxlXCIsKCgpPT57Y29uc3R7JGVsOmV9PXQuc2Nyb2xsYmFyO2UmJmVbdC5lbmFibGVkP1wicmVtb3ZlQ2xhc3NcIjpcImFkZENsYXNzXCJdKHQucGFyYW1zLnNjcm9sbGJhci5sb2NrQ2xhc3MpfSkpLGkoXCJkZXN0cm95XCIsKCgpPT57JCgpfSkpO2NvbnN0IFM9KCk9Pnt0LiRlbC5hZGRDbGFzcyh0LnBhcmFtcy5zY3JvbGxiYXIuc2Nyb2xsYmFyRGlzYWJsZWRDbGFzcyksdC5zY3JvbGxiYXIuJGVsJiZ0LnNjcm9sbGJhci4kZWwuYWRkQ2xhc3ModC5wYXJhbXMuc2Nyb2xsYmFyLnNjcm9sbGJhckRpc2FibGVkQ2xhc3MpLCQoKX07T2JqZWN0LmFzc2lnbih0LnNjcm9sbGJhcix7ZW5hYmxlOigpPT57dC4kZWwucmVtb3ZlQ2xhc3ModC5wYXJhbXMuc2Nyb2xsYmFyLnNjcm9sbGJhckRpc2FibGVkQ2xhc3MpLHQuc2Nyb2xsYmFyLiRlbCYmdC5zY3JvbGxiYXIuJGVsLnJlbW92ZUNsYXNzKHQucGFyYW1zLnNjcm9sbGJhci5zY3JvbGxiYXJEaXNhYmxlZENsYXNzKSxUKCksdigpLGcoKX0sZGlzYWJsZTpTLHVwZGF0ZVNpemU6dixzZXRUcmFuc2xhdGU6Zyxpbml0OlQsZGVzdHJveTokfSl9LGZ1bmN0aW9uKGUpe2xldHtzd2lwZXI6dCxleHRlbmRQYXJhbXM6cyxvbjphfT1lO3Moe3BhcmFsbGF4OntlbmFibGVkOiExfX0pO2NvbnN0IGk9KGUscyk9Pntjb25zdHtydGw6YX09dCxpPWQoZSkscj1hPy0xOjEsbj1pLmF0dHIoXCJkYXRhLXN3aXBlci1wYXJhbGxheFwiKXx8XCIwXCI7bGV0IGw9aS5hdHRyKFwiZGF0YS1zd2lwZXItcGFyYWxsYXgteFwiKSxvPWkuYXR0cihcImRhdGEtc3dpcGVyLXBhcmFsbGF4LXlcIik7Y29uc3QgYz1pLmF0dHIoXCJkYXRhLXN3aXBlci1wYXJhbGxheC1zY2FsZVwiKSxwPWkuYXR0cihcImRhdGEtc3dpcGVyLXBhcmFsbGF4LW9wYWNpdHlcIik7aWYobHx8bz8obD1sfHxcIjBcIixvPW98fFwiMFwiKTp0LmlzSG9yaXpvbnRhbCgpPyhsPW4sbz1cIjBcIik6KG89bixsPVwiMFwiKSxsPWwuaW5kZXhPZihcIiVcIik+PTA/cGFyc2VJbnQobCwxMCkqcypyK1wiJVwiOmwqcypyK1wicHhcIixvPW8uaW5kZXhPZihcIiVcIik+PTA/cGFyc2VJbnQobywxMCkqcytcIiVcIjpvKnMrXCJweFwiLG51bGwhPXApe2NvbnN0IGU9cC0ocC0xKSooMS1NYXRoLmFicyhzKSk7aVswXS5zdHlsZS5vcGFjaXR5PWV9aWYobnVsbD09YylpLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtsfSwgJHtvfSwgMHB4KWApO2Vsc2V7Y29uc3QgZT1jLShjLTEpKigxLU1hdGguYWJzKHMpKTtpLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtsfSwgJHtvfSwgMHB4KSBzY2FsZSgke2V9KWApfX0scj0oKT0+e2NvbnN0eyRlbDplLHNsaWRlczpzLHByb2dyZXNzOmEsc25hcEdyaWQ6cn09dDtlLmNoaWxkcmVuKFwiW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXVwiKS5lYWNoKChlPT57aShlLGEpfSkpLHMuZWFjaCgoKGUscyk9PntsZXQgbj1lLnByb2dyZXNzO3QucGFyYW1zLnNsaWRlc1Blckdyb3VwPjEmJlwiYXV0b1wiIT09dC5wYXJhbXMuc2xpZGVzUGVyVmlldyYmKG4rPU1hdGguY2VpbChzLzIpLWEqKHIubGVuZ3RoLTEpKSxuPU1hdGgubWluKE1hdGgubWF4KG4sLTEpLDEpLGQoZSkuZmluZChcIltkYXRhLXN3aXBlci1wYXJhbGxheF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC14XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXldLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgtb3BhY2l0eV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1zY2FsZV1cIikuZWFjaCgoZT0+e2koZSxuKX0pKX0pKX07YShcImJlZm9yZUluaXRcIiwoKCk9Pnt0LnBhcmFtcy5wYXJhbGxheC5lbmFibGVkJiYodC5wYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcz0hMCx0Lm9yaWdpbmFsUGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3M9ITApfSkpLGEoXCJpbml0XCIsKCgpPT57dC5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCYmcigpfSkpLGEoXCJzZXRUcmFuc2xhdGVcIiwoKCk9Pnt0LnBhcmFtcy5wYXJhbGxheC5lbmFibGVkJiZyKCl9KSksYShcInNldFRyYW5zaXRpb25cIiwoKGUscyk9Pnt0LnBhcmFtcy5wYXJhbGxheC5lbmFibGVkJiZmdW5jdGlvbihlKXt2b2lkIDA9PT1lJiYoZT10LnBhcmFtcy5zcGVlZCk7Y29uc3R7JGVsOnN9PXQ7cy5maW5kKFwiW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXVwiKS5lYWNoKCh0PT57Y29uc3Qgcz1kKHQpO2xldCBhPXBhcnNlSW50KHMuYXR0cihcImRhdGEtc3dpcGVyLXBhcmFsbGF4LWR1cmF0aW9uXCIpLDEwKXx8ZTswPT09ZSYmKGE9MCkscy50cmFuc2l0aW9uKGEpfSkpfShzKX0pKX0sZnVuY3Rpb24oZSl7bGV0e3N3aXBlcjp0LGV4dGVuZFBhcmFtczpzLG9uOmEsZW1pdDppfT1lO2NvbnN0IG49cigpO3Moe3pvb206e2VuYWJsZWQ6ITEsbWF4UmF0aW86MyxtaW5SYXRpbzoxLHRvZ2dsZTohMCxjb250YWluZXJDbGFzczpcInN3aXBlci16b29tLWNvbnRhaW5lclwiLHpvb21lZFNsaWRlQ2xhc3M6XCJzd2lwZXItc2xpZGUtem9vbWVkXCJ9fSksdC56b29tPXtlbmFibGVkOiExfTtsZXQgbCxvLGMscD0xLHU9ITE7Y29uc3QgbT17JHNsaWRlRWw6dm9pZCAwLHNsaWRlV2lkdGg6dm9pZCAwLHNsaWRlSGVpZ2h0OnZvaWQgMCwkaW1hZ2VFbDp2b2lkIDAsJGltYWdlV3JhcEVsOnZvaWQgMCxtYXhSYXRpbzozfSxmPXtpc1RvdWNoZWQ6dm9pZCAwLGlzTW92ZWQ6dm9pZCAwLGN1cnJlbnRYOnZvaWQgMCxjdXJyZW50WTp2b2lkIDAsbWluWDp2b2lkIDAsbWluWTp2b2lkIDAsbWF4WDp2b2lkIDAsbWF4WTp2b2lkIDAsd2lkdGg6dm9pZCAwLGhlaWdodDp2b2lkIDAsc3RhcnRYOnZvaWQgMCxzdGFydFk6dm9pZCAwLHRvdWNoZXNTdGFydDp7fSx0b3VjaGVzQ3VycmVudDp7fX0sZz17eDp2b2lkIDAseTp2b2lkIDAscHJldlBvc2l0aW9uWDp2b2lkIDAscHJldlBvc2l0aW9uWTp2b2lkIDAscHJldlRpbWU6dm9pZCAwfTtsZXQgdj0xO2Z1bmN0aW9uIHcoZSl7aWYoZS50YXJnZXRUb3VjaGVzLmxlbmd0aDwyKXJldHVybiAxO2NvbnN0IHQ9ZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYLHM9ZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZLGE9ZS50YXJnZXRUb3VjaGVzWzFdLnBhZ2VYLGk9ZS50YXJnZXRUb3VjaGVzWzFdLnBhZ2VZO3JldHVybiBNYXRoLnNxcnQoKGEtdCkqKjIrKGktcykqKjIpfWZ1bmN0aW9uIGIoZSl7Y29uc3Qgcz10LnN1cHBvcnQsYT10LnBhcmFtcy56b29tO2lmKG89ITEsYz0hMSwhcy5nZXN0dXJlcyl7aWYoXCJ0b3VjaHN0YXJ0XCIhPT1lLnR5cGV8fFwidG91Y2hzdGFydFwiPT09ZS50eXBlJiZlLnRhcmdldFRvdWNoZXMubGVuZ3RoPDIpcmV0dXJuO289ITAsbS5zY2FsZVN0YXJ0PXcoZSl9bS4kc2xpZGVFbCYmbS4kc2xpZGVFbC5sZW5ndGh8fChtLiRzbGlkZUVsPWQoZS50YXJnZXQpLmNsb3Nlc3QoYC4ke3QucGFyYW1zLnNsaWRlQ2xhc3N9YCksMD09PW0uJHNsaWRlRWwubGVuZ3RoJiYobS4kc2xpZGVFbD10LnNsaWRlcy5lcSh0LmFjdGl2ZUluZGV4KSksbS4kaW1hZ2VFbD1tLiRzbGlkZUVsLmZpbmQoYC4ke2EuY29udGFpbmVyQ2xhc3N9YCkuZXEoMCkuZmluZChcInBpY3R1cmUsIGltZywgc3ZnLCBjYW52YXMsIC5zd2lwZXItem9vbS10YXJnZXRcIikuZXEoMCksbS4kaW1hZ2VXcmFwRWw9bS4kaW1hZ2VFbC5wYXJlbnQoYC4ke2EuY29udGFpbmVyQ2xhc3N9YCksbS5tYXhSYXRpbz1tLiRpbWFnZVdyYXBFbC5hdHRyKFwiZGF0YS1zd2lwZXItem9vbVwiKXx8YS5tYXhSYXRpbywwIT09bS4kaW1hZ2VXcmFwRWwubGVuZ3RoKT8obS4kaW1hZ2VFbCYmbS4kaW1hZ2VFbC50cmFuc2l0aW9uKDApLHU9ITApOm0uJGltYWdlRWw9dm9pZCAwfWZ1bmN0aW9uIHgoZSl7Y29uc3Qgcz10LnN1cHBvcnQsYT10LnBhcmFtcy56b29tLGk9dC56b29tO2lmKCFzLmdlc3R1cmVzKXtpZihcInRvdWNobW92ZVwiIT09ZS50eXBlfHxcInRvdWNobW92ZVwiPT09ZS50eXBlJiZlLnRhcmdldFRvdWNoZXMubGVuZ3RoPDIpcmV0dXJuO2M9ITAsbS5zY2FsZU1vdmU9dyhlKX1tLiRpbWFnZUVsJiYwIT09bS4kaW1hZ2VFbC5sZW5ndGg/KHMuZ2VzdHVyZXM/aS5zY2FsZT1lLnNjYWxlKnA6aS5zY2FsZT1tLnNjYWxlTW92ZS9tLnNjYWxlU3RhcnQqcCxpLnNjYWxlPm0ubWF4UmF0aW8mJihpLnNjYWxlPW0ubWF4UmF0aW8tMSsoaS5zY2FsZS1tLm1heFJhdGlvKzEpKiouNSksaS5zY2FsZTxhLm1pblJhdGlvJiYoaS5zY2FsZT1hLm1pblJhdGlvKzEtKGEubWluUmF0aW8taS5zY2FsZSsxKSoqLjUpLG0uJGltYWdlRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoJHtpLnNjYWxlfSlgKSk6XCJnZXN0dXJlY2hhbmdlXCI9PT1lLnR5cGUmJmIoZSl9ZnVuY3Rpb24geShlKXtjb25zdCBzPXQuZGV2aWNlLGE9dC5zdXBwb3J0LGk9dC5wYXJhbXMuem9vbSxyPXQuem9vbTtpZighYS5nZXN0dXJlcyl7aWYoIW98fCFjKXJldHVybjtpZihcInRvdWNoZW5kXCIhPT1lLnR5cGV8fFwidG91Y2hlbmRcIj09PWUudHlwZSYmZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg8MiYmIXMuYW5kcm9pZClyZXR1cm47bz0hMSxjPSExfW0uJGltYWdlRWwmJjAhPT1tLiRpbWFnZUVsLmxlbmd0aCYmKHIuc2NhbGU9TWF0aC5tYXgoTWF0aC5taW4oci5zY2FsZSxtLm1heFJhdGlvKSxpLm1pblJhdGlvKSxtLiRpbWFnZUVsLnRyYW5zaXRpb24odC5wYXJhbXMuc3BlZWQpLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKCR7ci5zY2FsZX0pYCkscD1yLnNjYWxlLHU9ITEsMT09PXIuc2NhbGUmJihtLiRzbGlkZUVsPXZvaWQgMCkpfWZ1bmN0aW9uIEUoZSl7Y29uc3Qgcz10Lnpvb207aWYoIW0uJGltYWdlRWx8fDA9PT1tLiRpbWFnZUVsLmxlbmd0aClyZXR1cm47aWYodC5hbGxvd0NsaWNrPSExLCFmLmlzVG91Y2hlZHx8IW0uJHNsaWRlRWwpcmV0dXJuO2YuaXNNb3ZlZHx8KGYud2lkdGg9bS4kaW1hZ2VFbFswXS5vZmZzZXRXaWR0aCxmLmhlaWdodD1tLiRpbWFnZUVsWzBdLm9mZnNldEhlaWdodCxmLnN0YXJ0WD1oKG0uJGltYWdlV3JhcEVsWzBdLFwieFwiKXx8MCxmLnN0YXJ0WT1oKG0uJGltYWdlV3JhcEVsWzBdLFwieVwiKXx8MCxtLnNsaWRlV2lkdGg9bS4kc2xpZGVFbFswXS5vZmZzZXRXaWR0aCxtLnNsaWRlSGVpZ2h0PW0uJHNsaWRlRWxbMF0ub2Zmc2V0SGVpZ2h0LG0uJGltYWdlV3JhcEVsLnRyYW5zaXRpb24oMCkpO2NvbnN0IGE9Zi53aWR0aCpzLnNjYWxlLGk9Zi5oZWlnaHQqcy5zY2FsZTtpZighKGE8bS5zbGlkZVdpZHRoJiZpPG0uc2xpZGVIZWlnaHQpKXtpZihmLm1pblg9TWF0aC5taW4obS5zbGlkZVdpZHRoLzItYS8yLDApLGYubWF4WD0tZi5taW5YLGYubWluWT1NYXRoLm1pbihtLnNsaWRlSGVpZ2h0LzItaS8yLDApLGYubWF4WT0tZi5taW5ZLGYudG91Y2hlc0N1cnJlbnQueD1cInRvdWNobW92ZVwiPT09ZS50eXBlP2UudGFyZ2V0VG91Y2hlc1swXS5wYWdlWDplLnBhZ2VYLGYudG91Y2hlc0N1cnJlbnQueT1cInRvdWNobW92ZVwiPT09ZS50eXBlP2UudGFyZ2V0VG91Y2hlc1swXS5wYWdlWTplLnBhZ2VZLCFmLmlzTW92ZWQmJiF1KXtpZih0LmlzSG9yaXpvbnRhbCgpJiYoTWF0aC5mbG9vcihmLm1pblgpPT09TWF0aC5mbG9vcihmLnN0YXJ0WCkmJmYudG91Y2hlc0N1cnJlbnQueDxmLnRvdWNoZXNTdGFydC54fHxNYXRoLmZsb29yKGYubWF4WCk9PT1NYXRoLmZsb29yKGYuc3RhcnRYKSYmZi50b3VjaGVzQ3VycmVudC54PmYudG91Y2hlc1N0YXJ0LngpKXJldHVybiB2b2lkKGYuaXNUb3VjaGVkPSExKTtpZighdC5pc0hvcml6b250YWwoKSYmKE1hdGguZmxvb3IoZi5taW5ZKT09PU1hdGguZmxvb3IoZi5zdGFydFkpJiZmLnRvdWNoZXNDdXJyZW50Lnk8Zi50b3VjaGVzU3RhcnQueXx8TWF0aC5mbG9vcihmLm1heFkpPT09TWF0aC5mbG9vcihmLnN0YXJ0WSkmJmYudG91Y2hlc0N1cnJlbnQueT5mLnRvdWNoZXNTdGFydC55KSlyZXR1cm4gdm9pZChmLmlzVG91Y2hlZD0hMSl9ZS5jYW5jZWxhYmxlJiZlLnByZXZlbnREZWZhdWx0KCksZS5zdG9wUHJvcGFnYXRpb24oKSxmLmlzTW92ZWQ9ITAsZi5jdXJyZW50WD1mLnRvdWNoZXNDdXJyZW50LngtZi50b3VjaGVzU3RhcnQueCtmLnN0YXJ0WCxmLmN1cnJlbnRZPWYudG91Y2hlc0N1cnJlbnQueS1mLnRvdWNoZXNTdGFydC55K2Yuc3RhcnRZLGYuY3VycmVudFg8Zi5taW5YJiYoZi5jdXJyZW50WD1mLm1pblgrMS0oZi5taW5YLWYuY3VycmVudFgrMSkqKi44KSxmLmN1cnJlbnRYPmYubWF4WCYmKGYuY3VycmVudFg9Zi5tYXhYLTErKGYuY3VycmVudFgtZi5tYXhYKzEpKiouOCksZi5jdXJyZW50WTxmLm1pblkmJihmLmN1cnJlbnRZPWYubWluWSsxLShmLm1pblktZi5jdXJyZW50WSsxKSoqLjgpLGYuY3VycmVudFk+Zi5tYXhZJiYoZi5jdXJyZW50WT1mLm1heFktMSsoZi5jdXJyZW50WS1mLm1heFkrMSkqKi44KSxnLnByZXZQb3NpdGlvblh8fChnLnByZXZQb3NpdGlvblg9Zi50b3VjaGVzQ3VycmVudC54KSxnLnByZXZQb3NpdGlvbll8fChnLnByZXZQb3NpdGlvblk9Zi50b3VjaGVzQ3VycmVudC55KSxnLnByZXZUaW1lfHwoZy5wcmV2VGltZT1EYXRlLm5vdygpKSxnLng9KGYudG91Y2hlc0N1cnJlbnQueC1nLnByZXZQb3NpdGlvblgpLyhEYXRlLm5vdygpLWcucHJldlRpbWUpLzIsZy55PShmLnRvdWNoZXNDdXJyZW50LnktZy5wcmV2UG9zaXRpb25ZKS8oRGF0ZS5ub3coKS1nLnByZXZUaW1lKS8yLE1hdGguYWJzKGYudG91Y2hlc0N1cnJlbnQueC1nLnByZXZQb3NpdGlvblgpPDImJihnLng9MCksTWF0aC5hYnMoZi50b3VjaGVzQ3VycmVudC55LWcucHJldlBvc2l0aW9uWSk8MiYmKGcueT0wKSxnLnByZXZQb3NpdGlvblg9Zi50b3VjaGVzQ3VycmVudC54LGcucHJldlBvc2l0aW9uWT1mLnRvdWNoZXNDdXJyZW50LnksZy5wcmV2VGltZT1EYXRlLm5vdygpLG0uJGltYWdlV3JhcEVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtmLmN1cnJlbnRYfXB4LCAke2YuY3VycmVudFl9cHgsMClgKX19ZnVuY3Rpb24gQygpe2NvbnN0IGU9dC56b29tO20uJHNsaWRlRWwmJnQucHJldmlvdXNJbmRleCE9PXQuYWN0aXZlSW5kZXgmJihtLiRpbWFnZUVsJiZtLiRpbWFnZUVsLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgxKVwiKSxtLiRpbWFnZVdyYXBFbCYmbS4kaW1hZ2VXcmFwRWwudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApXCIpLGUuc2NhbGU9MSxwPTEsbS4kc2xpZGVFbD12b2lkIDAsbS4kaW1hZ2VFbD12b2lkIDAsbS4kaW1hZ2VXcmFwRWw9dm9pZCAwKX1mdW5jdGlvbiBUKGUpe2NvbnN0IHM9dC56b29tLGE9dC5wYXJhbXMuem9vbTtpZihtLiRzbGlkZUVsfHwoZSYmZS50YXJnZXQmJihtLiRzbGlkZUVsPWQoZS50YXJnZXQpLmNsb3Nlc3QoYC4ke3QucGFyYW1zLnNsaWRlQ2xhc3N9YCkpLG0uJHNsaWRlRWx8fCh0LnBhcmFtcy52aXJ0dWFsJiZ0LnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQmJnQudmlydHVhbD9tLiRzbGlkZUVsPXQuJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7dC5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzc31gKTptLiRzbGlkZUVsPXQuc2xpZGVzLmVxKHQuYWN0aXZlSW5kZXgpKSxtLiRpbWFnZUVsPW0uJHNsaWRlRWwuZmluZChgLiR7YS5jb250YWluZXJDbGFzc31gKS5lcSgwKS5maW5kKFwicGljdHVyZSwgaW1nLCBzdmcsIGNhbnZhcywgLnN3aXBlci16b29tLXRhcmdldFwiKS5lcSgwKSxtLiRpbWFnZVdyYXBFbD1tLiRpbWFnZUVsLnBhcmVudChgLiR7YS5jb250YWluZXJDbGFzc31gKSksIW0uJGltYWdlRWx8fDA9PT1tLiRpbWFnZUVsLmxlbmd0aHx8IW0uJGltYWdlV3JhcEVsfHwwPT09bS4kaW1hZ2VXcmFwRWwubGVuZ3RoKXJldHVybjtsZXQgaSxyLGwsbyxjLHUsaCxnLHYsdyxiLHgseSxFLEMsVCwkLFM7dC5wYXJhbXMuY3NzTW9kZSYmKHQud3JhcHBlckVsLnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCIsdC53cmFwcGVyRWwuc3R5bGUudG91Y2hBY3Rpb249XCJub25lXCIpLG0uJHNsaWRlRWwuYWRkQ2xhc3MoYCR7YS56b29tZWRTbGlkZUNsYXNzfWApLHZvaWQgMD09PWYudG91Y2hlc1N0YXJ0LngmJmU/KGk9XCJ0b3VjaGVuZFwiPT09ZS50eXBlP2UuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg6ZS5wYWdlWCxyPVwidG91Y2hlbmRcIj09PWUudHlwZT9lLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZOmUucGFnZVkpOihpPWYudG91Y2hlc1N0YXJ0Lngscj1mLnRvdWNoZXNTdGFydC55KSxzLnNjYWxlPW0uJGltYWdlV3JhcEVsLmF0dHIoXCJkYXRhLXN3aXBlci16b29tXCIpfHxhLm1heFJhdGlvLHA9bS4kaW1hZ2VXcmFwRWwuYXR0cihcImRhdGEtc3dpcGVyLXpvb21cIil8fGEubWF4UmF0aW8sZT8oJD1tLiRzbGlkZUVsWzBdLm9mZnNldFdpZHRoLFM9bS4kc2xpZGVFbFswXS5vZmZzZXRIZWlnaHQsbD1tLiRzbGlkZUVsLm9mZnNldCgpLmxlZnQrbi5zY3JvbGxYLG89bS4kc2xpZGVFbC5vZmZzZXQoKS50b3Arbi5zY3JvbGxZLGM9bCskLzItaSx1PW8rUy8yLXIsdj1tLiRpbWFnZUVsWzBdLm9mZnNldFdpZHRoLHc9bS4kaW1hZ2VFbFswXS5vZmZzZXRIZWlnaHQsYj12KnMuc2NhbGUseD13KnMuc2NhbGUseT1NYXRoLm1pbigkLzItYi8yLDApLEU9TWF0aC5taW4oUy8yLXgvMiwwKSxDPS15LFQ9LUUsaD1jKnMuc2NhbGUsZz11KnMuc2NhbGUsaDx5JiYoaD15KSxoPkMmJihoPUMpLGc8RSYmKGc9RSksZz5UJiYoZz1UKSk6KGg9MCxnPTApLG0uJGltYWdlV3JhcEVsLnRyYW5zaXRpb24oMzAwKS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7aH1weCwgJHtnfXB4LDApYCksbS4kaW1hZ2VFbC50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoJHtzLnNjYWxlfSlgKX1mdW5jdGlvbiAkKCl7Y29uc3QgZT10Lnpvb20scz10LnBhcmFtcy56b29tO20uJHNsaWRlRWx8fCh0LnBhcmFtcy52aXJ0dWFsJiZ0LnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQmJnQudmlydHVhbD9tLiRzbGlkZUVsPXQuJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7dC5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzc31gKTptLiRzbGlkZUVsPXQuc2xpZGVzLmVxKHQuYWN0aXZlSW5kZXgpLG0uJGltYWdlRWw9bS4kc2xpZGVFbC5maW5kKGAuJHtzLmNvbnRhaW5lckNsYXNzfWApLmVxKDApLmZpbmQoXCJwaWN0dXJlLCBpbWcsIHN2ZywgY2FudmFzLCAuc3dpcGVyLXpvb20tdGFyZ2V0XCIpLmVxKDApLG0uJGltYWdlV3JhcEVsPW0uJGltYWdlRWwucGFyZW50KGAuJHtzLmNvbnRhaW5lckNsYXNzfWApKSxtLiRpbWFnZUVsJiYwIT09bS4kaW1hZ2VFbC5sZW5ndGgmJm0uJGltYWdlV3JhcEVsJiYwIT09bS4kaW1hZ2VXcmFwRWwubGVuZ3RoJiYodC5wYXJhbXMuY3NzTW9kZSYmKHQud3JhcHBlckVsLnN0eWxlLm92ZXJmbG93PVwiXCIsdC53cmFwcGVyRWwuc3R5bGUudG91Y2hBY3Rpb249XCJcIiksZS5zY2FsZT0xLHA9MSxtLiRpbWFnZVdyYXBFbC50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApXCIpLG0uJGltYWdlRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgxKVwiKSxtLiRzbGlkZUVsLnJlbW92ZUNsYXNzKGAke3Muem9vbWVkU2xpZGVDbGFzc31gKSxtLiRzbGlkZUVsPXZvaWQgMCl9ZnVuY3Rpb24gUyhlKXtjb25zdCBzPXQuem9vbTtzLnNjYWxlJiYxIT09cy5zY2FsZT8kKCk6VChlKX1mdW5jdGlvbiBNKCl7Y29uc3QgZT10LnN1cHBvcnQ7cmV0dXJue3Bhc3NpdmVMaXN0ZW5lcjohKFwidG91Y2hzdGFydFwiIT09dC50b3VjaEV2ZW50cy5zdGFydHx8IWUucGFzc2l2ZUxpc3RlbmVyfHwhdC5wYXJhbXMucGFzc2l2ZUxpc3RlbmVycykmJntwYXNzaXZlOiEwLGNhcHR1cmU6ITF9LGFjdGl2ZUxpc3RlbmVyV2l0aENhcHR1cmU6IWUucGFzc2l2ZUxpc3RlbmVyfHx7cGFzc2l2ZTohMSxjYXB0dXJlOiEwfX19ZnVuY3Rpb24gUCgpe3JldHVybmAuJHt0LnBhcmFtcy5zbGlkZUNsYXNzfWB9ZnVuY3Rpb24gayhlKXtjb25zdHtwYXNzaXZlTGlzdGVuZXI6c309TSgpLGE9UCgpO3QuJHdyYXBwZXJFbFtlXShcImdlc3R1cmVzdGFydFwiLGEsYixzKSx0LiR3cmFwcGVyRWxbZV0oXCJnZXN0dXJlY2hhbmdlXCIsYSx4LHMpLHQuJHdyYXBwZXJFbFtlXShcImdlc3R1cmVlbmRcIixhLHkscyl9ZnVuY3Rpb24geigpe2x8fChsPSEwLGsoXCJvblwiKSl9ZnVuY3Rpb24gTCgpe2wmJihsPSExLGsoXCJvZmZcIikpfWZ1bmN0aW9uIE8oKXtjb25zdCBlPXQuem9vbTtpZihlLmVuYWJsZWQpcmV0dXJuO2UuZW5hYmxlZD0hMDtjb25zdCBzPXQuc3VwcG9ydCx7cGFzc2l2ZUxpc3RlbmVyOmEsYWN0aXZlTGlzdGVuZXJXaXRoQ2FwdHVyZTppfT1NKCkscj1QKCk7cy5nZXN0dXJlcz8odC4kd3JhcHBlckVsLm9uKHQudG91Y2hFdmVudHMuc3RhcnQseixhKSx0LiR3cmFwcGVyRWwub24odC50b3VjaEV2ZW50cy5lbmQsTCxhKSk6XCJ0b3VjaHN0YXJ0XCI9PT10LnRvdWNoRXZlbnRzLnN0YXJ0JiYodC4kd3JhcHBlckVsLm9uKHQudG91Y2hFdmVudHMuc3RhcnQscixiLGEpLHQuJHdyYXBwZXJFbC5vbih0LnRvdWNoRXZlbnRzLm1vdmUscix4LGkpLHQuJHdyYXBwZXJFbC5vbih0LnRvdWNoRXZlbnRzLmVuZCxyLHksYSksdC50b3VjaEV2ZW50cy5jYW5jZWwmJnQuJHdyYXBwZXJFbC5vbih0LnRvdWNoRXZlbnRzLmNhbmNlbCxyLHksYSkpLHQuJHdyYXBwZXJFbC5vbih0LnRvdWNoRXZlbnRzLm1vdmUsYC4ke3QucGFyYW1zLnpvb20uY29udGFpbmVyQ2xhc3N9YCxFLGkpfWZ1bmN0aW9uIEkoKXtjb25zdCBlPXQuem9vbTtpZighZS5lbmFibGVkKXJldHVybjtjb25zdCBzPXQuc3VwcG9ydDtlLmVuYWJsZWQ9ITE7Y29uc3R7cGFzc2l2ZUxpc3RlbmVyOmEsYWN0aXZlTGlzdGVuZXJXaXRoQ2FwdHVyZTppfT1NKCkscj1QKCk7cy5nZXN0dXJlcz8odC4kd3JhcHBlckVsLm9mZih0LnRvdWNoRXZlbnRzLnN0YXJ0LHosYSksdC4kd3JhcHBlckVsLm9mZih0LnRvdWNoRXZlbnRzLmVuZCxMLGEpKTpcInRvdWNoc3RhcnRcIj09PXQudG91Y2hFdmVudHMuc3RhcnQmJih0LiR3cmFwcGVyRWwub2ZmKHQudG91Y2hFdmVudHMuc3RhcnQscixiLGEpLHQuJHdyYXBwZXJFbC5vZmYodC50b3VjaEV2ZW50cy5tb3ZlLHIseCxpKSx0LiR3cmFwcGVyRWwub2ZmKHQudG91Y2hFdmVudHMuZW5kLHIseSxhKSx0LnRvdWNoRXZlbnRzLmNhbmNlbCYmdC4kd3JhcHBlckVsLm9mZih0LnRvdWNoRXZlbnRzLmNhbmNlbCxyLHksYSkpLHQuJHdyYXBwZXJFbC5vZmYodC50b3VjaEV2ZW50cy5tb3ZlLGAuJHt0LnBhcmFtcy56b29tLmNvbnRhaW5lckNsYXNzfWAsRSxpKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodC56b29tLFwic2NhbGVcIix7Z2V0OigpPT52LHNldChlKXtpZih2IT09ZSl7Y29uc3QgdD1tLiRpbWFnZUVsP20uJGltYWdlRWxbMF06dm9pZCAwLHM9bS4kc2xpZGVFbD9tLiRzbGlkZUVsWzBdOnZvaWQgMDtpKFwiem9vbUNoYW5nZVwiLGUsdCxzKX12PWV9fSksYShcImluaXRcIiwoKCk9Pnt0LnBhcmFtcy56b29tLmVuYWJsZWQmJk8oKX0pKSxhKFwiZGVzdHJveVwiLCgoKT0+e0koKX0pKSxhKFwidG91Y2hTdGFydFwiLCgoZSxzKT0+e3Quem9vbS5lbmFibGVkJiZmdW5jdGlvbihlKXtjb25zdCBzPXQuZGV2aWNlO20uJGltYWdlRWwmJjAhPT1tLiRpbWFnZUVsLmxlbmd0aCYmKGYuaXNUb3VjaGVkfHwocy5hbmRyb2lkJiZlLmNhbmNlbGFibGUmJmUucHJldmVudERlZmF1bHQoKSxmLmlzVG91Y2hlZD0hMCxmLnRvdWNoZXNTdGFydC54PVwidG91Y2hzdGFydFwiPT09ZS50eXBlP2UudGFyZ2V0VG91Y2hlc1swXS5wYWdlWDplLnBhZ2VYLGYudG91Y2hlc1N0YXJ0Lnk9XCJ0b3VjaHN0YXJ0XCI9PT1lLnR5cGU/ZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZOmUucGFnZVkpKX0ocyl9KSksYShcInRvdWNoRW5kXCIsKChlLHMpPT57dC56b29tLmVuYWJsZWQmJmZ1bmN0aW9uKCl7Y29uc3QgZT10Lnpvb207aWYoIW0uJGltYWdlRWx8fDA9PT1tLiRpbWFnZUVsLmxlbmd0aClyZXR1cm47aWYoIWYuaXNUb3VjaGVkfHwhZi5pc01vdmVkKXJldHVybiBmLmlzVG91Y2hlZD0hMSx2b2lkKGYuaXNNb3ZlZD0hMSk7Zi5pc1RvdWNoZWQ9ITEsZi5pc01vdmVkPSExO2xldCBzPTMwMCxhPTMwMDtjb25zdCBpPWcueCpzLHI9Zi5jdXJyZW50WCtpLG49Zy55KmEsbD1mLmN1cnJlbnRZK247MCE9PWcueCYmKHM9TWF0aC5hYnMoKHItZi5jdXJyZW50WCkvZy54KSksMCE9PWcueSYmKGE9TWF0aC5hYnMoKGwtZi5jdXJyZW50WSkvZy55KSk7Y29uc3Qgbz1NYXRoLm1heChzLGEpO2YuY3VycmVudFg9cixmLmN1cnJlbnRZPWw7Y29uc3QgZD1mLndpZHRoKmUuc2NhbGUsYz1mLmhlaWdodCplLnNjYWxlO2YubWluWD1NYXRoLm1pbihtLnNsaWRlV2lkdGgvMi1kLzIsMCksZi5tYXhYPS1mLm1pblgsZi5taW5ZPU1hdGgubWluKG0uc2xpZGVIZWlnaHQvMi1jLzIsMCksZi5tYXhZPS1mLm1pblksZi5jdXJyZW50WD1NYXRoLm1heChNYXRoLm1pbihmLmN1cnJlbnRYLGYubWF4WCksZi5taW5YKSxmLmN1cnJlbnRZPU1hdGgubWF4KE1hdGgubWluKGYuY3VycmVudFksZi5tYXhZKSxmLm1pblkpLG0uJGltYWdlV3JhcEVsLnRyYW5zaXRpb24obykudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2YuY3VycmVudFh9cHgsICR7Zi5jdXJyZW50WX1weCwwKWApfSgpfSkpLGEoXCJkb3VibGVUYXBcIiwoKGUscyk9PnshdC5hbmltYXRpbmcmJnQucGFyYW1zLnpvb20uZW5hYmxlZCYmdC56b29tLmVuYWJsZWQmJnQucGFyYW1zLnpvb20udG9nZ2xlJiZTKHMpfSkpLGEoXCJ0cmFuc2l0aW9uRW5kXCIsKCgpPT57dC56b29tLmVuYWJsZWQmJnQucGFyYW1zLnpvb20uZW5hYmxlZCYmQygpfSkpLGEoXCJzbGlkZUNoYW5nZVwiLCgoKT0+e3Quem9vbS5lbmFibGVkJiZ0LnBhcmFtcy56b29tLmVuYWJsZWQmJnQucGFyYW1zLmNzc01vZGUmJkMoKX0pKSxPYmplY3QuYXNzaWduKHQuem9vbSx7ZW5hYmxlOk8sZGlzYWJsZTpJLGluOlQsb3V0OiQsdG9nZ2xlOlN9KX0sZnVuY3Rpb24oZSl7bGV0e3N3aXBlcjp0LGV4dGVuZFBhcmFtczpzLG9uOmEsZW1pdDppfT1lO3Moe2xhenk6e2NoZWNrSW5WaWV3OiExLGVuYWJsZWQ6ITEsbG9hZFByZXZOZXh0OiExLGxvYWRQcmV2TmV4dEFtb3VudDoxLGxvYWRPblRyYW5zaXRpb25TdGFydDohMSxzY3JvbGxpbmdFbGVtZW50OlwiXCIsZWxlbWVudENsYXNzOlwic3dpcGVyLWxhenlcIixsb2FkaW5nQ2xhc3M6XCJzd2lwZXItbGF6eS1sb2FkaW5nXCIsbG9hZGVkQ2xhc3M6XCJzd2lwZXItbGF6eS1sb2FkZWRcIixwcmVsb2FkZXJDbGFzczpcInN3aXBlci1sYXp5LXByZWxvYWRlclwifX0pLHQubGF6eT17fTtsZXQgbj0hMSxsPSExO2Z1bmN0aW9uIG8oZSxzKXt2b2lkIDA9PT1zJiYocz0hMCk7Y29uc3QgYT10LnBhcmFtcy5sYXp5O2lmKHZvaWQgMD09PWUpcmV0dXJuO2lmKDA9PT10LnNsaWRlcy5sZW5ndGgpcmV0dXJuO2NvbnN0IHI9dC52aXJ0dWFsJiZ0LnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ/dC4kd3JhcHBlckVsLmNoaWxkcmVuKGAuJHt0LnBhcmFtcy5zbGlkZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7ZX1cIl1gKTp0LnNsaWRlcy5lcShlKSxuPXIuZmluZChgLiR7YS5lbGVtZW50Q2xhc3N9Om5vdCguJHthLmxvYWRlZENsYXNzfSk6bm90KC4ke2EubG9hZGluZ0NsYXNzfSlgKTshci5oYXNDbGFzcyhhLmVsZW1lbnRDbGFzcyl8fHIuaGFzQ2xhc3MoYS5sb2FkZWRDbGFzcyl8fHIuaGFzQ2xhc3MoYS5sb2FkaW5nQ2xhc3MpfHxuLnB1c2goclswXSksMCE9PW4ubGVuZ3RoJiZuLmVhY2goKGU9Pntjb25zdCBuPWQoZSk7bi5hZGRDbGFzcyhhLmxvYWRpbmdDbGFzcyk7Y29uc3QgbD1uLmF0dHIoXCJkYXRhLWJhY2tncm91bmRcIiksYz1uLmF0dHIoXCJkYXRhLXNyY1wiKSxwPW4uYXR0cihcImRhdGEtc3Jjc2V0XCIpLHU9bi5hdHRyKFwiZGF0YS1zaXplc1wiKSxoPW4ucGFyZW50KFwicGljdHVyZVwiKTt0LmxvYWRJbWFnZShuWzBdLGN8fGwscCx1LCExLCgoKT0+e2lmKG51bGwhPXQmJnQmJighdHx8dC5wYXJhbXMpJiYhdC5kZXN0cm95ZWQpe2lmKGw/KG4uY3NzKFwiYmFja2dyb3VuZC1pbWFnZVwiLGB1cmwoXCIke2x9XCIpYCksbi5yZW1vdmVBdHRyKFwiZGF0YS1iYWNrZ3JvdW5kXCIpKToocCYmKG4uYXR0cihcInNyY3NldFwiLHApLG4ucmVtb3ZlQXR0cihcImRhdGEtc3Jjc2V0XCIpKSx1JiYobi5hdHRyKFwic2l6ZXNcIix1KSxuLnJlbW92ZUF0dHIoXCJkYXRhLXNpemVzXCIpKSxoLmxlbmd0aCYmaC5jaGlsZHJlbihcInNvdXJjZVwiKS5lYWNoKChlPT57Y29uc3QgdD1kKGUpO3QuYXR0cihcImRhdGEtc3Jjc2V0XCIpJiYodC5hdHRyKFwic3Jjc2V0XCIsdC5hdHRyKFwiZGF0YS1zcmNzZXRcIikpLHQucmVtb3ZlQXR0cihcImRhdGEtc3Jjc2V0XCIpKX0pKSxjJiYobi5hdHRyKFwic3JjXCIsYyksbi5yZW1vdmVBdHRyKFwiZGF0YS1zcmNcIikpKSxuLmFkZENsYXNzKGEubG9hZGVkQ2xhc3MpLnJlbW92ZUNsYXNzKGEubG9hZGluZ0NsYXNzKSxyLmZpbmQoYC4ke2EucHJlbG9hZGVyQ2xhc3N9YCkucmVtb3ZlKCksdC5wYXJhbXMubG9vcCYmcyl7Y29uc3QgZT1yLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKTtpZihyLmhhc0NsYXNzKHQucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKXtvKHQuJHdyYXBwZXJFbC5jaGlsZHJlbihgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtlfVwiXTpub3QoLiR7dC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30pYCkuaW5kZXgoKSwhMSl9ZWxzZXtvKHQuJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7dC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2V9XCJdYCkuaW5kZXgoKSwhMSl9fWkoXCJsYXp5SW1hZ2VSZWFkeVwiLHJbMF0sblswXSksdC5wYXJhbXMuYXV0b0hlaWdodCYmdC51cGRhdGVBdXRvSGVpZ2h0KCl9fSkpLGkoXCJsYXp5SW1hZ2VMb2FkXCIsclswXSxuWzBdKX0pKX1mdW5jdGlvbiBjKCl7Y29uc3R7JHdyYXBwZXJFbDplLHBhcmFtczpzLHNsaWRlczphLGFjdGl2ZUluZGV4Oml9PXQscj10LnZpcnR1YWwmJnMudmlydHVhbC5lbmFibGVkLG49cy5sYXp5O2xldCBjPXMuc2xpZGVzUGVyVmlldztmdW5jdGlvbiBwKHQpe2lmKHIpe2lmKGUuY2hpbGRyZW4oYC4ke3Muc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3R9XCJdYCkubGVuZ3RoKXJldHVybiEwfWVsc2UgaWYoYVt0XSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiB1KGUpe3JldHVybiByP2QoZSkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpOmQoZSkuaW5kZXgoKX1pZihcImF1dG9cIj09PWMmJihjPTApLGx8fChsPSEwKSx0LnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzKWUuY2hpbGRyZW4oYC4ke3Muc2xpZGVWaXNpYmxlQ2xhc3N9YCkuZWFjaCgoZT0+e28ocj9kKGUpLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKTpkKGUpLmluZGV4KCkpfSkpO2Vsc2UgaWYoYz4xKWZvcihsZXQgZT1pO2U8aStjO2UrPTEpcChlKSYmbyhlKTtlbHNlIG8oaSk7aWYobi5sb2FkUHJldk5leHQpaWYoYz4xfHxuLmxvYWRQcmV2TmV4dEFtb3VudCYmbi5sb2FkUHJldk5leHRBbW91bnQ+MSl7Y29uc3QgZT1uLmxvYWRQcmV2TmV4dEFtb3VudCx0PU1hdGguY2VpbChjKSxzPU1hdGgubWluKGkrdCtNYXRoLm1heChlLHQpLGEubGVuZ3RoKSxyPU1hdGgubWF4KGktTWF0aC5tYXgodCxlKSwwKTtmb3IobGV0IGU9aSt0O2U8cztlKz0xKXAoZSkmJm8oZSk7Zm9yKGxldCBlPXI7ZTxpO2UrPTEpcChlKSYmbyhlKX1lbHNle2NvbnN0IHQ9ZS5jaGlsZHJlbihgLiR7cy5zbGlkZU5leHRDbGFzc31gKTt0Lmxlbmd0aD4wJiZvKHUodCkpO2NvbnN0IGE9ZS5jaGlsZHJlbihgLiR7cy5zbGlkZVByZXZDbGFzc31gKTthLmxlbmd0aD4wJiZvKHUoYSkpfX1mdW5jdGlvbiBwKCl7Y29uc3QgZT1yKCk7aWYoIXR8fHQuZGVzdHJveWVkKXJldHVybjtjb25zdCBzPXQucGFyYW1zLmxhenkuc2Nyb2xsaW5nRWxlbWVudD9kKHQucGFyYW1zLmxhenkuc2Nyb2xsaW5nRWxlbWVudCk6ZChlKSxhPXNbMF09PT1lLGk9YT9lLmlubmVyV2lkdGg6c1swXS5vZmZzZXRXaWR0aCxsPWE/ZS5pbm5lckhlaWdodDpzWzBdLm9mZnNldEhlaWdodCxvPXQuJGVsLm9mZnNldCgpLHtydGxUcmFuc2xhdGU6dX09dDtsZXQgaD0hMTt1JiYoby5sZWZ0LT10LiRlbFswXS5zY3JvbGxMZWZ0KTtjb25zdCBtPVtbby5sZWZ0LG8udG9wXSxbby5sZWZ0K3Qud2lkdGgsby50b3BdLFtvLmxlZnQsby50b3ArdC5oZWlnaHRdLFtvLmxlZnQrdC53aWR0aCxvLnRvcCt0LmhlaWdodF1dO2ZvcihsZXQgZT0wO2U8bS5sZW5ndGg7ZSs9MSl7Y29uc3QgdD1tW2VdO2lmKHRbMF0+PTAmJnRbMF08PWkmJnRbMV0+PTAmJnRbMV08PWwpe2lmKDA9PT10WzBdJiYwPT09dFsxXSljb250aW51ZTtoPSEwfX1jb25zdCBmPSEoXCJ0b3VjaHN0YXJ0XCIhPT10LnRvdWNoRXZlbnRzLnN0YXJ0fHwhdC5zdXBwb3J0LnBhc3NpdmVMaXN0ZW5lcnx8IXQucGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMpJiZ7cGFzc2l2ZTohMCxjYXB0dXJlOiExfTtoPyhjKCkscy5vZmYoXCJzY3JvbGxcIixwLGYpKTpufHwobj0hMCxzLm9uKFwic2Nyb2xsXCIscCxmKSl9YShcImJlZm9yZUluaXRcIiwoKCk9Pnt0LnBhcmFtcy5sYXp5LmVuYWJsZWQmJnQucGFyYW1zLnByZWxvYWRJbWFnZXMmJih0LnBhcmFtcy5wcmVsb2FkSW1hZ2VzPSExKX0pKSxhKFwiaW5pdFwiLCgoKT0+e3QucGFyYW1zLmxhenkuZW5hYmxlZCYmKHQucGFyYW1zLmxhenkuY2hlY2tJblZpZXc/cCgpOmMoKSl9KSksYShcInNjcm9sbFwiLCgoKT0+e3QucGFyYW1zLmZyZWVNb2RlJiZ0LnBhcmFtcy5mcmVlTW9kZS5lbmFibGVkJiYhdC5wYXJhbXMuZnJlZU1vZGUuc3RpY2t5JiZjKCl9KSksYShcInNjcm9sbGJhckRyYWdNb3ZlIHJlc2l6ZSBfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZVwiLCgoKT0+e3QucGFyYW1zLmxhenkuZW5hYmxlZCYmKHQucGFyYW1zLmxhenkuY2hlY2tJblZpZXc/cCgpOmMoKSl9KSksYShcInRyYW5zaXRpb25TdGFydFwiLCgoKT0+e3QucGFyYW1zLmxhenkuZW5hYmxlZCYmKHQucGFyYW1zLmxhenkubG9hZE9uVHJhbnNpdGlvblN0YXJ0fHwhdC5wYXJhbXMubGF6eS5sb2FkT25UcmFuc2l0aW9uU3RhcnQmJiFsKSYmKHQucGFyYW1zLmxhenkuY2hlY2tJblZpZXc/cCgpOmMoKSl9KSksYShcInRyYW5zaXRpb25FbmRcIiwoKCk9Pnt0LnBhcmFtcy5sYXp5LmVuYWJsZWQmJiF0LnBhcmFtcy5sYXp5LmxvYWRPblRyYW5zaXRpb25TdGFydCYmKHQucGFyYW1zLmxhenkuY2hlY2tJblZpZXc/cCgpOmMoKSl9KSksYShcInNsaWRlQ2hhbmdlXCIsKCgpPT57Y29uc3R7bGF6eTplLGNzc01vZGU6cyx3YXRjaFNsaWRlc1Byb2dyZXNzOmEsdG91Y2hSZWxlYXNlT25FZGdlczppLHJlc2lzdGFuY2VSYXRpbzpyfT10LnBhcmFtcztlLmVuYWJsZWQmJihzfHxhJiYoaXx8MD09PXIpKSYmYygpfSkpLGEoXCJkZXN0cm95XCIsKCgpPT57dC4kZWwmJnQuJGVsLmZpbmQoYC4ke3QucGFyYW1zLmxhenkubG9hZGluZ0NsYXNzfWApLnJlbW92ZUNsYXNzKHQucGFyYW1zLmxhenkubG9hZGluZ0NsYXNzKX0pKSxPYmplY3QuYXNzaWduKHQubGF6eSx7bG9hZDpjLGxvYWRJblNsaWRlOm99KX0sZnVuY3Rpb24oZSl7bGV0e3N3aXBlcjp0LGV4dGVuZFBhcmFtczpzLG9uOmF9PWU7ZnVuY3Rpb24gaShlLHQpe2NvbnN0IHM9ZnVuY3Rpb24oKXtsZXQgZSx0LHM7cmV0dXJuKGEsaSk9Pntmb3IodD0tMSxlPWEubGVuZ3RoO2UtdD4xOylzPWUrdD4+MSxhW3NdPD1pP3Q9czplPXM7cmV0dXJuIGV9fSgpO2xldCBhLGk7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMubGFzdEluZGV4PWUubGVuZ3RoLTEsdGhpcy5pbnRlcnBvbGF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gZT8oaT1zKHRoaXMueCxlKSxhPWktMSwoZS10aGlzLnhbYV0pKih0aGlzLnlbaV0tdGhpcy55W2FdKS8odGhpcy54W2ldLXRoaXMueFthXSkrdGhpcy55W2FdKTowfSx0aGlzfWZ1bmN0aW9uIHIoKXt0LmNvbnRyb2xsZXIuY29udHJvbCYmdC5jb250cm9sbGVyLnNwbGluZSYmKHQuY29udHJvbGxlci5zcGxpbmU9dm9pZCAwLGRlbGV0ZSB0LmNvbnRyb2xsZXIuc3BsaW5lKX1zKHtjb250cm9sbGVyOntjb250cm9sOnZvaWQgMCxpbnZlcnNlOiExLGJ5Olwic2xpZGVcIn19KSx0LmNvbnRyb2xsZXI9e2NvbnRyb2w6dm9pZCAwfSxhKFwiYmVmb3JlSW5pdFwiLCgoKT0+e3QuY29udHJvbGxlci5jb250cm9sPXQucGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbH0pKSxhKFwidXBkYXRlXCIsKCgpPT57cigpfSkpLGEoXCJyZXNpemVcIiwoKCk9PntyKCl9KSksYShcIm9ic2VydmVyVXBkYXRlXCIsKCgpPT57cigpfSkpLGEoXCJzZXRUcmFuc2xhdGVcIiwoKGUscyxhKT0+e3QuY29udHJvbGxlci5jb250cm9sJiZ0LmNvbnRyb2xsZXIuc2V0VHJhbnNsYXRlKHMsYSl9KSksYShcInNldFRyYW5zaXRpb25cIiwoKGUscyxhKT0+e3QuY29udHJvbGxlci5jb250cm9sJiZ0LmNvbnRyb2xsZXIuc2V0VHJhbnNpdGlvbihzLGEpfSkpLE9iamVjdC5hc3NpZ24odC5jb250cm9sbGVyLHtzZXRUcmFuc2xhdGU6ZnVuY3Rpb24oZSxzKXtjb25zdCBhPXQuY29udHJvbGxlci5jb250cm9sO2xldCByLG47Y29uc3QgbD10LmNvbnN0cnVjdG9yO2Z1bmN0aW9uIG8oZSl7Y29uc3Qgcz10LnJ0bFRyYW5zbGF0ZT8tdC50cmFuc2xhdGU6dC50cmFuc2xhdGU7XCJzbGlkZVwiPT09dC5wYXJhbXMuY29udHJvbGxlci5ieSYmKCFmdW5jdGlvbihlKXt0LmNvbnRyb2xsZXIuc3BsaW5lfHwodC5jb250cm9sbGVyLnNwbGluZT10LnBhcmFtcy5sb29wP25ldyBpKHQuc2xpZGVzR3JpZCxlLnNsaWRlc0dyaWQpOm5ldyBpKHQuc25hcEdyaWQsZS5zbmFwR3JpZCkpfShlKSxuPS10LmNvbnRyb2xsZXIuc3BsaW5lLmludGVycG9sYXRlKC1zKSksbiYmXCJjb250YWluZXJcIiE9PXQucGFyYW1zLmNvbnRyb2xsZXIuYnl8fChyPShlLm1heFRyYW5zbGF0ZSgpLWUubWluVHJhbnNsYXRlKCkpLyh0Lm1heFRyYW5zbGF0ZSgpLXQubWluVHJhbnNsYXRlKCkpLG49KHMtdC5taW5UcmFuc2xhdGUoKSkqcitlLm1pblRyYW5zbGF0ZSgpKSx0LnBhcmFtcy5jb250cm9sbGVyLmludmVyc2UmJihuPWUubWF4VHJhbnNsYXRlKCktbiksZS51cGRhdGVQcm9ncmVzcyhuKSxlLnNldFRyYW5zbGF0ZShuLHQpLGUudXBkYXRlQWN0aXZlSW5kZXgoKSxlLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKX1pZihBcnJheS5pc0FycmF5KGEpKWZvcihsZXQgZT0wO2U8YS5sZW5ndGg7ZSs9MSlhW2VdIT09cyYmYVtlXWluc3RhbmNlb2YgbCYmbyhhW2VdKTtlbHNlIGEgaW5zdGFuY2VvZiBsJiZzIT09YSYmbyhhKX0sc2V0VHJhbnNpdGlvbjpmdW5jdGlvbihlLHMpe2NvbnN0IGE9dC5jb25zdHJ1Y3RvcixpPXQuY29udHJvbGxlci5jb250cm9sO2xldCByO2Z1bmN0aW9uIG4ocyl7cy5zZXRUcmFuc2l0aW9uKGUsdCksMCE9PWUmJihzLnRyYW5zaXRpb25TdGFydCgpLHMucGFyYW1zLmF1dG9IZWlnaHQmJnAoKCgpPT57cy51cGRhdGVBdXRvSGVpZ2h0KCl9KSkscy4kd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoKCgpPT57aSYmKHMucGFyYW1zLmxvb3AmJlwic2xpZGVcIj09PXQucGFyYW1zLmNvbnRyb2xsZXIuYnkmJnMubG9vcEZpeCgpLHMudHJhbnNpdGlvbkVuZCgpKX0pKSl9aWYoQXJyYXkuaXNBcnJheShpKSlmb3Iocj0wO3I8aS5sZW5ndGg7cis9MSlpW3JdIT09cyYmaVtyXWluc3RhbmNlb2YgYSYmbihpW3JdKTtlbHNlIGkgaW5zdGFuY2VvZiBhJiZzIT09aSYmbihpKX19KX0sZnVuY3Rpb24oZSl7bGV0e3N3aXBlcjp0LGV4dGVuZFBhcmFtczpzLG9uOmF9PWU7cyh7YTExeTp7ZW5hYmxlZDohMCxub3RpZmljYXRpb25DbGFzczpcInN3aXBlci1ub3RpZmljYXRpb25cIixwcmV2U2xpZGVNZXNzYWdlOlwiUHJldmlvdXMgc2xpZGVcIixuZXh0U2xpZGVNZXNzYWdlOlwiTmV4dCBzbGlkZVwiLGZpcnN0U2xpZGVNZXNzYWdlOlwiVGhpcyBpcyB0aGUgZmlyc3Qgc2xpZGVcIixsYXN0U2xpZGVNZXNzYWdlOlwiVGhpcyBpcyB0aGUgbGFzdCBzbGlkZVwiLHBhZ2luYXRpb25CdWxsZXRNZXNzYWdlOlwiR28gdG8gc2xpZGUge3tpbmRleH19XCIsc2xpZGVMYWJlbE1lc3NhZ2U6XCJ7e2luZGV4fX0gLyB7e3NsaWRlc0xlbmd0aH19XCIsY29udGFpbmVyTWVzc2FnZTpudWxsLGNvbnRhaW5lclJvbGVEZXNjcmlwdGlvbk1lc3NhZ2U6bnVsbCxpdGVtUm9sZURlc2NyaXB0aW9uTWVzc2FnZTpudWxsLHNsaWRlUm9sZTpcImdyb3VwXCIsaWQ6bnVsbH19KTtsZXQgaT1udWxsO2Z1bmN0aW9uIHIoZSl7Y29uc3QgdD1pOzAhPT10Lmxlbmd0aCYmKHQuaHRtbChcIlwiKSx0Lmh0bWwoZSkpfWZ1bmN0aW9uIG4oZSl7ZS5hdHRyKFwidGFiSW5kZXhcIixcIjBcIil9ZnVuY3Rpb24gbChlKXtlLmF0dHIoXCJ0YWJJbmRleFwiLFwiLTFcIil9ZnVuY3Rpb24gbyhlLHQpe2UuYXR0cihcInJvbGVcIix0KX1mdW5jdGlvbiBjKGUsdCl7ZS5hdHRyKFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIix0KX1mdW5jdGlvbiBwKGUsdCl7ZS5hdHRyKFwiYXJpYS1sYWJlbFwiLHQpfWZ1bmN0aW9uIHUoZSl7ZS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLCEwKX1mdW5jdGlvbiBoKGUpe2UuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwhMSl9ZnVuY3Rpb24gbShlKXtpZigxMyE9PWUua2V5Q29kZSYmMzIhPT1lLmtleUNvZGUpcmV0dXJuO2NvbnN0IHM9dC5wYXJhbXMuYTExeSxhPWQoZS50YXJnZXQpO3QubmF2aWdhdGlvbiYmdC5uYXZpZ2F0aW9uLiRuZXh0RWwmJmEuaXModC5uYXZpZ2F0aW9uLiRuZXh0RWwpJiYodC5pc0VuZCYmIXQucGFyYW1zLmxvb3B8fHQuc2xpZGVOZXh0KCksdC5pc0VuZD9yKHMubGFzdFNsaWRlTWVzc2FnZSk6cihzLm5leHRTbGlkZU1lc3NhZ2UpKSx0Lm5hdmlnYXRpb24mJnQubmF2aWdhdGlvbi4kcHJldkVsJiZhLmlzKHQubmF2aWdhdGlvbi4kcHJldkVsKSYmKHQuaXNCZWdpbm5pbmcmJiF0LnBhcmFtcy5sb29wfHx0LnNsaWRlUHJldigpLHQuaXNCZWdpbm5pbmc/cihzLmZpcnN0U2xpZGVNZXNzYWdlKTpyKHMucHJldlNsaWRlTWVzc2FnZSkpLHQucGFnaW5hdGlvbiYmYS5pcyhVKHQucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MpKSYmYVswXS5jbGljaygpfWZ1bmN0aW9uIGYoKXtyZXR1cm4gdC5wYWdpbmF0aW9uJiZ0LnBhZ2luYXRpb24uYnVsbGV0cyYmdC5wYWdpbmF0aW9uLmJ1bGxldHMubGVuZ3RofWZ1bmN0aW9uIGcoKXtyZXR1cm4gZigpJiZ0LnBhcmFtcy5wYWdpbmF0aW9uLmNsaWNrYWJsZX1jb25zdCB2PShlLHQscyk9PntuKGUpLFwiQlVUVE9OXCIhPT1lWzBdLnRhZ05hbWUmJihvKGUsXCJidXR0b25cIiksZS5vbihcImtleWRvd25cIixtKSkscChlLHMpLGZ1bmN0aW9uKGUsdCl7ZS5hdHRyKFwiYXJpYS1jb250cm9sc1wiLHQpfShlLHQpfSx3PWU9Pntjb25zdCBzPWUudGFyZ2V0LmNsb3Nlc3QoYC4ke3QucGFyYW1zLnNsaWRlQ2xhc3N9YCk7aWYoIXN8fCF0LnNsaWRlcy5pbmNsdWRlcyhzKSlyZXR1cm47Y29uc3QgYT10LnNsaWRlcy5pbmRleE9mKHMpPT09dC5hY3RpdmVJbmRleCxpPXQucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MmJnQudmlzaWJsZVNsaWRlcyYmdC52aXNpYmxlU2xpZGVzLmluY2x1ZGVzKHMpO2F8fGl8fHQuc2xpZGVUbyh0LnNsaWRlcy5pbmRleE9mKHMpLDApfSxiPSgpPT57Y29uc3QgZT10LnBhcmFtcy5hMTF5O2UuaXRlbVJvbGVEZXNjcmlwdGlvbk1lc3NhZ2UmJmMoZCh0LnNsaWRlcyksZS5pdGVtUm9sZURlc2NyaXB0aW9uTWVzc2FnZSksbyhkKHQuc2xpZGVzKSxlLnNsaWRlUm9sZSk7Y29uc3Qgcz10LnBhcmFtcy5sb29wP3Quc2xpZGVzLmZpbHRlcigoZT0+IWUuY2xhc3NMaXN0LmNvbnRhaW5zKHQucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSkubGVuZ3RoOnQuc2xpZGVzLmxlbmd0aDtlLnNsaWRlTGFiZWxNZXNzYWdlJiZ0LnNsaWRlcy5lYWNoKCgoYSxpKT0+e2NvbnN0IHI9ZChhKSxuPXQucGFyYW1zLmxvb3A/cGFyc2VJbnQoci5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiksMTApOmk7cChyLGUuc2xpZGVMYWJlbE1lc3NhZ2UucmVwbGFjZSgvXFx7XFx7aW5kZXhcXH1cXH0vLG4rMSkucmVwbGFjZSgvXFx7XFx7c2xpZGVzTGVuZ3RoXFx9XFx9LyxzKSl9KSl9LHg9KCk9Pntjb25zdCBlPXQucGFyYW1zLmExMXk7dC4kZWwuYXBwZW5kKGkpO2NvbnN0IHM9dC4kZWw7ZS5jb250YWluZXJSb2xlRGVzY3JpcHRpb25NZXNzYWdlJiZjKHMsZS5jb250YWluZXJSb2xlRGVzY3JpcHRpb25NZXNzYWdlKSxlLmNvbnRhaW5lck1lc3NhZ2UmJnAocyxlLmNvbnRhaW5lck1lc3NhZ2UpO2NvbnN0IGE9dC4kd3JhcHBlckVsLHI9ZS5pZHx8YS5hdHRyKFwiaWRcIil8fGBzd2lwZXItd3JhcHBlci0ke249MTYsdm9pZCAwPT09biYmKG49MTYpLFwieFwiLnJlcGVhdChuKS5yZXBsYWNlKC94L2csKCgpPT5NYXRoLnJvdW5kKDE2Kk1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KSkpfWA7dmFyIG47Y29uc3QgbD10LnBhcmFtcy5hdXRvcGxheSYmdC5wYXJhbXMuYXV0b3BsYXkuZW5hYmxlZD9cIm9mZlwiOlwicG9saXRlXCI7dmFyIG87bGV0IGQsdTtvPXIsYS5hdHRyKFwiaWRcIixvKSxmdW5jdGlvbihlLHQpe2UuYXR0cihcImFyaWEtbGl2ZVwiLHQpfShhLGwpLGIoKSx0Lm5hdmlnYXRpb24mJnQubmF2aWdhdGlvbi4kbmV4dEVsJiYoZD10Lm5hdmlnYXRpb24uJG5leHRFbCksdC5uYXZpZ2F0aW9uJiZ0Lm5hdmlnYXRpb24uJHByZXZFbCYmKHU9dC5uYXZpZ2F0aW9uLiRwcmV2RWwpLGQmJmQubGVuZ3RoJiZ2KGQscixlLm5leHRTbGlkZU1lc3NhZ2UpLHUmJnUubGVuZ3RoJiZ2KHUscixlLnByZXZTbGlkZU1lc3NhZ2UpLGcoKSYmdC5wYWdpbmF0aW9uLiRlbC5vbihcImtleWRvd25cIixVKHQucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MpLG0pLHQuJGVsLm9uKFwiZm9jdXNcIix3LCEwKX07YShcImJlZm9yZUluaXRcIiwoKCk9PntpPWQoYDxzcGFuIGNsYXNzPVwiJHt0LnBhcmFtcy5hMTF5Lm5vdGlmaWNhdGlvbkNsYXNzfVwiIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiIGFyaWEtYXRvbWljPVwidHJ1ZVwiPjwvc3Bhbj5gKX0pKSxhKFwiYWZ0ZXJJbml0XCIsKCgpPT57dC5wYXJhbXMuYTExeS5lbmFibGVkJiZ4KCl9KSksYShcInNsaWRlc0xlbmd0aENoYW5nZSBzbmFwR3JpZExlbmd0aENoYW5nZSBzbGlkZXNHcmlkTGVuZ3RoQ2hhbmdlXCIsKCgpPT57dC5wYXJhbXMuYTExeS5lbmFibGVkJiZiKCl9KSksYShcImZyb21FZGdlIHRvRWRnZSBhZnRlckluaXQgbG9jayB1bmxvY2tcIiwoKCk9Pnt0LnBhcmFtcy5hMTF5LmVuYWJsZWQmJmZ1bmN0aW9uKCl7aWYodC5wYXJhbXMubG9vcHx8dC5wYXJhbXMucmV3aW5kfHwhdC5uYXZpZ2F0aW9uKXJldHVybjtjb25zdHskbmV4dEVsOmUsJHByZXZFbDpzfT10Lm5hdmlnYXRpb247cyYmcy5sZW5ndGg+MCYmKHQuaXNCZWdpbm5pbmc/KHUocyksbChzKSk6KGgocyksbihzKSkpLGUmJmUubGVuZ3RoPjAmJih0LmlzRW5kPyh1KGUpLGwoZSkpOihoKGUpLG4oZSkpKX0oKX0pKSxhKFwicGFnaW5hdGlvblVwZGF0ZVwiLCgoKT0+e3QucGFyYW1zLmExMXkuZW5hYmxlZCYmZnVuY3Rpb24oKXtjb25zdCBlPXQucGFyYW1zLmExMXk7ZigpJiZ0LnBhZ2luYXRpb24uYnVsbGV0cy5lYWNoKChzPT57Y29uc3QgYT1kKHMpO3QucGFyYW1zLnBhZ2luYXRpb24uY2xpY2thYmxlJiYobihhKSx0LnBhcmFtcy5wYWdpbmF0aW9uLnJlbmRlckJ1bGxldHx8KG8oYSxcImJ1dHRvblwiKSxwKGEsZS5wYWdpbmF0aW9uQnVsbGV0TWVzc2FnZS5yZXBsYWNlKC9cXHtcXHtpbmRleFxcfVxcfS8sYS5pbmRleCgpKzEpKSkpLGEuaXMoYC4ke3QucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0QWN0aXZlQ2xhc3N9YCk/YS5hdHRyKFwiYXJpYS1jdXJyZW50XCIsXCJ0cnVlXCIpOmEucmVtb3ZlQXR0cihcImFyaWEtY3VycmVudFwiKX0pKX0oKX0pKSxhKFwiZGVzdHJveVwiLCgoKT0+e3QucGFyYW1zLmExMXkuZW5hYmxlZCYmZnVuY3Rpb24oKXtsZXQgZSxzO2kmJmkubGVuZ3RoPjAmJmkucmVtb3ZlKCksdC5uYXZpZ2F0aW9uJiZ0Lm5hdmlnYXRpb24uJG5leHRFbCYmKGU9dC5uYXZpZ2F0aW9uLiRuZXh0RWwpLHQubmF2aWdhdGlvbiYmdC5uYXZpZ2F0aW9uLiRwcmV2RWwmJihzPXQubmF2aWdhdGlvbi4kcHJldkVsKSxlJiZlLm9mZihcImtleWRvd25cIixtKSxzJiZzLm9mZihcImtleWRvd25cIixtKSxnKCkmJnQucGFnaW5hdGlvbi4kZWwub2ZmKFwia2V5ZG93blwiLFUodC5wYXJhbXMucGFnaW5hdGlvbi5idWxsZXRDbGFzcyksbSksdC4kZWwub2ZmKFwiZm9jdXNcIix3LCEwKX0oKX0pKX0sZnVuY3Rpb24oZSl7bGV0e3N3aXBlcjp0LGV4dGVuZFBhcmFtczpzLG9uOmF9PWU7cyh7aGlzdG9yeTp7ZW5hYmxlZDohMSxyb290OlwiXCIscmVwbGFjZVN0YXRlOiExLGtleTpcInNsaWRlc1wiLGtlZXBRdWVyeTohMX19KTtsZXQgaT0hMSxuPXt9O2NvbnN0IGw9ZT0+ZS50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZyxcIi1cIikucmVwbGFjZSgvW15cXHctXSsvZyxcIlwiKS5yZXBsYWNlKC8tLSsvZyxcIi1cIikucmVwbGFjZSgvXi0rLyxcIlwiKS5yZXBsYWNlKC8tKyQvLFwiXCIpLG89ZT0+e2NvbnN0IHQ9cigpO2xldCBzO3M9ZT9uZXcgVVJMKGUpOnQubG9jYXRpb247Y29uc3QgYT1zLnBhdGhuYW1lLnNsaWNlKDEpLnNwbGl0KFwiL1wiKS5maWx0ZXIoKGU9PlwiXCIhPT1lKSksaT1hLmxlbmd0aDtyZXR1cm57a2V5OmFbaS0yXSx2YWx1ZTphW2ktMV19fSxkPShlLHMpPT57Y29uc3QgYT1yKCk7aWYoIWl8fCF0LnBhcmFtcy5oaXN0b3J5LmVuYWJsZWQpcmV0dXJuO2xldCBuO249dC5wYXJhbXMudXJsP25ldyBVUkwodC5wYXJhbXMudXJsKTphLmxvY2F0aW9uO2NvbnN0IG89dC5zbGlkZXMuZXEocyk7bGV0IGQ9bChvLmF0dHIoXCJkYXRhLWhpc3RvcnlcIikpO2lmKHQucGFyYW1zLmhpc3Rvcnkucm9vdC5sZW5ndGg+MCl7bGV0IHM9dC5wYXJhbXMuaGlzdG9yeS5yb290O1wiL1wiPT09c1tzLmxlbmd0aC0xXSYmKHM9cy5zbGljZSgwLHMubGVuZ3RoLTEpKSxkPWAke3N9LyR7ZX0vJHtkfWB9ZWxzZSBuLnBhdGhuYW1lLmluY2x1ZGVzKGUpfHwoZD1gJHtlfS8ke2R9YCk7dC5wYXJhbXMuaGlzdG9yeS5rZWVwUXVlcnkmJihkKz1uLnNlYXJjaCk7Y29uc3QgYz1hLmhpc3Rvcnkuc3RhdGU7YyYmYy52YWx1ZT09PWR8fCh0LnBhcmFtcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZT9hLmhpc3RvcnkucmVwbGFjZVN0YXRlKHt2YWx1ZTpkfSxudWxsLGQpOmEuaGlzdG9yeS5wdXNoU3RhdGUoe3ZhbHVlOmR9LG51bGwsZCkpfSxjPShlLHMsYSk9PntpZihzKWZvcihsZXQgaT0wLHI9dC5zbGlkZXMubGVuZ3RoO2k8cjtpKz0xKXtjb25zdCByPXQuc2xpZGVzLmVxKGkpO2lmKGwoci5hdHRyKFwiZGF0YS1oaXN0b3J5XCIpKT09PXMmJiFyLmhhc0NsYXNzKHQucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKXtjb25zdCBzPXIuaW5kZXgoKTt0LnNsaWRlVG8ocyxlLGEpfX1lbHNlIHQuc2xpZGVUbygwLGUsYSl9LHA9KCk9PntuPW8odC5wYXJhbXMudXJsKSxjKHQucGFyYW1zLnNwZWVkLG4udmFsdWUsITEpfTthKFwiaW5pdFwiLCgoKT0+e3QucGFyYW1zLmhpc3RvcnkuZW5hYmxlZCYmKCgpPT57Y29uc3QgZT1yKCk7aWYodC5wYXJhbXMuaGlzdG9yeSl7aWYoIWUuaGlzdG9yeXx8IWUuaGlzdG9yeS5wdXNoU3RhdGUpcmV0dXJuIHQucGFyYW1zLmhpc3RvcnkuZW5hYmxlZD0hMSx2b2lkKHQucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQ9ITApO2k9ITAsbj1vKHQucGFyYW1zLnVybCksKG4ua2V5fHxuLnZhbHVlKSYmKGMoMCxuLnZhbHVlLHQucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCksdC5wYXJhbXMuaGlzdG9yeS5yZXBsYWNlU3RhdGV8fGUuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIscCkpfX0pKCl9KSksYShcImRlc3Ryb3lcIiwoKCk9Pnt0LnBhcmFtcy5oaXN0b3J5LmVuYWJsZWQmJigoKT0+e2NvbnN0IGU9cigpO3QucGFyYW1zLmhpc3RvcnkucmVwbGFjZVN0YXRlfHxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLHApfSkoKX0pKSxhKFwidHJhbnNpdGlvbkVuZCBfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZVwiLCgoKT0+e2kmJmQodC5wYXJhbXMuaGlzdG9yeS5rZXksdC5hY3RpdmVJbmRleCl9KSksYShcInNsaWRlQ2hhbmdlXCIsKCgpPT57aSYmdC5wYXJhbXMuY3NzTW9kZSYmZCh0LnBhcmFtcy5oaXN0b3J5LmtleSx0LmFjdGl2ZUluZGV4KX0pKX0sZnVuY3Rpb24oZSl7bGV0e3N3aXBlcjp0LGV4dGVuZFBhcmFtczpzLGVtaXQ6aSxvbjpufT1lLGw9ITE7Y29uc3Qgbz1hKCksYz1yKCk7cyh7aGFzaE5hdmlnYXRpb246e2VuYWJsZWQ6ITEscmVwbGFjZVN0YXRlOiExLHdhdGNoU3RhdGU6ITF9fSk7Y29uc3QgcD0oKT0+e2koXCJoYXNoQ2hhbmdlXCIpO2NvbnN0IGU9by5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoXCIjXCIsXCJcIik7aWYoZSE9PXQuc2xpZGVzLmVxKHQuYWN0aXZlSW5kZXgpLmF0dHIoXCJkYXRhLWhhc2hcIikpe2NvbnN0IHM9dC4kd3JhcHBlckVsLmNoaWxkcmVuKGAuJHt0LnBhcmFtcy5zbGlkZUNsYXNzfVtkYXRhLWhhc2g9XCIke2V9XCJdYCkuaW5kZXgoKTtpZih2b2lkIDA9PT1zKXJldHVybjt0LnNsaWRlVG8ocyl9fSx1PSgpPT57aWYobCYmdC5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZClpZih0LnBhcmFtcy5oYXNoTmF2aWdhdGlvbi5yZXBsYWNlU3RhdGUmJmMuaGlzdG9yeSYmYy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSljLmhpc3RvcnkucmVwbGFjZVN0YXRlKG51bGwsbnVsbCxgIyR7dC5zbGlkZXMuZXEodC5hY3RpdmVJbmRleCkuYXR0cihcImRhdGEtaGFzaFwiKX1gfHxcIlwiKSxpKFwiaGFzaFNldFwiKTtlbHNle2NvbnN0IGU9dC5zbGlkZXMuZXEodC5hY3RpdmVJbmRleCkscz1lLmF0dHIoXCJkYXRhLWhhc2hcIil8fGUuYXR0cihcImRhdGEtaGlzdG9yeVwiKTtvLmxvY2F0aW9uLmhhc2g9c3x8XCJcIixpKFwiaGFzaFNldFwiKX19O24oXCJpbml0XCIsKCgpPT57dC5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCYmKCgpPT57aWYoIXQucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWR8fHQucGFyYW1zLmhpc3RvcnkmJnQucGFyYW1zLmhpc3RvcnkuZW5hYmxlZClyZXR1cm47bD0hMDtjb25zdCBlPW8ubG9jYXRpb24uaGFzaC5yZXBsYWNlKFwiI1wiLFwiXCIpO2lmKGUpe2NvbnN0IHM9MDtmb3IobGV0IGE9MCxpPXQuc2xpZGVzLmxlbmd0aDthPGk7YSs9MSl7Y29uc3QgaT10LnNsaWRlcy5lcShhKTtpZigoaS5hdHRyKFwiZGF0YS1oYXNoXCIpfHxpLmF0dHIoXCJkYXRhLWhpc3RvcnlcIikpPT09ZSYmIWkuaGFzQ2xhc3ModC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpe2NvbnN0IGU9aS5pbmRleCgpO3Quc2xpZGVUbyhlLHMsdC5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0LCEwKX19fXQucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLndhdGNoU3RhdGUmJmQoYykub24oXCJoYXNoY2hhbmdlXCIscCl9KSgpfSkpLG4oXCJkZXN0cm95XCIsKCgpPT57dC5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCYmdC5wYXJhbXMuaGFzaE5hdmlnYXRpb24ud2F0Y2hTdGF0ZSYmZChjKS5vZmYoXCJoYXNoY2hhbmdlXCIscCl9KSksbihcInRyYW5zaXRpb25FbmQgX2ZyZWVNb2RlTm9Nb21lbnR1bVJlbGVhc2VcIiwoKCk9PntsJiZ1KCl9KSksbihcInNsaWRlQ2hhbmdlXCIsKCgpPT57bCYmdC5wYXJhbXMuY3NzTW9kZSYmdSgpfSkpfSxmdW5jdGlvbihlKXtsZXQgdCx7c3dpcGVyOnMsZXh0ZW5kUGFyYW1zOmksb246cixlbWl0Om59PWU7ZnVuY3Rpb24gbCgpe2NvbnN0IGU9cy5zbGlkZXMuZXEocy5hY3RpdmVJbmRleCk7bGV0IGE9cy5wYXJhbXMuYXV0b3BsYXkuZGVsYXk7ZS5hdHRyKFwiZGF0YS1zd2lwZXItYXV0b3BsYXlcIikmJihhPWUuYXR0cihcImRhdGEtc3dpcGVyLWF1dG9wbGF5XCIpfHxzLnBhcmFtcy5hdXRvcGxheS5kZWxheSksY2xlYXJUaW1lb3V0KHQpLHQ9cCgoKCk9PntsZXQgZTtzLnBhcmFtcy5hdXRvcGxheS5yZXZlcnNlRGlyZWN0aW9uP3MucGFyYW1zLmxvb3A/KHMubG9vcEZpeCgpLGU9cy5zbGlkZVByZXYocy5wYXJhbXMuc3BlZWQsITAsITApLG4oXCJhdXRvcGxheVwiKSk6cy5pc0JlZ2lubmluZz9zLnBhcmFtcy5hdXRvcGxheS5zdG9wT25MYXN0U2xpZGU/ZCgpOihlPXMuc2xpZGVUbyhzLnNsaWRlcy5sZW5ndGgtMSxzLnBhcmFtcy5zcGVlZCwhMCwhMCksbihcImF1dG9wbGF5XCIpKTooZT1zLnNsaWRlUHJldihzLnBhcmFtcy5zcGVlZCwhMCwhMCksbihcImF1dG9wbGF5XCIpKTpzLnBhcmFtcy5sb29wPyhzLmxvb3BGaXgoKSxlPXMuc2xpZGVOZXh0KHMucGFyYW1zLnNwZWVkLCEwLCEwKSxuKFwiYXV0b3BsYXlcIikpOnMuaXNFbmQ/cy5wYXJhbXMuYXV0b3BsYXkuc3RvcE9uTGFzdFNsaWRlP2QoKTooZT1zLnNsaWRlVG8oMCxzLnBhcmFtcy5zcGVlZCwhMCwhMCksbihcImF1dG9wbGF5XCIpKTooZT1zLnNsaWRlTmV4dChzLnBhcmFtcy5zcGVlZCwhMCwhMCksbihcImF1dG9wbGF5XCIpKSwocy5wYXJhbXMuY3NzTW9kZSYmcy5hdXRvcGxheS5ydW5uaW5nfHwhMT09PWUpJiZsKCl9KSxhKX1mdW5jdGlvbiBvKCl7cmV0dXJuIHZvaWQgMD09PXQmJighcy5hdXRvcGxheS5ydW5uaW5nJiYocy5hdXRvcGxheS5ydW5uaW5nPSEwLG4oXCJhdXRvcGxheVN0YXJ0XCIpLGwoKSwhMCkpfWZ1bmN0aW9uIGQoKXtyZXR1cm4hIXMuYXV0b3BsYXkucnVubmluZyYmKHZvaWQgMCE9PXQmJih0JiYoY2xlYXJUaW1lb3V0KHQpLHQ9dm9pZCAwKSxzLmF1dG9wbGF5LnJ1bm5pbmc9ITEsbihcImF1dG9wbGF5U3RvcFwiKSwhMCkpfWZ1bmN0aW9uIGMoZSl7cy5hdXRvcGxheS5ydW5uaW5nJiYocy5hdXRvcGxheS5wYXVzZWR8fCh0JiZjbGVhclRpbWVvdXQodCkscy5hdXRvcGxheS5wYXVzZWQ9ITAsMCE9PWUmJnMucGFyYW1zLmF1dG9wbGF5LndhaXRGb3JUcmFuc2l0aW9uP1tcInRyYW5zaXRpb25lbmRcIixcIndlYmtpdFRyYW5zaXRpb25FbmRcIl0uZm9yRWFjaCgoZT0+e3MuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKGUsaCl9KSk6KHMuYXV0b3BsYXkucGF1c2VkPSExLGwoKSkpKX1mdW5jdGlvbiB1KCl7Y29uc3QgZT1hKCk7XCJoaWRkZW5cIj09PWUudmlzaWJpbGl0eVN0YXRlJiZzLmF1dG9wbGF5LnJ1bm5pbmcmJmMoKSxcInZpc2libGVcIj09PWUudmlzaWJpbGl0eVN0YXRlJiZzLmF1dG9wbGF5LnBhdXNlZCYmKGwoKSxzLmF1dG9wbGF5LnBhdXNlZD0hMSl9ZnVuY3Rpb24gaChlKXtzJiYhcy5kZXN0cm95ZWQmJnMuJHdyYXBwZXJFbCYmZS50YXJnZXQ9PT1zLiR3cmFwcGVyRWxbMF0mJihbXCJ0cmFuc2l0aW9uZW5kXCIsXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCJdLmZvckVhY2goKGU9PntzLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLGgpfSkpLHMuYXV0b3BsYXkucGF1c2VkPSExLHMuYXV0b3BsYXkucnVubmluZz9sKCk6ZCgpKX1mdW5jdGlvbiBtKCl7cy5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24/ZCgpOihuKFwiYXV0b3BsYXlQYXVzZVwiKSxjKCkpLFtcInRyYW5zaXRpb25lbmRcIixcIndlYmtpdFRyYW5zaXRpb25FbmRcIl0uZm9yRWFjaCgoZT0+e3MuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKGUsaCl9KSl9ZnVuY3Rpb24gZigpe3MucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9ufHwocy5hdXRvcGxheS5wYXVzZWQ9ITEsbihcImF1dG9wbGF5UmVzdW1lXCIpLGwoKSl9cy5hdXRvcGxheT17cnVubmluZzohMSxwYXVzZWQ6ITF9LGkoe2F1dG9wbGF5OntlbmFibGVkOiExLGRlbGF5OjNlMyx3YWl0Rm9yVHJhbnNpdGlvbjohMCxkaXNhYmxlT25JbnRlcmFjdGlvbjohMCxzdG9wT25MYXN0U2xpZGU6ITEscmV2ZXJzZURpcmVjdGlvbjohMSxwYXVzZU9uTW91c2VFbnRlcjohMX19KSxyKFwiaW5pdFwiLCgoKT0+e2lmKHMucGFyYW1zLmF1dG9wbGF5LmVuYWJsZWQpe28oKTthKCkuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIix1KSxzLnBhcmFtcy5hdXRvcGxheS5wYXVzZU9uTW91c2VFbnRlciYmKHMuJGVsLm9uKFwibW91c2VlbnRlclwiLG0pLHMuJGVsLm9uKFwibW91c2VsZWF2ZVwiLGYpKX19KSkscihcImJlZm9yZVRyYW5zaXRpb25TdGFydFwiLCgoZSx0LGEpPT57cy5hdXRvcGxheS5ydW5uaW5nJiYoYXx8IXMucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9uP3MuYXV0b3BsYXkucGF1c2UodCk6ZCgpKX0pKSxyKFwic2xpZGVyRmlyc3RNb3ZlXCIsKCgpPT57cy5hdXRvcGxheS5ydW5uaW5nJiYocy5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24/ZCgpOmMoKSl9KSkscihcInRvdWNoRW5kXCIsKCgpPT57cy5wYXJhbXMuY3NzTW9kZSYmcy5hdXRvcGxheS5wYXVzZWQmJiFzLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbiYmbCgpfSkpLHIoXCJkZXN0cm95XCIsKCgpPT57cy4kZWwub2ZmKFwibW91c2VlbnRlclwiLG0pLHMuJGVsLm9mZihcIm1vdXNlbGVhdmVcIixmKSxzLmF1dG9wbGF5LnJ1bm5pbmcmJmQoKTthKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIix1KX0pKSxPYmplY3QuYXNzaWduKHMuYXV0b3BsYXkse3BhdXNlOmMscnVuOmwsc3RhcnQ6byxzdG9wOmR9KX0sZnVuY3Rpb24oZSl7bGV0e3N3aXBlcjp0LGV4dGVuZFBhcmFtczpzLG9uOmF9PWU7cyh7dGh1bWJzOntzd2lwZXI6bnVsbCxtdWx0aXBsZUFjdGl2ZVRodW1iczohMCxhdXRvU2Nyb2xsT2Zmc2V0OjAsc2xpZGVUaHVtYkFjdGl2ZUNsYXNzOlwic3dpcGVyLXNsaWRlLXRodW1iLWFjdGl2ZVwiLHRodW1ic0NvbnRhaW5lckNsYXNzOlwic3dpcGVyLXRodW1ic1wifX0pO2xldCBpPSExLHI9ITE7ZnVuY3Rpb24gbigpe2NvbnN0IGU9dC50aHVtYnMuc3dpcGVyO2lmKCFlfHxlLmRlc3Ryb3llZClyZXR1cm47Y29uc3Qgcz1lLmNsaWNrZWRJbmRleCxhPWUuY2xpY2tlZFNsaWRlO2lmKGEmJmQoYSkuaGFzQ2xhc3ModC5wYXJhbXMudGh1bWJzLnNsaWRlVGh1bWJBY3RpdmVDbGFzcykpcmV0dXJuO2lmKG51bGw9PXMpcmV0dXJuO2xldCBpO2lmKGk9ZS5wYXJhbXMubG9vcD9wYXJzZUludChkKGUuY2xpY2tlZFNsaWRlKS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiksMTApOnMsdC5wYXJhbXMubG9vcCl7bGV0IGU9dC5hY3RpdmVJbmRleDt0LnNsaWRlcy5lcShlKS5oYXNDbGFzcyh0LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSYmKHQubG9vcEZpeCgpLHQuX2NsaWVudExlZnQ9dC4kd3JhcHBlckVsWzBdLmNsaWVudExlZnQsZT10LmFjdGl2ZUluZGV4KTtjb25zdCBzPXQuc2xpZGVzLmVxKGUpLnByZXZBbGwoYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7aX1cIl1gKS5lcSgwKS5pbmRleCgpLGE9dC5zbGlkZXMuZXEoZSkubmV4dEFsbChgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtpfVwiXWApLmVxKDApLmluZGV4KCk7aT12b2lkIDA9PT1zP2E6dm9pZCAwPT09YT9zOmEtZTxlLXM/YTpzfXQuc2xpZGVUbyhpKX1mdW5jdGlvbiBsKCl7Y29uc3R7dGh1bWJzOmV9PXQucGFyYW1zO2lmKGkpcmV0dXJuITE7aT0hMDtjb25zdCBzPXQuY29uc3RydWN0b3I7aWYoZS5zd2lwZXIgaW5zdGFuY2VvZiBzKXQudGh1bWJzLnN3aXBlcj1lLnN3aXBlcixPYmplY3QuYXNzaWduKHQudGh1bWJzLnN3aXBlci5vcmlnaW5hbFBhcmFtcyx7d2F0Y2hTbGlkZXNQcm9ncmVzczohMCxzbGlkZVRvQ2xpY2tlZFNsaWRlOiExfSksT2JqZWN0LmFzc2lnbih0LnRodW1icy5zd2lwZXIucGFyYW1zLHt3YXRjaFNsaWRlc1Byb2dyZXNzOiEwLHNsaWRlVG9DbGlja2VkU2xpZGU6ITF9KTtlbHNlIGlmKG0oZS5zd2lwZXIpKXtjb25zdCBhPU9iamVjdC5hc3NpZ24oe30sZS5zd2lwZXIpO09iamVjdC5hc3NpZ24oYSx7d2F0Y2hTbGlkZXNQcm9ncmVzczohMCxzbGlkZVRvQ2xpY2tlZFNsaWRlOiExfSksdC50aHVtYnMuc3dpcGVyPW5ldyBzKGEpLHI9ITB9cmV0dXJuIHQudGh1bWJzLnN3aXBlci4kZWwuYWRkQ2xhc3ModC5wYXJhbXMudGh1bWJzLnRodW1ic0NvbnRhaW5lckNsYXNzKSx0LnRodW1icy5zd2lwZXIub24oXCJ0YXBcIixuKSwhMH1mdW5jdGlvbiBvKGUpe2NvbnN0IHM9dC50aHVtYnMuc3dpcGVyO2lmKCFzfHxzLmRlc3Ryb3llZClyZXR1cm47Y29uc3QgYT1cImF1dG9cIj09PXMucGFyYW1zLnNsaWRlc1BlclZpZXc/cy5zbGlkZXNQZXJWaWV3RHluYW1pYygpOnMucGFyYW1zLnNsaWRlc1BlclZpZXcsaT10LnBhcmFtcy50aHVtYnMuYXV0b1Njcm9sbE9mZnNldCxyPWkmJiFzLnBhcmFtcy5sb29wO2lmKHQucmVhbEluZGV4IT09cy5yZWFsSW5kZXh8fHIpe2xldCBuLGwsbz1zLmFjdGl2ZUluZGV4O2lmKHMucGFyYW1zLmxvb3Ape3Muc2xpZGVzLmVxKG8pLmhhc0NsYXNzKHMucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpJiYocy5sb29wRml4KCkscy5fY2xpZW50TGVmdD1zLiR3cmFwcGVyRWxbMF0uY2xpZW50TGVmdCxvPXMuYWN0aXZlSW5kZXgpO2NvbnN0IGU9cy5zbGlkZXMuZXEobykucHJldkFsbChgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHt0LnJlYWxJbmRleH1cIl1gKS5lcSgwKS5pbmRleCgpLGE9cy5zbGlkZXMuZXEobykubmV4dEFsbChgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHt0LnJlYWxJbmRleH1cIl1gKS5lcSgwKS5pbmRleCgpO249dm9pZCAwPT09ZT9hOnZvaWQgMD09PWE/ZTphLW89PW8tZT9zLnBhcmFtcy5zbGlkZXNQZXJHcm91cD4xP2E6bzphLW88by1lP2E6ZSxsPXQuYWN0aXZlSW5kZXg+dC5wcmV2aW91c0luZGV4P1wibmV4dFwiOlwicHJldlwifWVsc2Ugbj10LnJlYWxJbmRleCxsPW4+dC5wcmV2aW91c0luZGV4P1wibmV4dFwiOlwicHJldlwiO3ImJihuKz1cIm5leHRcIj09PWw/aTotMSppKSxzLnZpc2libGVTbGlkZXNJbmRleGVzJiZzLnZpc2libGVTbGlkZXNJbmRleGVzLmluZGV4T2Yobik8MCYmKHMucGFyYW1zLmNlbnRlcmVkU2xpZGVzP249bj5vP24tTWF0aC5mbG9vcihhLzIpKzE6bitNYXRoLmZsb29yKGEvMiktMTpuPm8mJnMucGFyYW1zLnNsaWRlc1Blckdyb3VwLHMuc2xpZGVUbyhuLGU/MDp2b2lkIDApKX1sZXQgbj0xO2NvbnN0IGw9dC5wYXJhbXMudGh1bWJzLnNsaWRlVGh1bWJBY3RpdmVDbGFzcztpZih0LnBhcmFtcy5zbGlkZXNQZXJWaWV3PjEmJiF0LnBhcmFtcy5jZW50ZXJlZFNsaWRlcyYmKG49dC5wYXJhbXMuc2xpZGVzUGVyVmlldyksdC5wYXJhbXMudGh1bWJzLm11bHRpcGxlQWN0aXZlVGh1bWJzfHwobj0xKSxuPU1hdGguZmxvb3Iobikscy5zbGlkZXMucmVtb3ZlQ2xhc3MobCkscy5wYXJhbXMubG9vcHx8cy5wYXJhbXMudmlydHVhbCYmcy5wYXJhbXMudmlydHVhbC5lbmFibGVkKWZvcihsZXQgZT0wO2U8bjtlKz0xKXMuJHdyYXBwZXJFbC5jaGlsZHJlbihgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHt0LnJlYWxJbmRleCtlfVwiXWApLmFkZENsYXNzKGwpO2Vsc2UgZm9yKGxldCBlPTA7ZTxuO2UrPTEpcy5zbGlkZXMuZXEodC5yZWFsSW5kZXgrZSkuYWRkQ2xhc3MobCl9dC50aHVtYnM9e3N3aXBlcjpudWxsfSxhKFwiYmVmb3JlSW5pdFwiLCgoKT0+e2NvbnN0e3RodW1iczplfT10LnBhcmFtcztlJiZlLnN3aXBlciYmKGwoKSxvKCEwKSl9KSksYShcInNsaWRlQ2hhbmdlIHVwZGF0ZSByZXNpemUgb2JzZXJ2ZXJVcGRhdGVcIiwoKCk9PntvKCl9KSksYShcInNldFRyYW5zaXRpb25cIiwoKGUscyk9Pntjb25zdCBhPXQudGh1bWJzLnN3aXBlcjthJiYhYS5kZXN0cm95ZWQmJmEuc2V0VHJhbnNpdGlvbihzKX0pKSxhKFwiYmVmb3JlRGVzdHJveVwiLCgoKT0+e2NvbnN0IGU9dC50aHVtYnMuc3dpcGVyO2UmJiFlLmRlc3Ryb3llZCYmciYmZS5kZXN0cm95KCl9KSksT2JqZWN0LmFzc2lnbih0LnRodW1icyx7aW5pdDpsLHVwZGF0ZTpvfSl9LGZ1bmN0aW9uKGUpe2xldHtzd2lwZXI6dCxleHRlbmRQYXJhbXM6cyxlbWl0OmEsb25jZTppfT1lO3Moe2ZyZWVNb2RlOntlbmFibGVkOiExLG1vbWVudHVtOiEwLG1vbWVudHVtUmF0aW86MSxtb21lbnR1bUJvdW5jZTohMCxtb21lbnR1bUJvdW5jZVJhdGlvOjEsbW9tZW50dW1WZWxvY2l0eVJhdGlvOjEsc3RpY2t5OiExLG1pbmltdW1WZWxvY2l0eTouMDJ9fSksT2JqZWN0LmFzc2lnbih0LHtmcmVlTW9kZTp7b25Ub3VjaFN0YXJ0OmZ1bmN0aW9uKCl7Y29uc3QgZT10LmdldFRyYW5zbGF0ZSgpO3Quc2V0VHJhbnNsYXRlKGUpLHQuc2V0VHJhbnNpdGlvbigwKSx0LnRvdWNoRXZlbnRzRGF0YS52ZWxvY2l0aWVzLmxlbmd0aD0wLHQuZnJlZU1vZGUub25Ub3VjaEVuZCh7Y3VycmVudFBvczp0LnJ0bD90LnRyYW5zbGF0ZTotdC50cmFuc2xhdGV9KX0sb25Ub3VjaE1vdmU6ZnVuY3Rpb24oKXtjb25zdHt0b3VjaEV2ZW50c0RhdGE6ZSx0b3VjaGVzOnN9PXQ7MD09PWUudmVsb2NpdGllcy5sZW5ndGgmJmUudmVsb2NpdGllcy5wdXNoKHtwb3NpdGlvbjpzW3QuaXNIb3Jpem9udGFsKCk/XCJzdGFydFhcIjpcInN0YXJ0WVwiXSx0aW1lOmUudG91Y2hTdGFydFRpbWV9KSxlLnZlbG9jaXRpZXMucHVzaCh7cG9zaXRpb246c1t0LmlzSG9yaXpvbnRhbCgpP1wiY3VycmVudFhcIjpcImN1cnJlbnRZXCJdLHRpbWU6dSgpfSl9LG9uVG91Y2hFbmQ6ZnVuY3Rpb24oZSl7bGV0e2N1cnJlbnRQb3M6c309ZTtjb25zdHtwYXJhbXM6ciwkd3JhcHBlckVsOm4scnRsVHJhbnNsYXRlOmwsc25hcEdyaWQ6byx0b3VjaEV2ZW50c0RhdGE6ZH09dCxjPXUoKS1kLnRvdWNoU3RhcnRUaW1lO2lmKHM8LXQubWluVHJhbnNsYXRlKCkpdC5zbGlkZVRvKHQuYWN0aXZlSW5kZXgpO2Vsc2UgaWYocz4tdC5tYXhUcmFuc2xhdGUoKSl0LnNsaWRlcy5sZW5ndGg8by5sZW5ndGg/dC5zbGlkZVRvKG8ubGVuZ3RoLTEpOnQuc2xpZGVUbyh0LnNsaWRlcy5sZW5ndGgtMSk7ZWxzZXtpZihyLmZyZWVNb2RlLm1vbWVudHVtKXtpZihkLnZlbG9jaXRpZXMubGVuZ3RoPjEpe2NvbnN0IGU9ZC52ZWxvY2l0aWVzLnBvcCgpLHM9ZC52ZWxvY2l0aWVzLnBvcCgpLGE9ZS5wb3NpdGlvbi1zLnBvc2l0aW9uLGk9ZS50aW1lLXMudGltZTt0LnZlbG9jaXR5PWEvaSx0LnZlbG9jaXR5Lz0yLE1hdGguYWJzKHQudmVsb2NpdHkpPHIuZnJlZU1vZGUubWluaW11bVZlbG9jaXR5JiYodC52ZWxvY2l0eT0wKSwoaT4xNTB8fHUoKS1lLnRpbWU+MzAwKSYmKHQudmVsb2NpdHk9MCl9ZWxzZSB0LnZlbG9jaXR5PTA7dC52ZWxvY2l0eSo9ci5mcmVlTW9kZS5tb21lbnR1bVZlbG9jaXR5UmF0aW8sZC52ZWxvY2l0aWVzLmxlbmd0aD0wO2xldCBlPTFlMypyLmZyZWVNb2RlLm1vbWVudHVtUmF0aW87Y29uc3Qgcz10LnZlbG9jaXR5KmU7bGV0IGM9dC50cmFuc2xhdGUrcztsJiYoYz0tYyk7bGV0IHAsaD0hMTtjb25zdCBtPTIwKk1hdGguYWJzKHQudmVsb2NpdHkpKnIuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2VSYXRpbztsZXQgZjtpZihjPHQubWF4VHJhbnNsYXRlKCkpci5mcmVlTW9kZS5tb21lbnR1bUJvdW5jZT8oYyt0Lm1heFRyYW5zbGF0ZSgpPC1tJiYoYz10Lm1heFRyYW5zbGF0ZSgpLW0pLHA9dC5tYXhUcmFuc2xhdGUoKSxoPSEwLGQuYWxsb3dNb21lbnR1bUJvdW5jZT0hMCk6Yz10Lm1heFRyYW5zbGF0ZSgpLHIubG9vcCYmci5jZW50ZXJlZFNsaWRlcyYmKGY9ITApO2Vsc2UgaWYoYz50Lm1pblRyYW5zbGF0ZSgpKXIuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2U/KGMtdC5taW5UcmFuc2xhdGUoKT5tJiYoYz10Lm1pblRyYW5zbGF0ZSgpK20pLHA9dC5taW5UcmFuc2xhdGUoKSxoPSEwLGQuYWxsb3dNb21lbnR1bUJvdW5jZT0hMCk6Yz10Lm1pblRyYW5zbGF0ZSgpLHIubG9vcCYmci5jZW50ZXJlZFNsaWRlcyYmKGY9ITApO2Vsc2UgaWYoci5mcmVlTW9kZS5zdGlja3kpe2xldCBlO2ZvcihsZXQgdD0wO3Q8by5sZW5ndGg7dCs9MSlpZihvW3RdPi1jKXtlPXQ7YnJlYWt9Yz1NYXRoLmFicyhvW2VdLWMpPE1hdGguYWJzKG9bZS0xXS1jKXx8XCJuZXh0XCI9PT10LnN3aXBlRGlyZWN0aW9uP29bZV06b1tlLTFdLGM9LWN9aWYoZiYmaShcInRyYW5zaXRpb25FbmRcIiwoKCk9Pnt0Lmxvb3BGaXgoKX0pKSwwIT09dC52ZWxvY2l0eSl7aWYoZT1sP01hdGguYWJzKCgtYy10LnRyYW5zbGF0ZSkvdC52ZWxvY2l0eSk6TWF0aC5hYnMoKGMtdC50cmFuc2xhdGUpL3QudmVsb2NpdHkpLHIuZnJlZU1vZGUuc3RpY2t5KXtjb25zdCBzPU1hdGguYWJzKChsPy1jOmMpLXQudHJhbnNsYXRlKSxhPXQuc2xpZGVzU2l6ZXNHcmlkW3QuYWN0aXZlSW5kZXhdO2U9czxhP3Iuc3BlZWQ6czwyKmE/MS41KnIuc3BlZWQ6Mi41KnIuc3BlZWR9fWVsc2UgaWYoci5mcmVlTW9kZS5zdGlja3kpcmV0dXJuIHZvaWQgdC5zbGlkZVRvQ2xvc2VzdCgpO3IuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2UmJmg/KHQudXBkYXRlUHJvZ3Jlc3MocCksdC5zZXRUcmFuc2l0aW9uKGUpLHQuc2V0VHJhbnNsYXRlKGMpLHQudHJhbnNpdGlvblN0YXJ0KCEwLHQuc3dpcGVEaXJlY3Rpb24pLHQuYW5pbWF0aW5nPSEwLG4udHJhbnNpdGlvbkVuZCgoKCk9Pnt0JiYhdC5kZXN0cm95ZWQmJmQuYWxsb3dNb21lbnR1bUJvdW5jZSYmKGEoXCJtb21lbnR1bUJvdW5jZVwiKSx0LnNldFRyYW5zaXRpb24oci5zcGVlZCksc2V0VGltZW91dCgoKCk9Pnt0LnNldFRyYW5zbGF0ZShwKSxuLnRyYW5zaXRpb25FbmQoKCgpPT57dCYmIXQuZGVzdHJveWVkJiZ0LnRyYW5zaXRpb25FbmQoKX0pKX0pLDApKX0pKSk6dC52ZWxvY2l0eT8oYShcIl9mcmVlTW9kZU5vTW9tZW50dW1SZWxlYXNlXCIpLHQudXBkYXRlUHJvZ3Jlc3MoYyksdC5zZXRUcmFuc2l0aW9uKGUpLHQuc2V0VHJhbnNsYXRlKGMpLHQudHJhbnNpdGlvblN0YXJ0KCEwLHQuc3dpcGVEaXJlY3Rpb24pLHQuYW5pbWF0aW5nfHwodC5hbmltYXRpbmc9ITAsbi50cmFuc2l0aW9uRW5kKCgoKT0+e3QmJiF0LmRlc3Ryb3llZCYmdC50cmFuc2l0aW9uRW5kKCl9KSkpKTp0LnVwZGF0ZVByb2dyZXNzKGMpLHQudXBkYXRlQWN0aXZlSW5kZXgoKSx0LnVwZGF0ZVNsaWRlc0NsYXNzZXMoKX1lbHNle2lmKHIuZnJlZU1vZGUuc3RpY2t5KXJldHVybiB2b2lkIHQuc2xpZGVUb0Nsb3Nlc3QoKTtyLmZyZWVNb2RlJiZhKFwiX2ZyZWVNb2RlTm9Nb21lbnR1bVJlbGVhc2VcIil9KCFyLmZyZWVNb2RlLm1vbWVudHVtfHxjPj1yLmxvbmdTd2lwZXNNcykmJih0LnVwZGF0ZVByb2dyZXNzKCksdC51cGRhdGVBY3RpdmVJbmRleCgpLHQudXBkYXRlU2xpZGVzQ2xhc3NlcygpKX19fX0pfSxmdW5jdGlvbihlKXtsZXQgdCxzLGEse3N3aXBlcjppLGV4dGVuZFBhcmFtczpyfT1lO3Ioe2dyaWQ6e3Jvd3M6MSxmaWxsOlwiY29sdW1uXCJ9fSksaS5ncmlkPXtpbml0U2xpZGVzOmU9Pntjb25zdHtzbGlkZXNQZXJWaWV3OnJ9PWkucGFyYW1zLHtyb3dzOm4sZmlsbDpsfT1pLnBhcmFtcy5ncmlkO3M9dC9uLGE9TWF0aC5mbG9vcihlL24pLHQ9TWF0aC5mbG9vcihlL24pPT09ZS9uP2U6TWF0aC5jZWlsKGUvbikqbixcImF1dG9cIiE9PXImJlwicm93XCI9PT1sJiYodD1NYXRoLm1heCh0LHIqbikpfSx1cGRhdGVTbGlkZTooZSxyLG4sbCk9Pntjb25zdHtzbGlkZXNQZXJHcm91cDpvLHNwYWNlQmV0d2VlbjpkfT1pLnBhcmFtcyx7cm93czpjLGZpbGw6cH09aS5wYXJhbXMuZ3JpZDtsZXQgdSxoLG07aWYoXCJyb3dcIj09PXAmJm8+MSl7Y29uc3Qgcz1NYXRoLmZsb29yKGUvKG8qYykpLGE9ZS1jKm8qcyxpPTA9PT1zP286TWF0aC5taW4oTWF0aC5jZWlsKChuLXMqYypvKS9jKSxvKTttPU1hdGguZmxvb3IoYS9pKSxoPWEtbSppK3Mqbyx1PWgrbSp0L2Msci5jc3Moe1wiLXdlYmtpdC1vcmRlclwiOnUsb3JkZXI6dX0pfWVsc2VcImNvbHVtblwiPT09cD8oaD1NYXRoLmZsb29yKGUvYyksbT1lLWgqYywoaD5hfHxoPT09YSYmbT09PWMtMSkmJihtKz0xLG0+PWMmJihtPTAsaCs9MSkpKToobT1NYXRoLmZsb29yKGUvcyksaD1lLW0qcyk7ci5jc3MobChcIm1hcmdpbi10b3BcIiksMCE9PW0/ZCYmYCR7ZH1weGA6XCJcIil9LHVwZGF0ZVdyYXBwZXJTaXplOihlLHMsYSk9Pntjb25zdHtzcGFjZUJldHdlZW46cixjZW50ZXJlZFNsaWRlczpuLHJvdW5kTGVuZ3RoczpsfT1pLnBhcmFtcyx7cm93czpvfT1pLnBhcmFtcy5ncmlkO2lmKGkudmlydHVhbFNpemU9KGUrcikqdCxpLnZpcnR1YWxTaXplPU1hdGguY2VpbChpLnZpcnR1YWxTaXplL28pLXIsaS4kd3JhcHBlckVsLmNzcyh7W2EoXCJ3aWR0aFwiKV06YCR7aS52aXJ0dWFsU2l6ZStyfXB4YH0pLG4pe3Muc3BsaWNlKDAscy5sZW5ndGgpO2NvbnN0IGU9W107Zm9yKGxldCB0PTA7dDxzLmxlbmd0aDt0Kz0xKXtsZXQgYT1zW3RdO2wmJihhPU1hdGguZmxvb3IoYSkpLHNbdF08aS52aXJ0dWFsU2l6ZStzWzBdJiZlLnB1c2goYSl9cy5wdXNoKC4uLmUpfX19fSxmdW5jdGlvbihlKXtsZXR7c3dpcGVyOnR9PWU7T2JqZWN0LmFzc2lnbih0LHthcHBlbmRTbGlkZTpLLmJpbmQodCkscHJlcGVuZFNsaWRlOlouYmluZCh0KSxhZGRTbGlkZTpRLmJpbmQodCkscmVtb3ZlU2xpZGU6Si5iaW5kKHQpLHJlbW92ZUFsbFNsaWRlczplZS5iaW5kKHQpfSl9LGZ1bmN0aW9uKGUpe2xldHtzd2lwZXI6dCxleHRlbmRQYXJhbXM6cyxvbjphfT1lO3Moe2ZhZGVFZmZlY3Q6e2Nyb3NzRmFkZTohMSx0cmFuc2Zvcm1FbDpudWxsfX0pLHRlKHtlZmZlY3Q6XCJmYWRlXCIsc3dpcGVyOnQsb246YSxzZXRUcmFuc2xhdGU6KCk9Pntjb25zdHtzbGlkZXM6ZX09dCxzPXQucGFyYW1zLmZhZGVFZmZlY3Q7Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDthKz0xKXtjb25zdCBlPXQuc2xpZGVzLmVxKGEpO2xldCBpPS1lWzBdLnN3aXBlclNsaWRlT2Zmc2V0O3QucGFyYW1zLnZpcnR1YWxUcmFuc2xhdGV8fChpLT10LnRyYW5zbGF0ZSk7bGV0IHI9MDt0LmlzSG9yaXpvbnRhbCgpfHwocj1pLGk9MCk7Y29uc3Qgbj10LnBhcmFtcy5mYWRlRWZmZWN0LmNyb3NzRmFkZT9NYXRoLm1heCgxLU1hdGguYWJzKGVbMF0ucHJvZ3Jlc3MpLDApOjErTWF0aC5taW4oTWF0aC5tYXgoZVswXS5wcm9ncmVzcywtMSksMCk7c2UocyxlKS5jc3Moe29wYWNpdHk6bn0pLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtpfXB4LCAke3J9cHgsIDBweClgKX19LHNldFRyYW5zaXRpb246ZT0+e2NvbnN0e3RyYW5zZm9ybUVsOnN9PXQucGFyYW1zLmZhZGVFZmZlY3Q7KHM/dC5zbGlkZXMuZmluZChzKTp0LnNsaWRlcykudHJhbnNpdGlvbihlKSxhZSh7c3dpcGVyOnQsZHVyYXRpb246ZSx0cmFuc2Zvcm1FbDpzLGFsbFNsaWRlczohMH0pfSxvdmVyd3JpdGVQYXJhbXM6KCk9Pih7c2xpZGVzUGVyVmlldzoxLHNsaWRlc1Blckdyb3VwOjEsd2F0Y2hTbGlkZXNQcm9ncmVzczohMCxzcGFjZUJldHdlZW46MCx2aXJ0dWFsVHJhbnNsYXRlOiF0LnBhcmFtcy5jc3NNb2RlfSl9KX0sZnVuY3Rpb24oZSl7bGV0e3N3aXBlcjp0LGV4dGVuZFBhcmFtczpzLG9uOmF9PWU7cyh7Y3ViZUVmZmVjdDp7c2xpZGVTaGFkb3dzOiEwLHNoYWRvdzohMCxzaGFkb3dPZmZzZXQ6MjAsc2hhZG93U2NhbGU6Ljk0fX0pO2NvbnN0IGk9KGUsdCxzKT0+e2xldCBhPXM/ZS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKTplLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3BcIiksaT1zP2UuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0XCIpOmUuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbVwiKTswPT09YS5sZW5ndGgmJihhPWQoYDxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LSR7cz9cImxlZnRcIjpcInRvcFwifVwiPjwvZGl2PmApLGUuYXBwZW5kKGEpKSwwPT09aS5sZW5ndGgmJihpPWQoYDxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LSR7cz9cInJpZ2h0XCI6XCJib3R0b21cIn1cIj48L2Rpdj5gKSxlLmFwcGVuZChpKSksYS5sZW5ndGgmJihhWzBdLnN0eWxlLm9wYWNpdHk9TWF0aC5tYXgoLXQsMCkpLGkubGVuZ3RoJiYoaVswXS5zdHlsZS5vcGFjaXR5PU1hdGgubWF4KHQsMCkpfTt0ZSh7ZWZmZWN0OlwiY3ViZVwiLHN3aXBlcjp0LG9uOmEsc2V0VHJhbnNsYXRlOigpPT57Y29uc3R7JGVsOmUsJHdyYXBwZXJFbDpzLHNsaWRlczphLHdpZHRoOnIsaGVpZ2h0Om4scnRsVHJhbnNsYXRlOmwsc2l6ZTpvLGJyb3dzZXI6Y309dCxwPXQucGFyYW1zLmN1YmVFZmZlY3QsdT10LmlzSG9yaXpvbnRhbCgpLGg9dC52aXJ0dWFsJiZ0LnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7bGV0IG0sZj0wO3Auc2hhZG93JiYodT8obT1zLmZpbmQoXCIuc3dpcGVyLWN1YmUtc2hhZG93XCIpLDA9PT1tLmxlbmd0aCYmKG09ZCgnPGRpdiBjbGFzcz1cInN3aXBlci1jdWJlLXNoYWRvd1wiPjwvZGl2PicpLHMuYXBwZW5kKG0pKSxtLmNzcyh7aGVpZ2h0OmAke3J9cHhgfSkpOihtPWUuZmluZChcIi5zd2lwZXItY3ViZS1zaGFkb3dcIiksMD09PW0ubGVuZ3RoJiYobT1kKCc8ZGl2IGNsYXNzPVwic3dpcGVyLWN1YmUtc2hhZG93XCI+PC9kaXY+JyksZS5hcHBlbmQobSkpKSk7Zm9yKGxldCBlPTA7ZTxhLmxlbmd0aDtlKz0xKXtjb25zdCB0PWEuZXEoZSk7bGV0IHM9ZTtoJiYocz1wYXJzZUludCh0LmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSwxMCkpO2xldCByPTkwKnMsbj1NYXRoLmZsb29yKHIvMzYwKTtsJiYocj0tcixuPU1hdGguZmxvb3IoLXIvMzYwKSk7Y29uc3QgZD1NYXRoLm1heChNYXRoLm1pbih0WzBdLnByb2dyZXNzLDEpLC0xKTtsZXQgYz0wLG09MCxnPTA7cyU0PT0wPyhjPTQqLW4qbyxnPTApOihzLTEpJTQ9PTA/KGM9MCxnPTQqLW4qbyk6KHMtMiklND09MD8oYz1vKzQqbipvLGc9byk6KHMtMyklND09MCYmKGM9LW8sZz0zKm8rNCpvKm4pLGwmJihjPS1jKSx1fHwobT1jLGM9MCk7Y29uc3Qgdj1gcm90YXRlWCgke3U/MDotcn1kZWcpIHJvdGF0ZVkoJHt1P3I6MH1kZWcpIHRyYW5zbGF0ZTNkKCR7Y31weCwgJHttfXB4LCAke2d9cHgpYDtkPD0xJiZkPi0xJiYoZj05MCpzKzkwKmQsbCYmKGY9OTAqLXMtOTAqZCkpLHQudHJhbnNmb3JtKHYpLHAuc2xpZGVTaGFkb3dzJiZpKHQsZCx1KX1pZihzLmNzcyh7XCItd2Via2l0LXRyYW5zZm9ybS1vcmlnaW5cIjpgNTAlIDUwJSAtJHtvLzJ9cHhgLFwidHJhbnNmb3JtLW9yaWdpblwiOmA1MCUgNTAlIC0ke28vMn1weGB9KSxwLnNoYWRvdylpZih1KW0udHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwcHgsICR7ci8yK3Auc2hhZG93T2Zmc2V0fXB4LCAkey1yLzJ9cHgpIHJvdGF0ZVgoOTBkZWcpIHJvdGF0ZVooMGRlZykgc2NhbGUoJHtwLnNoYWRvd1NjYWxlfSlgKTtlbHNle2NvbnN0IGU9TWF0aC5hYnMoZiktOTAqTWF0aC5mbG9vcihNYXRoLmFicyhmKS85MCksdD0xLjUtKE1hdGguc2luKDIqZSpNYXRoLlBJLzM2MCkvMitNYXRoLmNvcygyKmUqTWF0aC5QSS8zNjApLzIpLHM9cC5zaGFkb3dTY2FsZSxhPXAuc2hhZG93U2NhbGUvdCxpPXAuc2hhZG93T2Zmc2V0O20udHJhbnNmb3JtKGBzY2FsZTNkKCR7c30sIDEsICR7YX0pIHRyYW5zbGF0ZTNkKDBweCwgJHtuLzIraX1weCwgJHstbi8yL2F9cHgpIHJvdGF0ZVgoLTkwZGVnKWApfWNvbnN0IGc9Yy5pc1NhZmFyaXx8Yy5pc1dlYlZpZXc/LW8vMjowO3MudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwcHgsMCwke2d9cHgpIHJvdGF0ZVgoJHt0LmlzSG9yaXpvbnRhbCgpPzA6Zn1kZWcpIHJvdGF0ZVkoJHt0LmlzSG9yaXpvbnRhbCgpPy1mOjB9ZGVnKWApLHNbMF0uc3R5bGUuc2V0UHJvcGVydHkoXCItLXN3aXBlci1jdWJlLXRyYW5zbGF0ZS16XCIsYCR7Z31weGApfSxzZXRUcmFuc2l0aW9uOmU9Pntjb25zdHskZWw6cyxzbGlkZXM6YX09dDthLnRyYW5zaXRpb24oZSkuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKS50cmFuc2l0aW9uKGUpLHQucGFyYW1zLmN1YmVFZmZlY3Quc2hhZG93JiYhdC5pc0hvcml6b250YWwoKSYmcy5maW5kKFwiLnN3aXBlci1jdWJlLXNoYWRvd1wiKS50cmFuc2l0aW9uKGUpfSxyZWNyZWF0ZVNoYWRvd3M6KCk9Pntjb25zdCBlPXQuaXNIb3Jpem9udGFsKCk7dC5zbGlkZXMuZWFjaCgodD0+e2NvbnN0IHM9TWF0aC5tYXgoTWF0aC5taW4odC5wcm9ncmVzcywxKSwtMSk7aShkKHQpLHMsZSl9KSl9LGdldEVmZmVjdFBhcmFtczooKT0+dC5wYXJhbXMuY3ViZUVmZmVjdCxwZXJzcGVjdGl2ZTooKT0+ITAsb3ZlcndyaXRlUGFyYW1zOigpPT4oe3NsaWRlc1BlclZpZXc6MSxzbGlkZXNQZXJHcm91cDoxLHdhdGNoU2xpZGVzUHJvZ3Jlc3M6ITAscmVzaXN0YW5jZVJhdGlvOjAsc3BhY2VCZXR3ZWVuOjAsY2VudGVyZWRTbGlkZXM6ITEsdmlydHVhbFRyYW5zbGF0ZTohMH0pfSl9LGZ1bmN0aW9uKGUpe2xldHtzd2lwZXI6dCxleHRlbmRQYXJhbXM6cyxvbjphfT1lO3Moe2ZsaXBFZmZlY3Q6e3NsaWRlU2hhZG93czohMCxsaW1pdFJvdGF0aW9uOiEwLHRyYW5zZm9ybUVsOm51bGx9fSk7Y29uc3QgaT0oZSxzLGEpPT57bGV0IGk9dC5pc0hvcml6b250YWwoKT9lLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0XCIpOmUuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcFwiKSxyPXQuaXNIb3Jpem9udGFsKCk/ZS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHRcIik6ZS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tXCIpOzA9PT1pLmxlbmd0aCYmKGk9aWUoYSxlLHQuaXNIb3Jpem9udGFsKCk/XCJsZWZ0XCI6XCJ0b3BcIikpLDA9PT1yLmxlbmd0aCYmKHI9aWUoYSxlLHQuaXNIb3Jpem9udGFsKCk/XCJyaWdodFwiOlwiYm90dG9tXCIpKSxpLmxlbmd0aCYmKGlbMF0uc3R5bGUub3BhY2l0eT1NYXRoLm1heCgtcywwKSksci5sZW5ndGgmJihyWzBdLnN0eWxlLm9wYWNpdHk9TWF0aC5tYXgocywwKSl9O3RlKHtlZmZlY3Q6XCJmbGlwXCIsc3dpcGVyOnQsb246YSxzZXRUcmFuc2xhdGU6KCk9Pntjb25zdHtzbGlkZXM6ZSxydGxUcmFuc2xhdGU6c309dCxhPXQucGFyYW1zLmZsaXBFZmZlY3Q7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKz0xKXtjb25zdCBuPWUuZXEocik7bGV0IGw9blswXS5wcm9ncmVzczt0LnBhcmFtcy5mbGlwRWZmZWN0LmxpbWl0Um90YXRpb24mJihsPU1hdGgubWF4KE1hdGgubWluKG5bMF0ucHJvZ3Jlc3MsMSksLTEpKTtjb25zdCBvPW5bMF0uc3dpcGVyU2xpZGVPZmZzZXQ7bGV0IGQ9LTE4MCpsLGM9MCxwPXQucGFyYW1zLmNzc01vZGU/LW8tdC50cmFuc2xhdGU6LW8sdT0wO3QuaXNIb3Jpem9udGFsKCk/cyYmKGQ9LWQpOih1PXAscD0wLGM9LWQsZD0wKSxuWzBdLnN0eWxlLnpJbmRleD0tTWF0aC5hYnMoTWF0aC5yb3VuZChsKSkrZS5sZW5ndGgsYS5zbGlkZVNoYWRvd3MmJmkobixsLGEpO2NvbnN0IGg9YHRyYW5zbGF0ZTNkKCR7cH1weCwgJHt1fXB4LCAwcHgpIHJvdGF0ZVgoJHtjfWRlZykgcm90YXRlWSgke2R9ZGVnKWA7c2UoYSxuKS50cmFuc2Zvcm0oaCl9fSxzZXRUcmFuc2l0aW9uOmU9Pntjb25zdHt0cmFuc2Zvcm1FbDpzfT10LnBhcmFtcy5mbGlwRWZmZWN0OyhzP3Quc2xpZGVzLmZpbmQocyk6dC5zbGlkZXMpLnRyYW5zaXRpb24oZSkuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKS50cmFuc2l0aW9uKGUpLGFlKHtzd2lwZXI6dCxkdXJhdGlvbjplLHRyYW5zZm9ybUVsOnN9KX0scmVjcmVhdGVTaGFkb3dzOigpPT57Y29uc3QgZT10LnBhcmFtcy5mbGlwRWZmZWN0O3Quc2xpZGVzLmVhY2goKHM9Pntjb25zdCBhPWQocyk7bGV0IHI9YVswXS5wcm9ncmVzczt0LnBhcmFtcy5mbGlwRWZmZWN0LmxpbWl0Um90YXRpb24mJihyPU1hdGgubWF4KE1hdGgubWluKHMucHJvZ3Jlc3MsMSksLTEpKSxpKGEscixlKX0pKX0sZ2V0RWZmZWN0UGFyYW1zOigpPT50LnBhcmFtcy5mbGlwRWZmZWN0LHBlcnNwZWN0aXZlOigpPT4hMCxvdmVyd3JpdGVQYXJhbXM6KCk9Pih7c2xpZGVzUGVyVmlldzoxLHNsaWRlc1Blckdyb3VwOjEsd2F0Y2hTbGlkZXNQcm9ncmVzczohMCxzcGFjZUJldHdlZW46MCx2aXJ0dWFsVHJhbnNsYXRlOiF0LnBhcmFtcy5jc3NNb2RlfSl9KX0sZnVuY3Rpb24oZSl7bGV0e3N3aXBlcjp0LGV4dGVuZFBhcmFtczpzLG9uOmF9PWU7cyh7Y292ZXJmbG93RWZmZWN0Ontyb3RhdGU6NTAsc3RyZXRjaDowLGRlcHRoOjEwMCxzY2FsZToxLG1vZGlmaWVyOjEsc2xpZGVTaGFkb3dzOiEwLHRyYW5zZm9ybUVsOm51bGx9fSksdGUoe2VmZmVjdDpcImNvdmVyZmxvd1wiLHN3aXBlcjp0LG9uOmEsc2V0VHJhbnNsYXRlOigpPT57Y29uc3R7d2lkdGg6ZSxoZWlnaHQ6cyxzbGlkZXM6YSxzbGlkZXNTaXplc0dyaWQ6aX09dCxyPXQucGFyYW1zLmNvdmVyZmxvd0VmZmVjdCxuPXQuaXNIb3Jpem9udGFsKCksbD10LnRyYW5zbGF0ZSxvPW4/ZS8yLWw6cy8yLWwsZD1uP3Iucm90YXRlOi1yLnJvdGF0ZSxjPXIuZGVwdGg7Zm9yKGxldCBlPTAsdD1hLmxlbmd0aDtlPHQ7ZSs9MSl7Y29uc3QgdD1hLmVxKGUpLHM9aVtlXSxsPShvLXRbMF0uc3dpcGVyU2xpZGVPZmZzZXQtcy8yKS9zLHA9XCJmdW5jdGlvblwiPT10eXBlb2Ygci5tb2RpZmllcj9yLm1vZGlmaWVyKGwpOmwqci5tb2RpZmllcjtsZXQgdT1uP2QqcDowLGg9bj8wOmQqcCxtPS1jKk1hdGguYWJzKHApLGY9ci5zdHJldGNoO1wic3RyaW5nXCI9PXR5cGVvZiBmJiYtMSE9PWYuaW5kZXhPZihcIiVcIikmJihmPXBhcnNlRmxvYXQoci5zdHJldGNoKS8xMDAqcyk7bGV0IGc9bj8wOmYqcCx2PW4/ZipwOjAsdz0xLSgxLXIuc2NhbGUpKk1hdGguYWJzKHApO01hdGguYWJzKHYpPC4wMDEmJih2PTApLE1hdGguYWJzKGcpPC4wMDEmJihnPTApLE1hdGguYWJzKG0pPC4wMDEmJihtPTApLE1hdGguYWJzKHUpPC4wMDEmJih1PTApLE1hdGguYWJzKGgpPC4wMDEmJihoPTApLE1hdGguYWJzKHcpPC4wMDEmJih3PTApO2NvbnN0IGI9YHRyYW5zbGF0ZTNkKCR7dn1weCwke2d9cHgsJHttfXB4KSAgcm90YXRlWCgke2h9ZGVnKSByb3RhdGVZKCR7dX1kZWcpIHNjYWxlKCR7d30pYDtpZihzZShyLHQpLnRyYW5zZm9ybShiKSx0WzBdLnN0eWxlLnpJbmRleD0xLU1hdGguYWJzKE1hdGgucm91bmQocCkpLHIuc2xpZGVTaGFkb3dzKXtsZXQgZT1uP3QuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnRcIik6dC5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wXCIpLHM9bj90LmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodFwiKTp0LmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b21cIik7MD09PWUubGVuZ3RoJiYoZT1pZShyLHQsbj9cImxlZnRcIjpcInRvcFwiKSksMD09PXMubGVuZ3RoJiYocz1pZShyLHQsbj9cInJpZ2h0XCI6XCJib3R0b21cIikpLGUubGVuZ3RoJiYoZVswXS5zdHlsZS5vcGFjaXR5PXA+MD9wOjApLHMubGVuZ3RoJiYoc1swXS5zdHlsZS5vcGFjaXR5PS1wPjA/LXA6MCl9fX0sc2V0VHJhbnNpdGlvbjplPT57Y29uc3R7dHJhbnNmb3JtRWw6c309dC5wYXJhbXMuY292ZXJmbG93RWZmZWN0OyhzP3Quc2xpZGVzLmZpbmQocyk6dC5zbGlkZXMpLnRyYW5zaXRpb24oZSkuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKS50cmFuc2l0aW9uKGUpfSxwZXJzcGVjdGl2ZTooKT0+ITAsb3ZlcndyaXRlUGFyYW1zOigpPT4oe3dhdGNoU2xpZGVzUHJvZ3Jlc3M6ITB9KX0pfSxmdW5jdGlvbihlKXtsZXR7c3dpcGVyOnQsZXh0ZW5kUGFyYW1zOnMsb246YX09ZTtzKHtjcmVhdGl2ZUVmZmVjdDp7dHJhbnNmb3JtRWw6bnVsbCxsaW1pdFByb2dyZXNzOjEsc2hhZG93UGVyUHJvZ3Jlc3M6ITEscHJvZ3Jlc3NNdWx0aXBsaWVyOjEscGVyc3BlY3RpdmU6ITAscHJldjp7dHJhbnNsYXRlOlswLDAsMF0scm90YXRlOlswLDAsMF0sb3BhY2l0eToxLHNjYWxlOjF9LG5leHQ6e3RyYW5zbGF0ZTpbMCwwLDBdLHJvdGF0ZTpbMCwwLDBdLG9wYWNpdHk6MSxzY2FsZToxfX19KTtjb25zdCBpPWU9Plwic3RyaW5nXCI9PXR5cGVvZiBlP2U6YCR7ZX1weGA7dGUoe2VmZmVjdDpcImNyZWF0aXZlXCIsc3dpcGVyOnQsb246YSxzZXRUcmFuc2xhdGU6KCk9Pntjb25zdHtzbGlkZXM6ZSwkd3JhcHBlckVsOnMsc2xpZGVzU2l6ZXNHcmlkOmF9PXQscj10LnBhcmFtcy5jcmVhdGl2ZUVmZmVjdCx7cHJvZ3Jlc3NNdWx0aXBsaWVyOm59PXIsbD10LnBhcmFtcy5jZW50ZXJlZFNsaWRlcztpZihsKXtjb25zdCBlPWFbMF0vMi10LnBhcmFtcy5zbGlkZXNPZmZzZXRCZWZvcmV8fDA7cy50cmFuc2Zvcm0oYHRyYW5zbGF0ZVgoY2FsYyg1MCUgLSAke2V9cHgpKWApfWZvcihsZXQgcz0wO3M8ZS5sZW5ndGg7cys9MSl7Y29uc3QgYT1lLmVxKHMpLG89YVswXS5wcm9ncmVzcyxkPU1hdGgubWluKE1hdGgubWF4KGFbMF0ucHJvZ3Jlc3MsLXIubGltaXRQcm9ncmVzcyksci5saW1pdFByb2dyZXNzKTtsZXQgYz1kO2x8fChjPU1hdGgubWluKE1hdGgubWF4KGFbMF0ub3JpZ2luYWxQcm9ncmVzcywtci5saW1pdFByb2dyZXNzKSxyLmxpbWl0UHJvZ3Jlc3MpKTtjb25zdCBwPWFbMF0uc3dpcGVyU2xpZGVPZmZzZXQsdT1bdC5wYXJhbXMuY3NzTW9kZT8tcC10LnRyYW5zbGF0ZTotcCwwLDBdLGg9WzAsMCwwXTtsZXQgbT0hMTt0LmlzSG9yaXpvbnRhbCgpfHwodVsxXT11WzBdLHVbMF09MCk7bGV0IGY9e3RyYW5zbGF0ZTpbMCwwLDBdLHJvdGF0ZTpbMCwwLDBdLHNjYWxlOjEsb3BhY2l0eToxfTtkPDA/KGY9ci5uZXh0LG09ITApOmQ+MCYmKGY9ci5wcmV2LG09ITApLHUuZm9yRWFjaCgoKGUsdCk9Pnt1W3RdPWBjYWxjKCR7ZX1weCArICgke2koZi50cmFuc2xhdGVbdF0pfSAqICR7TWF0aC5hYnMoZCpuKX0pKWB9KSksaC5mb3JFYWNoKCgoZSx0KT0+e2hbdF09Zi5yb3RhdGVbdF0qTWF0aC5hYnMoZCpuKX0pKSxhWzBdLnN0eWxlLnpJbmRleD0tTWF0aC5hYnMoTWF0aC5yb3VuZChvKSkrZS5sZW5ndGg7Y29uc3QgZz11LmpvaW4oXCIsIFwiKSx2PWByb3RhdGVYKCR7aFswXX1kZWcpIHJvdGF0ZVkoJHtoWzFdfWRlZykgcm90YXRlWigke2hbMl19ZGVnKWAsdz1jPDA/YHNjYWxlKCR7MSsoMS1mLnNjYWxlKSpjKm59KWA6YHNjYWxlKCR7MS0oMS1mLnNjYWxlKSpjKm59KWAsYj1jPDA/MSsoMS1mLm9wYWNpdHkpKmMqbjoxLSgxLWYub3BhY2l0eSkqYypuLHg9YHRyYW5zbGF0ZTNkKCR7Z30pICR7dn0gJHt3fWA7aWYobSYmZi5zaGFkb3d8fCFtKXtsZXQgZT1hLmNoaWxkcmVuKFwiLnN3aXBlci1zbGlkZS1zaGFkb3dcIik7aWYoMD09PWUubGVuZ3RoJiZmLnNoYWRvdyYmKGU9aWUocixhKSksZS5sZW5ndGgpe2NvbnN0IHQ9ci5zaGFkb3dQZXJQcm9ncmVzcz9kKigxL3IubGltaXRQcm9ncmVzcyk6ZDtlWzBdLnN0eWxlLm9wYWNpdHk9TWF0aC5taW4oTWF0aC5tYXgoTWF0aC5hYnModCksMCksMSl9fWNvbnN0IHk9c2UocixhKTt5LnRyYW5zZm9ybSh4KS5jc3Moe29wYWNpdHk6Yn0pLGYub3JpZ2luJiZ5LmNzcyhcInRyYW5zZm9ybS1vcmlnaW5cIixmLm9yaWdpbil9fSxzZXRUcmFuc2l0aW9uOmU9Pntjb25zdHt0cmFuc2Zvcm1FbDpzfT10LnBhcmFtcy5jcmVhdGl2ZUVmZmVjdDsocz90LnNsaWRlcy5maW5kKHMpOnQuc2xpZGVzKS50cmFuc2l0aW9uKGUpLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvd1wiKS50cmFuc2l0aW9uKGUpLGFlKHtzd2lwZXI6dCxkdXJhdGlvbjplLHRyYW5zZm9ybUVsOnMsYWxsU2xpZGVzOiEwfSl9LHBlcnNwZWN0aXZlOigpPT50LnBhcmFtcy5jcmVhdGl2ZUVmZmVjdC5wZXJzcGVjdGl2ZSxvdmVyd3JpdGVQYXJhbXM6KCk9Pih7d2F0Y2hTbGlkZXNQcm9ncmVzczohMCx2aXJ0dWFsVHJhbnNsYXRlOiF0LnBhcmFtcy5jc3NNb2RlfSl9KX0sZnVuY3Rpb24oZSl7bGV0e3N3aXBlcjp0LGV4dGVuZFBhcmFtczpzLG9uOmF9PWU7cyh7Y2FyZHNFZmZlY3Q6e3NsaWRlU2hhZG93czohMCx0cmFuc2Zvcm1FbDpudWxsLHJvdGF0ZTohMH19KSx0ZSh7ZWZmZWN0OlwiY2FyZHNcIixzd2lwZXI6dCxvbjphLHNldFRyYW5zbGF0ZTooKT0+e2NvbnN0e3NsaWRlczplLGFjdGl2ZUluZGV4OnN9PXQsYT10LnBhcmFtcy5jYXJkc0VmZmVjdCx7c3RhcnRUcmFuc2xhdGU6aSxpc1RvdWNoZWQ6cn09dC50b3VjaEV2ZW50c0RhdGEsbj10LnRyYW5zbGF0ZTtmb3IobGV0IGw9MDtsPGUubGVuZ3RoO2wrPTEpe2NvbnN0IG89ZS5lcShsKSxkPW9bMF0ucHJvZ3Jlc3MsYz1NYXRoLm1pbihNYXRoLm1heChkLC00KSw0KTtsZXQgcD1vWzBdLnN3aXBlclNsaWRlT2Zmc2V0O3QucGFyYW1zLmNlbnRlcmVkU2xpZGVzJiYhdC5wYXJhbXMuY3NzTW9kZSYmdC4kd3JhcHBlckVsLnRyYW5zZm9ybShgdHJhbnNsYXRlWCgke3QubWluVHJhbnNsYXRlKCl9cHgpYCksdC5wYXJhbXMuY2VudGVyZWRTbGlkZXMmJnQucGFyYW1zLmNzc01vZGUmJihwLT1lWzBdLnN3aXBlclNsaWRlT2Zmc2V0KTtsZXQgdT10LnBhcmFtcy5jc3NNb2RlPy1wLXQudHJhbnNsYXRlOi1wLGg9MDtjb25zdCBtPS0xMDAqTWF0aC5hYnMoYyk7bGV0IGY9MSxnPS0yKmMsdj04LS43NSpNYXRoLmFicyhjKTtjb25zdCB3PXQudmlydHVhbCYmdC5wYXJhbXMudmlydHVhbC5lbmFibGVkP3QudmlydHVhbC5mcm9tK2w6bCxiPSh3PT09c3x8dz09PXMtMSkmJmM+MCYmYzwxJiYocnx8dC5wYXJhbXMuY3NzTW9kZSkmJm48aSx4PSh3PT09c3x8dz09PXMrMSkmJmM8MCYmYz4tMSYmKHJ8fHQucGFyYW1zLmNzc01vZGUpJiZuPmk7aWYoYnx8eCl7Y29uc3QgZT0oMS1NYXRoLmFicygoTWF0aC5hYnMoYyktLjUpLy41KSkqKi41O2crPS0yOCpjKmUsZis9LS41KmUsdis9OTYqZSxoPS0yNSplKk1hdGguYWJzKGMpK1wiJVwifWlmKHU9YzwwP2BjYWxjKCR7dX1weCArICgke3YqTWF0aC5hYnMoYyl9JSkpYDpjPjA/YGNhbGMoJHt1fXB4ICsgKC0ke3YqTWF0aC5hYnMoYyl9JSkpYDpgJHt1fXB4YCwhdC5pc0hvcml6b250YWwoKSl7Y29uc3QgZT1oO2g9dSx1PWV9Y29uc3QgeT1jPDA/XCJcIisoMSsoMS1mKSpjKTpcIlwiKygxLSgxLWYpKmMpLEU9YFxcbiAgICAgICAgdHJhbnNsYXRlM2QoJHt1fSwgJHtofSwgJHttfXB4KVxcbiAgICAgICAgcm90YXRlWigke2Eucm90YXRlP2c6MH1kZWcpXFxuICAgICAgICBzY2FsZSgke3l9KVxcbiAgICAgIGA7aWYoYS5zbGlkZVNoYWRvd3Mpe2xldCBlPW8uZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93XCIpOzA9PT1lLmxlbmd0aCYmKGU9aWUoYSxvKSksZS5sZW5ndGgmJihlWzBdLnN0eWxlLm9wYWNpdHk9TWF0aC5taW4oTWF0aC5tYXgoKE1hdGguYWJzKGMpLS41KS8uNSwwKSwxKSl9b1swXS5zdHlsZS56SW5kZXg9LU1hdGguYWJzKE1hdGgucm91bmQoZCkpK2UubGVuZ3RoO3NlKGEsbykudHJhbnNmb3JtKEUpfX0sc2V0VHJhbnNpdGlvbjplPT57Y29uc3R7dHJhbnNmb3JtRWw6c309dC5wYXJhbXMuY2FyZHNFZmZlY3Q7KHM/dC5zbGlkZXMuZmluZChzKTp0LnNsaWRlcykudHJhbnNpdGlvbihlKS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3dcIikudHJhbnNpdGlvbihlKSxhZSh7c3dpcGVyOnQsZHVyYXRpb246ZSx0cmFuc2Zvcm1FbDpzfSl9LHBlcnNwZWN0aXZlOigpPT4hMCxvdmVyd3JpdGVQYXJhbXM6KCk9Pih7d2F0Y2hTbGlkZXNQcm9ncmVzczohMCx2aXJ0dWFsVHJhbnNsYXRlOiF0LnBhcmFtcy5jc3NNb2RlfSl9KX1dO3JldHVybiBWLnVzZShyZSksVn0pKTtcclxuIl0sImZpbGUiOiJzd2lwZXItYnVuZGxlLm1pbi5qcyJ9
